/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import globalAxios from "axios";
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setSearchParams, toPathString, createRequestFunction } from './common.js';
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { BASE_PATH, BaseAPI } from './base.js';
export const TabularExportRequestFormatEnum = {
    CSV: "CSV",
    XLSX: "XLSX",
};
/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create visual - pdf export request
         * @param {string} workspaceId
         * @param {PdfExportRequest} pdfExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPdfExport: async (workspaceId, pdfExportRequest, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createPdfExport", "workspaceId", workspaceId);
            // verify required parameter 'pdfExportRequest' is not null or undefined
            assertParamExists("createPdfExport", "pdfExportRequest", pdfExportRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof pdfExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(pdfExportRequest !== undefined ? pdfExportRequest : {})
                : pdfExportRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create tabular export request
         * @param {string} workspaceId
         * @param {TabularExportRequest} tabularExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTabularExport: async (workspaceId, tabularExportRequest, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createTabularExport", "workspaceId", workspaceId);
            // verify required parameter 'tabularExportRequest' is not null or undefined
            assertParamExists("createTabularExport", "tabularExportRequest", tabularExportRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/tabular`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof tabularExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(tabularExportRequest !== undefined ? tabularExportRequest : {})
                : tabularExportRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportedFile: async (workspaceId, exportId, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getExportedFile", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getExportedFile", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoints serves as a cache for user defined metadata for the front end ui to retrieve them, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified. If metadata for given {exportId} has been found, endpoint returns the value 200 else 404.
         * @summary Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (workspaceId, exportId, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getMetadata", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getMetadata", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual/{exportId}/metadata`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTabularExport: async (workspaceId, exportId, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getTabularExport", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getTabularExport", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/tabular/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration);
    return {
        /**
         * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create visual - pdf export request
         * @param {string} workspaceId
         * @param {PdfExportRequest} pdfExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPdfExport(workspaceId, pdfExportRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPdfExport(workspaceId, pdfExportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create tabular export request
         * @param {string} workspaceId
         * @param {TabularExportRequest} tabularExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTabularExport(workspaceId, tabularExportRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTabularExport(workspaceId, tabularExportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExportedFile(workspaceId, exportId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExportedFile(workspaceId, exportId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoints serves as a cache for user defined metadata for the front end ui to retrieve them, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified. If metadata for given {exportId} has been found, endpoint returns the value 200 else 404.
         * @summary Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(workspaceId, exportId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadata(workspaceId, exportId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTabularExport(workspaceId, exportId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTabularExport(workspaceId, exportId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ActionsApiFp(configuration);
    return {
        /**
         * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create visual - pdf export request
         * @param {ActionsApiCreatePdfExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPdfExport(requestParameters, options) {
            return localVarFp
                .createPdfExport(requestParameters.workspaceId, requestParameters.pdfExportRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create tabular export request
         * @param {ActionsApiCreateTabularExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTabularExport(requestParameters, options) {
            return localVarFp
                .createTabularExport(requestParameters.workspaceId, requestParameters.tabularExportRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
         * @summary Retrieve exported files
         * @param {ActionsApiGetExportedFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportedFile(requestParameters, options) {
            return localVarFp
                .getExportedFile(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * This endpoints serves as a cache for user defined metadata for the front end ui to retrieve them, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified. If metadata for given {exportId} has been found, endpoint returns the value 200 else 404.
         * @summary Retrieve metadata context
         * @param {ActionsApiGetMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(requestParameters, options) {
            return localVarFp
                .getMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary Retrieve exported files
         * @param {ActionsApiGetTabularExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTabularExport(requestParameters, options) {
            return localVarFp
                .getTabularExport(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI {
    /**
     * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create visual - pdf export request
     * @param {ActionsApiCreatePdfExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    createPdfExport(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .createPdfExport(requestParameters.workspaceId, requestParameters.pdfExportRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create tabular export request
     * @param {ActionsApiCreateTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    createTabularExport(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .createTabularExport(requestParameters.workspaceId, requestParameters.tabularExportRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
     * @summary Retrieve exported files
     * @param {ActionsApiGetExportedFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    getExportedFile(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .getExportedFile(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoints serves as a cache for user defined metadata for the front end ui to retrieve them, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified. If metadata for given {exportId} has been found, endpoint returns the value 200 else 404.
     * @summary Retrieve metadata context
     * @param {ActionsApiGetMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    getMetadata(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .getMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary Retrieve exported files
     * @param {ActionsApiGetTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    getTabularExport(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .getTabularExport(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ComputationApi - axios parameter creator
 * @export
 */
export const ComputationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create tabular export request
         * @param {string} workspaceId
         * @param {TabularExportRequest} tabularExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTabularExport: async (workspaceId, tabularExportRequest, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createTabularExport", "workspaceId", workspaceId);
            // verify required parameter 'tabularExportRequest' is not null or undefined
            assertParamExists("createTabularExport", "tabularExportRequest", tabularExportRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/tabular`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof tabularExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(tabularExportRequest !== undefined ? tabularExportRequest : {})
                : tabularExportRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTabularExport: async (workspaceId, exportId, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getTabularExport", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getTabularExport", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/tabular/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ComputationApi - functional programming interface
 * @export
 */
export const ComputationApiFp = function (configuration) {
    const localVarAxiosParamCreator = ComputationApiAxiosParamCreator(configuration);
    return {
        /**
         * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create tabular export request
         * @param {string} workspaceId
         * @param {TabularExportRequest} tabularExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTabularExport(workspaceId, tabularExportRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTabularExport(workspaceId, tabularExportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTabularExport(workspaceId, exportId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTabularExport(workspaceId, exportId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ComputationApi - factory interface
 * @export
 */
export const ComputationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ComputationApiFp(configuration);
    return {
        /**
         * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create tabular export request
         * @param {ComputationApiCreateTabularExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTabularExport(requestParameters, options) {
            return localVarFp
                .createTabularExport(requestParameters.workspaceId, requestParameters.tabularExportRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary Retrieve exported files
         * @param {ComputationApiGetTabularExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTabularExport(requestParameters, options) {
            return localVarFp
                .getTabularExport(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * ComputationApi - object-oriented interface
 * @export
 * @class ComputationApi
 * @extends {BaseAPI}
 */
export class ComputationApi extends BaseAPI {
    /**
     * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create tabular export request
     * @param {ComputationApiCreateTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    createTabularExport(requestParameters, options) {
        return ComputationApiFp(this.configuration)
            .createTabularExport(requestParameters.workspaceId, requestParameters.tabularExportRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary Retrieve exported files
     * @param {ComputationApiGetTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    getTabularExport(requestParameters, options) {
        return ComputationApiFp(this.configuration)
            .getTabularExport(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ExportingApi - axios parameter creator
 * @export
 */
export const ExportingApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create visual - pdf export request
         * @param {string} workspaceId
         * @param {PdfExportRequest} pdfExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPdfExport: async (workspaceId, pdfExportRequest, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createPdfExport", "workspaceId", workspaceId);
            // verify required parameter 'pdfExportRequest' is not null or undefined
            assertParamExists("createPdfExport", "pdfExportRequest", pdfExportRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof pdfExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(pdfExportRequest !== undefined ? pdfExportRequest : {})
                : pdfExportRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportedFile: async (workspaceId, exportId, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getExportedFile", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getExportedFile", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoints serves as a cache for user defined metadata for the front end ui to retrieve them, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified. If metadata for given {exportId} has been found, endpoint returns the value 200 else 404.
         * @summary Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (workspaceId, exportId, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getMetadata", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getMetadata", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual/{exportId}/metadata`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ExportingApi - functional programming interface
 * @export
 */
export const ExportingApiFp = function (configuration) {
    const localVarAxiosParamCreator = ExportingApiAxiosParamCreator(configuration);
    return {
        /**
         * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create visual - pdf export request
         * @param {string} workspaceId
         * @param {PdfExportRequest} pdfExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPdfExport(workspaceId, pdfExportRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPdfExport(workspaceId, pdfExportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExportedFile(workspaceId, exportId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExportedFile(workspaceId, exportId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoints serves as a cache for user defined metadata for the front end ui to retrieve them, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified. If metadata for given {exportId} has been found, endpoint returns the value 200 else 404.
         * @summary Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(workspaceId, exportId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadata(workspaceId, exportId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ExportingApi - factory interface
 * @export
 */
export const ExportingApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ExportingApiFp(configuration);
    return {
        /**
         * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create visual - pdf export request
         * @param {ExportingApiCreatePdfExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPdfExport(requestParameters, options) {
            return localVarFp
                .createPdfExport(requestParameters.workspaceId, requestParameters.pdfExportRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
         * @summary Retrieve exported files
         * @param {ExportingApiGetExportedFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportedFile(requestParameters, options) {
            return localVarFp
                .getExportedFile(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * This endpoints serves as a cache for user defined metadata for the front end ui to retrieve them, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified. If metadata for given {exportId} has been found, endpoint returns the value 200 else 404.
         * @summary Retrieve metadata context
         * @param {ExportingApiGetMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(requestParameters, options) {
            return localVarFp
                .getMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * ExportingApi - object-oriented interface
 * @export
 * @class ExportingApi
 * @extends {BaseAPI}
 */
export class ExportingApi extends BaseAPI {
    /**
     * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create visual - pdf export request
     * @param {ExportingApiCreatePdfExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportingApi
     */
    createPdfExport(requestParameters, options) {
        return ExportingApiFp(this.configuration)
            .createPdfExport(requestParameters.workspaceId, requestParameters.pdfExportRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
     * @summary Retrieve exported files
     * @param {ExportingApiGetExportedFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportingApi
     */
    getExportedFile(requestParameters, options) {
        return ExportingApiFp(this.configuration)
            .getExportedFile(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoints serves as a cache for user defined metadata for the front end ui to retrieve them, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified. If metadata for given {exportId} has been found, endpoint returns the value 200 else 404.
     * @summary Retrieve metadata context
     * @param {ExportingApiGetMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportingApi
     */
    getMetadata(requestParameters, options) {
        return ExportingApiFp(this.configuration)
            .getMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
//# sourceMappingURL=api.js.map