/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import globalAxios from "axios";
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setSearchParams, toPathString, createRequestFunction } from './common.js';
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI } from './base.js';
export const ApiEntitlementNameEnum = {
    CACHE_STRATEGY: "CacheStrategy",
    CONTRACT: "Contract",
    CUSTOM_THEMING: "CustomTheming",
    EXTRA_CACHE: "ExtraCache",
    PDF_EXPORTS: "PdfExports",
    MANAGED_OIDC: "ManagedOIDC",
    UI_LOCALIZATION: "UiLocalization",
    TIER: "Tier",
    USER_COUNT: "UserCount",
    UNLIMITED_USERS: "UnlimitedUsers",
    UNLIMITED_WORKSPACES: "UnlimitedWorkspaces",
    WHITE_LABELING: "WhiteLabeling",
    WORKSPACE_COUNT: "WorkspaceCount",
};
export const AssigneeIdentifierTypeEnum = {
    USER: "user",
    USER_GROUP: "userGroup",
};
export const DataSourceTableIdentifierTypeEnum = {
    DATA_SOURCE: "dataSource",
};
export const DatasetReferenceIdentifierTypeEnum = {
    DATASET: "dataset",
};
export const DatasetWorkspaceDataFilterIdentifierTypeEnum = {
    WORKSPACE_DATA_FILTER: "workspaceDataFilter",
};
export const DeclarativeAnalyticalDashboardPermissionNameEnum = {
    EDIT: "EDIT",
    SHARE: "SHARE",
    VIEW: "VIEW",
};
export const DeclarativeAttributeSortDirectionEnum = {
    ASC: "ASC",
    DESC: "DESC",
};
export const DeclarativeAttributeSourceColumnDataTypeEnum = {
    INT: "INT",
    STRING: "STRING",
    DATE: "DATE",
    NUMERIC: "NUMERIC",
    TIMESTAMP: "TIMESTAMP",
    TIMESTAMP_TZ: "TIMESTAMP_TZ",
    BOOLEAN: "BOOLEAN",
};
export const DeclarativeColumnDataTypeEnum = {
    INT: "INT",
    STRING: "STRING",
    DATE: "DATE",
    NUMERIC: "NUMERIC",
    TIMESTAMP: "TIMESTAMP",
    TIMESTAMP_TZ: "TIMESTAMP_TZ",
    BOOLEAN: "BOOLEAN",
};
export const DeclarativeDataSourceTypeEnum = {
    POSTGRESQL: "POSTGRESQL",
    REDSHIFT: "REDSHIFT",
    VERTICA: "VERTICA",
    SNOWFLAKE: "SNOWFLAKE",
    ADS: "ADS",
    BIGQUERY: "BIGQUERY",
    MSSQL: "MSSQL",
    PRESTO: "PRESTO",
    DREMIO: "DREMIO",
    DRILL: "DRILL",
    GREENPLUM: "GREENPLUM",
    AZURESQL: "AZURESQL",
    SYNAPSESQL: "SYNAPSESQL",
    DATABRICKS: "DATABRICKS",
};
export const DeclarativeDataSourcePermissionNameEnum = {
    MANAGE: "MANAGE",
    USE: "USE",
};
export const DeclarativeDateDatasetGranularitiesEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
};
export const DeclarativeFactSourceColumnDataTypeEnum = {
    INT: "INT",
    STRING: "STRING",
    DATE: "DATE",
    NUMERIC: "NUMERIC",
    TIMESTAMP: "TIMESTAMP",
    TIMESTAMP_TZ: "TIMESTAMP_TZ",
    BOOLEAN: "BOOLEAN",
};
export const DeclarativeLabelSourceColumnDataTypeEnum = {
    INT: "INT",
    STRING: "STRING",
    DATE: "DATE",
    NUMERIC: "NUMERIC",
    TIMESTAMP: "TIMESTAMP",
    TIMESTAMP_TZ: "TIMESTAMP_TZ",
    BOOLEAN: "BOOLEAN",
};
export const DeclarativeLabelValueTypeEnum = {
    TEXT: "TEXT",
    HYPERLINK: "HYPERLINK",
    GEO: "GEO",
    GEO_LONGITUDE: "GEO_LONGITUDE",
    GEO_LATITUDE: "GEO_LATITUDE",
};
export const DeclarativeOrganizationPermissionNameEnum = {
    MANAGE: "MANAGE",
};
export const DeclarativeReferenceSourceColumnDataTypesEnum = {
    INT: "INT",
    STRING: "STRING",
    DATE: "DATE",
    NUMERIC: "NUMERIC",
    TIMESTAMP: "TIMESTAMP",
    TIMESTAMP_TZ: "TIMESTAMP_TZ",
    BOOLEAN: "BOOLEAN",
};
export const DeclarativeRsaSpecificationKtyEnum = {
    RSA: "RSA",
};
export const DeclarativeRsaSpecificationAlgEnum = {
    RS256: "RS256",
    RS384: "RS384",
    RS512: "RS512",
};
export const DeclarativeRsaSpecificationUseEnum = {
    SIG: "sig",
};
export const DeclarativeSettingTypeEnum = {
    TIMEZONE: "TIMEZONE",
    ACTIVE_THEME: "ACTIVE_THEME",
    ACTIVE_COLOR_PALETTE: "ACTIVE_COLOR_PALETTE",
    WHITE_LABELING: "WHITE_LABELING",
    LOCALE: "LOCALE",
    FORMAT_LOCALE: "FORMAT_LOCALE",
    MAPBOX_TOKEN: "MAPBOX_TOKEN",
    WEEK_START: "WEEK_START",
};
export const DeclarativeSingleWorkspacePermissionNameEnum = {
    MANAGE: "MANAGE",
    ANALYZE: "ANALYZE",
    EXPORT: "EXPORT",
    EXPORT_TABULAR: "EXPORT_TABULAR",
    EXPORT_PDF: "EXPORT_PDF",
    VIEW: "VIEW",
};
export const DeclarativeUserGroupPermissionNameEnum = {
    SEE: "SEE",
};
export const DeclarativeUserIdentifierTypeEnum = {
    USER: "user",
};
export const DeclarativeUserPermissionNameEnum = {
    SEE: "SEE",
};
export const DeclarativeWorkspaceDataFilterColumnDataTypeEnum = {
    INT: "INT",
    STRING: "STRING",
    DATE: "DATE",
    NUMERIC: "NUMERIC",
    TIMESTAMP: "TIMESTAMP",
    TIMESTAMP_TZ: "TIMESTAMP_TZ",
    BOOLEAN: "BOOLEAN",
};
export const DeclarativeWorkspaceDataFilterReferencesFilterColumnDataTypeEnum = {
    INT: "INT",
    STRING: "STRING",
    DATE: "DATE",
    NUMERIC: "NUMERIC",
    TIMESTAMP: "TIMESTAMP",
    TIMESTAMP_TZ: "TIMESTAMP_TZ",
    BOOLEAN: "BOOLEAN",
};
export const DeclarativeWorkspaceHierarchyPermissionNameEnum = {
    MANAGE: "MANAGE",
    ANALYZE: "ANALYZE",
    EXPORT: "EXPORT",
    EXPORT_TABULAR: "EXPORT_TABULAR",
    EXPORT_PDF: "EXPORT_PDF",
    VIEW: "VIEW",
};
export const DependentEntitiesNodeTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
    ATTRIBUTE: "attribute",
    DASHBOARD_PLUGIN: "dashboardPlugin",
    DATASET: "dataset",
    FACT: "fact",
    LABEL: "label",
    METRIC: "metric",
    USER_DATA_FILTER: "userDataFilter",
    PROMPT: "prompt",
    VISUALIZATION_OBJECT: "visualizationObject",
    FILTER_CONTEXT: "filterContext",
};
export const EntitlementsRequestEntitlementsNameEnum = {
    CACHE_STRATEGY: "CacheStrategy",
    CONTRACT: "Contract",
    CUSTOM_THEMING: "CustomTheming",
    EXTRA_CACHE: "ExtraCache",
    PDF_EXPORTS: "PdfExports",
    MANAGED_OIDC: "ManagedOIDC",
    UI_LOCALIZATION: "UiLocalization",
    TIER: "Tier",
    USER_COUNT: "UserCount",
    UNLIMITED_USERS: "UnlimitedUsers",
    UNLIMITED_WORKSPACES: "UnlimitedWorkspaces",
    WHITE_LABELING: "WhiteLabeling",
    WORKSPACE_COUNT: "WorkspaceCount",
};
export const EntityIdentifierTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
    ATTRIBUTE: "attribute",
    DASHBOARD_PLUGIN: "dashboardPlugin",
    DATASET: "dataset",
    FACT: "fact",
    LABEL: "label",
    METRIC: "metric",
    USER_DATA_FILTER: "userDataFilter",
    PROMPT: "prompt",
    VISUALIZATION_OBJECT: "visualizationObject",
    FILTER_CONTEXT: "filterContext",
};
export const GrainIdentifierTypeEnum = {
    ATTRIBUTE: "attribute",
    DATASET: "dataset",
};
export const HierarchyObjectIdentificationTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
    ATTRIBUTE: "attribute",
    DASHBOARD_PLUGIN: "dashboardPlugin",
    DATASET: "dataset",
    FACT: "fact",
    LABEL: "label",
    METRIC: "metric",
    PROMPT: "prompt",
    VISUALIZATION_OBJECT: "visualizationObject",
    FILTER_CONTEXT: "filterContext",
    WORKSPACE_DATA_FILTER: "workspaceDataFilter",
    WORKSPACE_DATA_FILTER_SETTINGS: "workspaceDataFilterSettings",
};
export const IdentifierDuplicationsTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
    ATTRIBUTE: "attribute",
    DASHBOARD_PLUGIN: "dashboardPlugin",
    DATASET: "dataset",
    FACT: "fact",
    LABEL: "label",
    METRIC: "metric",
    PROMPT: "prompt",
    VISUALIZATION_OBJECT: "visualizationObject",
    FILTER_CONTEXT: "filterContext",
    WORKSPACE_DATA_FILTER: "workspaceDataFilter",
    WORKSPACE_DATA_FILTER_SETTINGS: "workspaceDataFilterSettings",
};
export const JsonApiAnalyticalDashboardInTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
};
export const JsonApiAnalyticalDashboardLinkageTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
};
export const JsonApiAnalyticalDashboardOutTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
};
export const JsonApiAnalyticalDashboardOutMetaPermissionsEnum = {
    EDIT: "EDIT",
    SHARE: "SHARE",
    VIEW: "VIEW",
};
export const JsonApiAnalyticalDashboardOutMetaOriginOriginTypeEnum = {
    NATIVE: "NATIVE",
    PARENT: "PARENT",
};
export const JsonApiAnalyticalDashboardOutWithLinksTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
};
export const JsonApiAnalyticalDashboardPatchTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
};
export const JsonApiAnalyticalDashboardPostOptionalIdTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
};
export const JsonApiApiTokenInTypeEnum = {
    API_TOKEN: "apiToken",
};
export const JsonApiApiTokenOutTypeEnum = {
    API_TOKEN: "apiToken",
};
export const JsonApiApiTokenOutWithLinksTypeEnum = {
    API_TOKEN: "apiToken",
};
export const JsonApiAttributeHierarchyInTypeEnum = {
    ATTRIBUTE_HIERARCHY: "attributeHierarchy",
};
export const JsonApiAttributeHierarchyLinkageTypeEnum = {
    ATTRIBUTE_HIERARCHY: "attributeHierarchy",
};
export const JsonApiAttributeHierarchyOutTypeEnum = {
    ATTRIBUTE_HIERARCHY: "attributeHierarchy",
};
export const JsonApiAttributeHierarchyOutWithLinksTypeEnum = {
    ATTRIBUTE_HIERARCHY: "attributeHierarchy",
};
export const JsonApiAttributeHierarchyPatchTypeEnum = {
    ATTRIBUTE_HIERARCHY: "attributeHierarchy",
};
export const JsonApiAttributeLinkageTypeEnum = {
    ATTRIBUTE: "attribute",
};
export const JsonApiAttributeOutTypeEnum = {
    ATTRIBUTE: "attribute",
};
export const JsonApiAttributeOutAttributesGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
};
export const JsonApiAttributeOutAttributesSortDirectionEnum = {
    ASC: "ASC",
    DESC: "DESC",
};
export const JsonApiAttributeOutAttributesSourceColumnDataTypeEnum = {
    INT: "INT",
    STRING: "STRING",
    DATE: "DATE",
    NUMERIC: "NUMERIC",
    TIMESTAMP: "TIMESTAMP",
    TIMESTAMP_TZ: "TIMESTAMP_TZ",
    BOOLEAN: "BOOLEAN",
};
export const JsonApiAttributeOutWithLinksTypeEnum = {
    ATTRIBUTE: "attribute",
};
export const JsonApiColorPaletteInTypeEnum = {
    COLOR_PALETTE: "colorPalette",
};
export const JsonApiColorPaletteOutTypeEnum = {
    COLOR_PALETTE: "colorPalette",
};
export const JsonApiColorPaletteOutWithLinksTypeEnum = {
    COLOR_PALETTE: "colorPalette",
};
export const JsonApiColorPalettePatchTypeEnum = {
    COLOR_PALETTE: "colorPalette",
};
export const JsonApiCookieSecurityConfigurationInTypeEnum = {
    COOKIE_SECURITY_CONFIGURATION: "cookieSecurityConfiguration",
};
export const JsonApiCookieSecurityConfigurationOutTypeEnum = {
    COOKIE_SECURITY_CONFIGURATION: "cookieSecurityConfiguration",
};
export const JsonApiCookieSecurityConfigurationPatchTypeEnum = {
    COOKIE_SECURITY_CONFIGURATION: "cookieSecurityConfiguration",
};
export const JsonApiCspDirectiveInTypeEnum = {
    CSP_DIRECTIVE: "cspDirective",
};
export const JsonApiCspDirectiveOutTypeEnum = {
    CSP_DIRECTIVE: "cspDirective",
};
export const JsonApiCspDirectiveOutWithLinksTypeEnum = {
    CSP_DIRECTIVE: "cspDirective",
};
export const JsonApiCspDirectivePatchTypeEnum = {
    CSP_DIRECTIVE: "cspDirective",
};
export const JsonApiCustomApplicationSettingInTypeEnum = {
    CUSTOM_APPLICATION_SETTING: "customApplicationSetting",
};
export const JsonApiCustomApplicationSettingOutTypeEnum = {
    CUSTOM_APPLICATION_SETTING: "customApplicationSetting",
};
export const JsonApiCustomApplicationSettingOutWithLinksTypeEnum = {
    CUSTOM_APPLICATION_SETTING: "customApplicationSetting",
};
export const JsonApiCustomApplicationSettingPatchTypeEnum = {
    CUSTOM_APPLICATION_SETTING: "customApplicationSetting",
};
export const JsonApiCustomApplicationSettingPostOptionalIdTypeEnum = {
    CUSTOM_APPLICATION_SETTING: "customApplicationSetting",
};
export const JsonApiDashboardPluginInTypeEnum = {
    DASHBOARD_PLUGIN: "dashboardPlugin",
};
export const JsonApiDashboardPluginLinkageTypeEnum = {
    DASHBOARD_PLUGIN: "dashboardPlugin",
};
export const JsonApiDashboardPluginOutTypeEnum = {
    DASHBOARD_PLUGIN: "dashboardPlugin",
};
export const JsonApiDashboardPluginOutWithLinksTypeEnum = {
    DASHBOARD_PLUGIN: "dashboardPlugin",
};
export const JsonApiDashboardPluginPatchTypeEnum = {
    DASHBOARD_PLUGIN: "dashboardPlugin",
};
export const JsonApiDashboardPluginPostOptionalIdTypeEnum = {
    DASHBOARD_PLUGIN: "dashboardPlugin",
};
export const JsonApiDataSourceIdentifierOutTypeEnum = {
    DATA_SOURCE_IDENTIFIER: "dataSourceIdentifier",
};
export const JsonApiDataSourceIdentifierOutAttributesTypeEnum = {
    POSTGRESQL: "POSTGRESQL",
    REDSHIFT: "REDSHIFT",
    VERTICA: "VERTICA",
    SNOWFLAKE: "SNOWFLAKE",
    ADS: "ADS",
    BIGQUERY: "BIGQUERY",
    MSSQL: "MSSQL",
    PRESTO: "PRESTO",
    DREMIO: "DREMIO",
    DRILL: "DRILL",
    GREENPLUM: "GREENPLUM",
    AZURESQL: "AZURESQL",
    SYNAPSESQL: "SYNAPSESQL",
    DATABRICKS: "DATABRICKS",
};
export const JsonApiDataSourceIdentifierOutMetaPermissionsEnum = {
    MANAGE: "MANAGE",
    USE: "USE",
};
export const JsonApiDataSourceIdentifierOutWithLinksTypeEnum = {
    DATA_SOURCE_IDENTIFIER: "dataSourceIdentifier",
};
export const JsonApiDataSourceInTypeEnum = {
    DATA_SOURCE: "dataSource",
};
export const JsonApiDataSourceInAttributesTypeEnum = {
    POSTGRESQL: "POSTGRESQL",
    REDSHIFT: "REDSHIFT",
    VERTICA: "VERTICA",
    SNOWFLAKE: "SNOWFLAKE",
    ADS: "ADS",
    BIGQUERY: "BIGQUERY",
    MSSQL: "MSSQL",
    PRESTO: "PRESTO",
    DREMIO: "DREMIO",
    DRILL: "DRILL",
    GREENPLUM: "GREENPLUM",
    AZURESQL: "AZURESQL",
    SYNAPSESQL: "SYNAPSESQL",
    DATABRICKS: "DATABRICKS",
};
export const JsonApiDataSourceOutTypeEnum = {
    DATA_SOURCE: "dataSource",
};
export const JsonApiDataSourceOutAttributesTypeEnum = {
    POSTGRESQL: "POSTGRESQL",
    REDSHIFT: "REDSHIFT",
    VERTICA: "VERTICA",
    SNOWFLAKE: "SNOWFLAKE",
    ADS: "ADS",
    BIGQUERY: "BIGQUERY",
    MSSQL: "MSSQL",
    PRESTO: "PRESTO",
    DREMIO: "DREMIO",
    DRILL: "DRILL",
    GREENPLUM: "GREENPLUM",
    AZURESQL: "AZURESQL",
    SYNAPSESQL: "SYNAPSESQL",
    DATABRICKS: "DATABRICKS",
};
export const JsonApiDataSourceOutWithLinksTypeEnum = {
    DATA_SOURCE: "dataSource",
};
export const JsonApiDataSourcePatchTypeEnum = {
    DATA_SOURCE: "dataSource",
};
export const JsonApiDataSourcePatchAttributesTypeEnum = {
    POSTGRESQL: "POSTGRESQL",
    REDSHIFT: "REDSHIFT",
    VERTICA: "VERTICA",
    SNOWFLAKE: "SNOWFLAKE",
    ADS: "ADS",
    BIGQUERY: "BIGQUERY",
    MSSQL: "MSSQL",
    PRESTO: "PRESTO",
    DREMIO: "DREMIO",
    DRILL: "DRILL",
    GREENPLUM: "GREENPLUM",
    AZURESQL: "AZURESQL",
    SYNAPSESQL: "SYNAPSESQL",
    DATABRICKS: "DATABRICKS",
};
export const JsonApiDataSourceTableOutTypeEnum = {
    DATA_SOURCE_TABLE: "dataSourceTable",
};
export const JsonApiDataSourceTableOutAttributesTypeEnum = {
    TABLE: "TABLE",
    VIEW: "VIEW",
};
export const JsonApiDataSourceTableOutAttributesColumnsDataTypeEnum = {
    INT: "INT",
    STRING: "STRING",
    DATE: "DATE",
    NUMERIC: "NUMERIC",
    TIMESTAMP: "TIMESTAMP",
    TIMESTAMP_TZ: "TIMESTAMP_TZ",
    BOOLEAN: "BOOLEAN",
};
export const JsonApiDataSourceTableOutWithLinksTypeEnum = {
    DATA_SOURCE_TABLE: "dataSourceTable",
};
export const JsonApiDatasetLinkageTypeEnum = {
    DATASET: "dataset",
};
export const JsonApiDatasetOutTypeEnum = {
    DATASET: "dataset",
};
export const JsonApiDatasetOutAttributesTypeEnum = {
    NORMAL: "NORMAL",
    DATE: "DATE",
};
export const JsonApiDatasetOutAttributesGrainTypeEnum = {
    ATTRIBUTE: "attribute",
    DATASET: "dataset",
};
export const JsonApiDatasetOutAttributesReferencePropertiesSourceColumnDataTypesEnum = {
    INT: "INT",
    STRING: "STRING",
    DATE: "DATE",
    NUMERIC: "NUMERIC",
    TIMESTAMP: "TIMESTAMP",
    TIMESTAMP_TZ: "TIMESTAMP_TZ",
    BOOLEAN: "BOOLEAN",
};
export const JsonApiDatasetOutAttributesWorkspaceDataFilterColumnsDataTypeEnum = {
    INT: "INT",
    STRING: "STRING",
    DATE: "DATE",
    NUMERIC: "NUMERIC",
    TIMESTAMP: "TIMESTAMP",
    TIMESTAMP_TZ: "TIMESTAMP_TZ",
    BOOLEAN: "BOOLEAN",
};
export const JsonApiDatasetOutAttributesWorkspaceDataFilterReferencesFilterColumnDataTypeEnum = {
    INT: "INT",
    STRING: "STRING",
    DATE: "DATE",
    NUMERIC: "NUMERIC",
    TIMESTAMP: "TIMESTAMP",
    TIMESTAMP_TZ: "TIMESTAMP_TZ",
    BOOLEAN: "BOOLEAN",
};
export const JsonApiDatasetOutWithLinksTypeEnum = {
    DATASET: "dataset",
};
export const JsonApiEntitlementOutTypeEnum = {
    ENTITLEMENT: "entitlement",
};
export const JsonApiEntitlementOutWithLinksTypeEnum = {
    ENTITLEMENT: "entitlement",
};
export const JsonApiFactLinkageTypeEnum = {
    FACT: "fact",
};
export const JsonApiFactOutTypeEnum = {
    FACT: "fact",
};
export const JsonApiFactOutAttributesSourceColumnDataTypeEnum = {
    INT: "INT",
    STRING: "STRING",
    DATE: "DATE",
    NUMERIC: "NUMERIC",
    TIMESTAMP: "TIMESTAMP",
    TIMESTAMP_TZ: "TIMESTAMP_TZ",
    BOOLEAN: "BOOLEAN",
};
export const JsonApiFactOutWithLinksTypeEnum = {
    FACT: "fact",
};
export const JsonApiFilterContextInTypeEnum = {
    FILTER_CONTEXT: "filterContext",
};
export const JsonApiFilterContextLinkageTypeEnum = {
    FILTER_CONTEXT: "filterContext",
};
export const JsonApiFilterContextOutTypeEnum = {
    FILTER_CONTEXT: "filterContext",
};
export const JsonApiFilterContextOutWithLinksTypeEnum = {
    FILTER_CONTEXT: "filterContext",
};
export const JsonApiFilterContextPatchTypeEnum = {
    FILTER_CONTEXT: "filterContext",
};
export const JsonApiFilterContextPostOptionalIdTypeEnum = {
    FILTER_CONTEXT: "filterContext",
};
export const JsonApiJwkInTypeEnum = {
    JWK: "jwk",
};
export const JsonApiJwkOutTypeEnum = {
    JWK: "jwk",
};
export const JsonApiJwkOutWithLinksTypeEnum = {
    JWK: "jwk",
};
export const JsonApiJwkPatchTypeEnum = {
    JWK: "jwk",
};
export const JsonApiLabelLinkageTypeEnum = {
    LABEL: "label",
};
export const JsonApiLabelOutTypeEnum = {
    LABEL: "label",
};
export const JsonApiLabelOutAttributesSourceColumnDataTypeEnum = {
    INT: "INT",
    STRING: "STRING",
    DATE: "DATE",
    NUMERIC: "NUMERIC",
    TIMESTAMP: "TIMESTAMP",
    TIMESTAMP_TZ: "TIMESTAMP_TZ",
    BOOLEAN: "BOOLEAN",
};
export const JsonApiLabelOutAttributesValueTypeEnum = {
    TEXT: "TEXT",
    HYPERLINK: "HYPERLINK",
    GEO: "GEO",
    GEO_LONGITUDE: "GEO_LONGITUDE",
    GEO_LATITUDE: "GEO_LATITUDE",
};
export const JsonApiLabelOutWithLinksTypeEnum = {
    LABEL: "label",
};
export const JsonApiMetricInTypeEnum = {
    METRIC: "metric",
};
export const JsonApiMetricLinkageTypeEnum = {
    METRIC: "metric",
};
export const JsonApiMetricOutTypeEnum = {
    METRIC: "metric",
};
export const JsonApiMetricOutWithLinksTypeEnum = {
    METRIC: "metric",
};
export const JsonApiMetricPatchTypeEnum = {
    METRIC: "metric",
};
export const JsonApiMetricPostOptionalIdTypeEnum = {
    METRIC: "metric",
};
export const JsonApiOrganizationInTypeEnum = {
    ORGANIZATION: "organization",
};
export const JsonApiOrganizationOutTypeEnum = {
    ORGANIZATION: "organization",
};
export const JsonApiOrganizationOutAttributesCacheSettingsCacheStrategyEnum = {
    DURABLE: "DURABLE",
    EPHEMERAL: "EPHEMERAL",
};
export const JsonApiOrganizationOutMetaPermissionsEnum = {
    MANAGE: "MANAGE",
};
export const JsonApiOrganizationPatchTypeEnum = {
    ORGANIZATION: "organization",
};
export const JsonApiOrganizationSettingInTypeEnum = {
    ORGANIZATION_SETTING: "organizationSetting",
};
export const JsonApiOrganizationSettingOutTypeEnum = {
    ORGANIZATION_SETTING: "organizationSetting",
};
export const JsonApiOrganizationSettingOutWithLinksTypeEnum = {
    ORGANIZATION_SETTING: "organizationSetting",
};
export const JsonApiOrganizationSettingPatchTypeEnum = {
    ORGANIZATION_SETTING: "organizationSetting",
};
export const JsonApiThemeInTypeEnum = {
    THEME: "theme",
};
export const JsonApiThemeOutTypeEnum = {
    THEME: "theme",
};
export const JsonApiThemeOutWithLinksTypeEnum = {
    THEME: "theme",
};
export const JsonApiThemePatchTypeEnum = {
    THEME: "theme",
};
export const JsonApiUserDataFilterInTypeEnum = {
    USER_DATA_FILTER: "userDataFilter",
};
export const JsonApiUserDataFilterOutTypeEnum = {
    USER_DATA_FILTER: "userDataFilter",
};
export const JsonApiUserDataFilterOutWithLinksTypeEnum = {
    USER_DATA_FILTER: "userDataFilter",
};
export const JsonApiUserDataFilterPatchTypeEnum = {
    USER_DATA_FILTER: "userDataFilter",
};
export const JsonApiUserDataFilterPostOptionalIdTypeEnum = {
    USER_DATA_FILTER: "userDataFilter",
};
export const JsonApiUserGroupInTypeEnum = {
    USER_GROUP: "userGroup",
};
export const JsonApiUserGroupLinkageTypeEnum = {
    USER_GROUP: "userGroup",
};
export const JsonApiUserGroupOutTypeEnum = {
    USER_GROUP: "userGroup",
};
export const JsonApiUserGroupOutWithLinksTypeEnum = {
    USER_GROUP: "userGroup",
};
export const JsonApiUserGroupPatchTypeEnum = {
    USER_GROUP: "userGroup",
};
export const JsonApiUserIdentifierLinkageTypeEnum = {
    USER_IDENTIFIER: "userIdentifier",
};
export const JsonApiUserIdentifierOutTypeEnum = {
    USER_IDENTIFIER: "userIdentifier",
};
export const JsonApiUserIdentifierOutWithLinksTypeEnum = {
    USER_IDENTIFIER: "userIdentifier",
};
export const JsonApiUserInTypeEnum = {
    USER: "user",
};
export const JsonApiUserLinkageTypeEnum = {
    USER: "user",
};
export const JsonApiUserOutTypeEnum = {
    USER: "user",
};
export const JsonApiUserOutWithLinksTypeEnum = {
    USER: "user",
};
export const JsonApiUserPatchTypeEnum = {
    USER: "user",
};
export const JsonApiUserSettingInTypeEnum = {
    USER_SETTING: "userSetting",
};
export const JsonApiUserSettingOutTypeEnum = {
    USER_SETTING: "userSetting",
};
export const JsonApiUserSettingOutWithLinksTypeEnum = {
    USER_SETTING: "userSetting",
};
export const JsonApiVisualizationObjectInTypeEnum = {
    VISUALIZATION_OBJECT: "visualizationObject",
};
export const JsonApiVisualizationObjectLinkageTypeEnum = {
    VISUALIZATION_OBJECT: "visualizationObject",
};
export const JsonApiVisualizationObjectOutTypeEnum = {
    VISUALIZATION_OBJECT: "visualizationObject",
};
export const JsonApiVisualizationObjectOutWithLinksTypeEnum = {
    VISUALIZATION_OBJECT: "visualizationObject",
};
export const JsonApiVisualizationObjectPatchTypeEnum = {
    VISUALIZATION_OBJECT: "visualizationObject",
};
export const JsonApiVisualizationObjectPostOptionalIdTypeEnum = {
    VISUALIZATION_OBJECT: "visualizationObject",
};
export const JsonApiWorkspaceDataFilterInTypeEnum = {
    WORKSPACE_DATA_FILTER: "workspaceDataFilter",
};
export const JsonApiWorkspaceDataFilterLinkageTypeEnum = {
    WORKSPACE_DATA_FILTER: "workspaceDataFilter",
};
export const JsonApiWorkspaceDataFilterOutTypeEnum = {
    WORKSPACE_DATA_FILTER: "workspaceDataFilter",
};
export const JsonApiWorkspaceDataFilterOutWithLinksTypeEnum = {
    WORKSPACE_DATA_FILTER: "workspaceDataFilter",
};
export const JsonApiWorkspaceDataFilterPatchTypeEnum = {
    WORKSPACE_DATA_FILTER: "workspaceDataFilter",
};
export const JsonApiWorkspaceDataFilterSettingInTypeEnum = {
    WORKSPACE_DATA_FILTER_SETTING: "workspaceDataFilterSetting",
};
export const JsonApiWorkspaceDataFilterSettingLinkageTypeEnum = {
    WORKSPACE_DATA_FILTER_SETTING: "workspaceDataFilterSetting",
};
export const JsonApiWorkspaceDataFilterSettingOutTypeEnum = {
    WORKSPACE_DATA_FILTER_SETTING: "workspaceDataFilterSetting",
};
export const JsonApiWorkspaceDataFilterSettingOutWithLinksTypeEnum = {
    WORKSPACE_DATA_FILTER_SETTING: "workspaceDataFilterSetting",
};
export const JsonApiWorkspaceDataFilterSettingPatchTypeEnum = {
    WORKSPACE_DATA_FILTER_SETTING: "workspaceDataFilterSetting",
};
export const JsonApiWorkspaceInTypeEnum = {
    WORKSPACE: "workspace",
};
export const JsonApiWorkspaceLinkageTypeEnum = {
    WORKSPACE: "workspace",
};
export const JsonApiWorkspaceOutTypeEnum = {
    WORKSPACE: "workspace",
};
export const JsonApiWorkspaceOutMetaPermissionsEnum = {
    MANAGE: "MANAGE",
    ANALYZE: "ANALYZE",
    EXPORT: "EXPORT",
    EXPORT_TABULAR: "EXPORT_TABULAR",
    EXPORT_PDF: "EXPORT_PDF",
    VIEW: "VIEW",
};
export const JsonApiWorkspaceOutWithLinksTypeEnum = {
    WORKSPACE: "workspace",
};
export const JsonApiWorkspacePatchTypeEnum = {
    WORKSPACE: "workspace",
};
export const JsonApiWorkspaceSettingInTypeEnum = {
    WORKSPACE_SETTING: "workspaceSetting",
};
export const JsonApiWorkspaceSettingOutTypeEnum = {
    WORKSPACE_SETTING: "workspaceSetting",
};
export const JsonApiWorkspaceSettingOutWithLinksTypeEnum = {
    WORKSPACE_SETTING: "workspaceSetting",
};
export const JsonApiWorkspaceSettingPatchTypeEnum = {
    WORKSPACE_SETTING: "workspaceSetting",
};
export const JsonApiWorkspaceSettingPostOptionalIdTypeEnum = {
    WORKSPACE_SETTING: "workspaceSetting",
};
export const JsonApiWorkspaceSettingPostOptionalIdAttributesTypeEnum = {
    TIMEZONE: "TIMEZONE",
    ACTIVE_THEME: "ACTIVE_THEME",
    ACTIVE_COLOR_PALETTE: "ACTIVE_COLOR_PALETTE",
    WHITE_LABELING: "WHITE_LABELING",
    LOCALE: "LOCALE",
    FORMAT_LOCALE: "FORMAT_LOCALE",
    MAPBOX_TOKEN: "MAPBOX_TOKEN",
    WEEK_START: "WEEK_START",
};
export const LabelIdentifierTypeEnum = {
    LABEL: "label",
};
export const PermissionsForAssigneePermissionsEnum = {
    EDIT: "EDIT",
    SHARE: "SHARE",
    VIEW: "VIEW",
};
export const PlatformUsageNameEnum = {
    USER_COUNT: "UserCount",
    WORKSPACE_COUNT: "WorkspaceCount",
};
export const PlatformUsageRequestUsageItemNamesEnum = {
    USER_COUNT: "UserCount",
    WORKSPACE_COUNT: "WorkspaceCount",
};
export const ReferenceIdentifierTypeEnum = {
    DATASET: "dataset",
};
export const ResolvedSettingTypeEnum = {
    TIMEZONE: "TIMEZONE",
    ACTIVE_THEME: "ACTIVE_THEME",
    ACTIVE_COLOR_PALETTE: "ACTIVE_COLOR_PALETTE",
    WHITE_LABELING: "WHITE_LABELING",
    LOCALE: "LOCALE",
    FORMAT_LOCALE: "FORMAT_LOCALE",
    MAPBOX_TOKEN: "MAPBOX_TOKEN",
    WEEK_START: "WEEK_START",
};
export const RsaSpecificationKtyEnum = {
    RSA: "RSA",
};
export const RsaSpecificationAlgEnum = {
    RS256: "RS256",
    RS384: "RS384",
    RS512: "RS512",
};
export const RsaSpecificationUseEnum = {
    SIG: "sig",
};
export const SqlColumnDataTypeEnum = {
    INT: "INT",
    STRING: "STRING",
    DATE: "DATE",
    NUMERIC: "NUMERIC",
    TIMESTAMP: "TIMESTAMP",
    TIMESTAMP_TZ: "TIMESTAMP_TZ",
    BOOLEAN: "BOOLEAN",
};
export const UserGroupIdentifierTypeEnum = {
    USER_GROUP: "userGroup",
};
export const WorkspaceIdentifierTypeEnum = {
    WORKSPACE: "workspace",
};
/**
 * APITokensApi - axios parameter creator
 * @export
 */
export const APITokensApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Post a new API token for the user
         * @param {string} userId
         * @param {JsonApiApiTokenInDocument} jsonApiApiTokenInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityApiTokens: async (userId, jsonApiApiTokenInDocument, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("createEntityApiTokens", "userId", userId);
            // verify required parameter 'jsonApiApiTokenInDocument' is not null or undefined
            assertParamExists("createEntityApiTokens", "jsonApiApiTokenInDocument", jsonApiApiTokenInDocument);
            const localVarPath = `/api/v1/entities/users/{userId}/apiTokens`.replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiApiTokenInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiApiTokenInDocument !== undefined ? jsonApiApiTokenInDocument : {})
                : jsonApiApiTokenInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete an API Token for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityApiTokens: async (userId, id, filter, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("deleteEntityApiTokens", "userId", userId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityApiTokens", "id", id);
            const localVarPath = `/api/v1/entities/users/{userId}/apiTokens/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List all api tokens for a user
         * @param {string} userId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesApiTokens: async (userId, filter, page, size, sort, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("getAllEntitiesApiTokens", "userId", userId);
            const localVarPath = `/api/v1/entities/users/{userId}/apiTokens`.replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get an API Token for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityApiTokens: async (userId, id, filter, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("getEntityApiTokens", "userId", userId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityApiTokens", "id", id);
            const localVarPath = `/api/v1/entities/users/{userId}/apiTokens/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put new API token for the user
         * @param {string} userId
         * @param {string} id
         * @param {JsonApiApiTokenInDocument} jsonApiApiTokenInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityApiTokens: async (userId, id, jsonApiApiTokenInDocument, filter, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("updateEntityApiTokens", "userId", userId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityApiTokens", "id", id);
            // verify required parameter 'jsonApiApiTokenInDocument' is not null or undefined
            assertParamExists("updateEntityApiTokens", "jsonApiApiTokenInDocument", jsonApiApiTokenInDocument);
            const localVarPath = `/api/v1/entities/users/{userId}/apiTokens/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiApiTokenInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiApiTokenInDocument !== undefined ? jsonApiApiTokenInDocument : {})
                : jsonApiApiTokenInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * APITokensApi - functional programming interface
 * @export
 */
export const APITokensApiFp = function (configuration) {
    const localVarAxiosParamCreator = APITokensApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Post a new API token for the user
         * @param {string} userId
         * @param {JsonApiApiTokenInDocument} jsonApiApiTokenInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityApiTokens(userId, jsonApiApiTokenInDocument, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityApiTokens(userId, jsonApiApiTokenInDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete an API Token for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityApiTokens(userId, id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityApiTokens(userId, id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary List all api tokens for a user
         * @param {string} userId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesApiTokens(userId, filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesApiTokens(userId, filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get an API Token for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityApiTokens(userId, id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityApiTokens(userId, id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put new API token for the user
         * @param {string} userId
         * @param {string} id
         * @param {JsonApiApiTokenInDocument} jsonApiApiTokenInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityApiTokens(userId, id, jsonApiApiTokenInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityApiTokens(userId, id, jsonApiApiTokenInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * APITokensApi - factory interface
 * @export
 */
export const APITokensApiFactory = function (configuration, basePath, axios) {
    const localVarFp = APITokensApiFp(configuration);
    return {
        /**
         *
         * @summary Post a new API token for the user
         * @param {APITokensApiCreateEntityApiTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityApiTokens(requestParameters, options) {
            return localVarFp
                .createEntityApiTokens(requestParameters.userId, requestParameters.jsonApiApiTokenInDocument, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete an API Token for a user
         * @param {APITokensApiDeleteEntityApiTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityApiTokens(requestParameters, options) {
            return localVarFp
                .deleteEntityApiTokens(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List all api tokens for a user
         * @param {APITokensApiGetAllEntitiesApiTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesApiTokens(requestParameters, options) {
            return localVarFp
                .getAllEntitiesApiTokens(requestParameters.userId, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get an API Token for a user
         * @param {APITokensApiGetEntityApiTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityApiTokens(requestParameters, options) {
            return localVarFp
                .getEntityApiTokens(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put new API token for the user
         * @param {APITokensApiUpdateEntityApiTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityApiTokens(requestParameters, options) {
            return localVarFp
                .updateEntityApiTokens(requestParameters.userId, requestParameters.id, requestParameters.jsonApiApiTokenInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * APITokensApi - object-oriented interface
 * @export
 * @class APITokensApi
 * @extends {BaseAPI}
 */
export class APITokensApi extends BaseAPI {
    /**
     *
     * @summary Post a new API token for the user
     * @param {APITokensApiCreateEntityApiTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APITokensApi
     */
    createEntityApiTokens(requestParameters, options) {
        return APITokensApiFp(this.configuration)
            .createEntityApiTokens(requestParameters.userId, requestParameters.jsonApiApiTokenInDocument, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete an API Token for a user
     * @param {APITokensApiDeleteEntityApiTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APITokensApi
     */
    deleteEntityApiTokens(requestParameters, options) {
        return APITokensApiFp(this.configuration)
            .deleteEntityApiTokens(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List all api tokens for a user
     * @param {APITokensApiGetAllEntitiesApiTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APITokensApi
     */
    getAllEntitiesApiTokens(requestParameters, options) {
        return APITokensApiFp(this.configuration)
            .getAllEntitiesApiTokens(requestParameters.userId, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get an API Token for a user
     * @param {APITokensApiGetEntityApiTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APITokensApi
     */
    getEntityApiTokens(requestParameters, options) {
        return APITokensApiFp(this.configuration)
            .getEntityApiTokens(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put new API token for the user
     * @param {APITokensApiUpdateEntityApiTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APITokensApi
     */
    updateEntityApiTokens(requestParameters, options) {
        return APITokensApiFp(this.configuration)
            .updateEntityApiTokens(requestParameters.userId, requestParameters.id, requestParameters.jsonApiApiTokenInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Provides information about platform usage, like amount of users, workspaces, ...
         * @summary Info about the platform usage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allPlatformUsage: async (options = {}) => {
            const localVarPath = `/api/v1/actions/collectUsage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Available Assignees
         * @param {string} workspaceId
         * @param {string} dashboardId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableAssignees: async (workspaceId, dashboardId, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("availableAssignees", "workspaceId", workspaceId);
            // verify required parameter 'dashboardId' is not null or undefined
            assertParamExists("availableAssignees", "dashboardId", dashboardId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/analyticalDashboards/{dashboardId}/availableAssignees`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds entities with given ID in hierarchy (e.g. to check possible future conflicts).
         * @summary Finds entities with given ID in hierarchy.
         * @param {string} workspaceId
         * @param {Array<HierarchyObjectIdentification>} hierarchyObjectIdentification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkEntityOverrides: async (workspaceId, hierarchyObjectIdentification, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("checkEntityOverrides", "workspaceId", workspaceId);
            // verify required parameter 'hierarchyObjectIdentification' is not null or undefined
            assertParamExists("checkEntityOverrides", "hierarchyObjectIdentification", hierarchyObjectIdentification);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/checkEntityOverrides`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof hierarchyObjectIdentification !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(hierarchyObjectIdentification !== undefined ? hierarchyObjectIdentification : {})
                : hierarchyObjectIdentification || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Dashboard Permissions
         * @param {string} workspaceId
         * @param {string} dashboardId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardPermissions: async (workspaceId, dashboardId, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("dashboardPermissions", "workspaceId", workspaceId);
            // verify required parameter 'dashboardId' is not null or undefined
            assertParamExists("dashboardPermissions", "dashboardId", dashboardId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/analyticalDashboards/{dashboardId}/permissions`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate logical data model (LDM) from physical data model (PDM) stored in data source.
         * @summary Generate logical data model (LDM) from physical data model (PDM)
         * @param {string} dataSourceId
         * @param {GenerateLdmRequest} generateLdmRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateLogicalModel: async (dataSourceId, generateLdmRequest, options = {}) => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("generateLogicalModel", "dataSourceId", dataSourceId);
            // verify required parameter 'generateLdmRequest' is not null or undefined
            assertParamExists("generateLogicalModel", "generateLdmRequest", generateLdmRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/generateLogicalModel`.replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof generateLdmRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(generateLdmRequest !== undefined ? generateLdmRequest : {})
                : generateLdmRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Computes the dependent entities graph
         * @summary Computes the dependent entities graph
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDependentEntitiesGraph: async (workspaceId, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getDependentEntitiesGraph", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/dependentEntitiesGraph`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Computes the dependent entities graph from given entry points
         * @summary Computes the dependent entities graph from given entry points
         * @param {string} workspaceId
         * @param {DependentEntitiesRequest} dependentEntitiesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDependentEntitiesGraphFromEntryPoints: async (workspaceId, dependentEntitiesRequest, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getDependentEntitiesGraphFromEntryPoints", "workspaceId", workspaceId);
            // verify required parameter 'dependentEntitiesRequest' is not null or undefined
            assertParamExists("getDependentEntitiesGraphFromEntryPoints", "dependentEntitiesRequest", dependentEntitiesRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/dependentEntitiesGraph`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof dependentEntitiesRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(dependentEntitiesRequest !== undefined ? dependentEntitiesRequest : {})
                : dependentEntitiesRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds API identifier conflicts in given workspace hierarchy.
         * @summary Finds API identifier conflicts in given workspace hierarchy.
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inheritedEntityConflicts: async (workspaceId, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("inheritedEntityConflicts", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/inheritedEntityConflicts`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get used entity prefixes in hierarchy of parent workspaces
         * @summary Get used entity prefixes in hierarchy
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inheritedEntityPrefixes: async (workspaceId, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("inheritedEntityPrefixes", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/inheritedEntityPrefixes`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Manage Permissions for a Dashboard
         * @param {string} workspaceId
         * @param {string} dashboardId
         * @param {Array<PermissionsForAssignee>} permissionsForAssignee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageDashboardPermissions: async (workspaceId, dashboardId, permissionsForAssignee, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("manageDashboardPermissions", "workspaceId", workspaceId);
            // verify required parameter 'dashboardId' is not null or undefined
            assertParamExists("manageDashboardPermissions", "dashboardId", dashboardId);
            // verify required parameter 'permissionsForAssignee' is not null or undefined
            assertParamExists("manageDashboardPermissions", "permissionsForAssignee", permissionsForAssignee);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/analyticalDashboards/{dashboardId}/managePermissions`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof permissionsForAssignee !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(permissionsForAssignee !== undefined ? permissionsForAssignee : {})
                : permissionsForAssignee || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds API identifier overrides in given workspace hierarchy.
         * @summary Finds API identifier overrides in given workspace hierarchy.
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overriddenChildEntities: async (workspaceId, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("overriddenChildEntities", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/overriddenChildEntities`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides information about platform usage, like amount of users, workspaces, ...
         * @summary Info about the platform usage for particular items.
         * @param {PlatformUsageRequest} platformUsageRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        particularPlatformUsage: async (platformUsageRequest, options = {}) => {
            // verify required parameter 'platformUsageRequest' is not null or undefined
            assertParamExists("particularPlatformUsage", "platformUsageRequest", platformUsageRequest);
            const localVarPath = `/api/v1/actions/collectUsage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof platformUsageRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(platformUsageRequest !== undefined ? platformUsageRequest : {})
                : platformUsageRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Notification sets up all reports to be computed again with new data.
         * @summary Register an upload notification
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUploadNotification: async (dataSourceId, options = {}) => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("registerUploadNotification", "dataSourceId", dataSourceId);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/uploadNotification`.replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolves values of available entitlements for the organization.
         * @summary Values for all public entitlements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveAllEntitlements: async (options = {}) => {
            const localVarPath = `/api/v1/actions/resolveEntitlements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolves values for all settings without workspace by current user, organization, or default settings.
         * @summary Values for all settings without workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveAllSettingsWithoutWorkspace: async (options = {}) => {
            const localVarPath = `/api/v1/actions/resolveSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolves values for requested entitlements in the organization.
         * @summary Values for requested public entitlements.
         * @param {EntitlementsRequest} entitlementsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveRequestedEntitlements: async (entitlementsRequest, options = {}) => {
            // verify required parameter 'entitlementsRequest' is not null or undefined
            assertParamExists("resolveRequestedEntitlements", "entitlementsRequest", entitlementsRequest);
            const localVarPath = `/api/v1/actions/resolveEntitlements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof entitlementsRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(entitlementsRequest !== undefined ? entitlementsRequest : {})
                : entitlementsRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolves values for selected settings without workspace by current user, organization, or default settings.
         * @summary Values for selected settings without workspace.
         * @param {ResolveSettingsRequest} resolveSettingsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveSettingsWithoutWorkspace: async (resolveSettingsRequest, options = {}) => {
            // verify required parameter 'resolveSettingsRequest' is not null or undefined
            assertParamExists("resolveSettingsWithoutWorkspace", "resolveSettingsRequest", resolveSettingsRequest);
            const localVarPath = `/api/v1/actions/resolveSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof resolveSettingsRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(resolveSettingsRequest !== undefined ? resolveSettingsRequest : {})
                : resolveSettingsRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolves values for all settings in a workspace by current user, workspace, organization, or default settings.
         * @summary Values for all settings.
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceResolveAllSettings: async (workspaceId, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("workspaceResolveAllSettings", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/resolveSettings`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolves value for selected settings in a workspace by current user, workspace, organization, or default settings.
         * @summary Values for selected settings.
         * @param {string} workspaceId
         * @param {ResolveSettingsRequest} resolveSettingsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceResolveSettings: async (workspaceId, resolveSettingsRequest, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("workspaceResolveSettings", "workspaceId", workspaceId);
            // verify required parameter 'resolveSettingsRequest' is not null or undefined
            assertParamExists("workspaceResolveSettings", "resolveSettingsRequest", resolveSettingsRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/resolveSettings`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof resolveSettingsRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(resolveSettingsRequest !== undefined ? resolveSettingsRequest : {})
                : resolveSettingsRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Provides information about platform usage, like amount of users, workspaces, ...
         * @summary Info about the platform usage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allPlatformUsage(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allPlatformUsage(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Available Assignees
         * @param {string} workspaceId
         * @param {string} dashboardId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableAssignees(workspaceId, dashboardId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableAssignees(workspaceId, dashboardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Finds entities with given ID in hierarchy (e.g. to check possible future conflicts).
         * @summary Finds entities with given ID in hierarchy.
         * @param {string} workspaceId
         * @param {Array<HierarchyObjectIdentification>} hierarchyObjectIdentification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkEntityOverrides(workspaceId, hierarchyObjectIdentification, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkEntityOverrides(workspaceId, hierarchyObjectIdentification, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Dashboard Permissions
         * @param {string} workspaceId
         * @param {string} dashboardId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardPermissions(workspaceId, dashboardId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardPermissions(workspaceId, dashboardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate logical data model (LDM) from physical data model (PDM) stored in data source.
         * @summary Generate logical data model (LDM) from physical data model (PDM)
         * @param {string} dataSourceId
         * @param {GenerateLdmRequest} generateLdmRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateLogicalModel(dataSourceId, generateLdmRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateLogicalModel(dataSourceId, generateLdmRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Computes the dependent entities graph
         * @summary Computes the dependent entities graph
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDependentEntitiesGraph(workspaceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDependentEntitiesGraph(workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Computes the dependent entities graph from given entry points
         * @summary Computes the dependent entities graph from given entry points
         * @param {string} workspaceId
         * @param {DependentEntitiesRequest} dependentEntitiesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDependentEntitiesGraphFromEntryPoints(workspaceId, dependentEntitiesRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDependentEntitiesGraphFromEntryPoints(workspaceId, dependentEntitiesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Finds API identifier conflicts in given workspace hierarchy.
         * @summary Finds API identifier conflicts in given workspace hierarchy.
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inheritedEntityConflicts(workspaceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inheritedEntityConflicts(workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get used entity prefixes in hierarchy of parent workspaces
         * @summary Get used entity prefixes in hierarchy
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inheritedEntityPrefixes(workspaceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inheritedEntityPrefixes(workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Manage Permissions for a Dashboard
         * @param {string} workspaceId
         * @param {string} dashboardId
         * @param {Array<PermissionsForAssignee>} permissionsForAssignee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async manageDashboardPermissions(workspaceId, dashboardId, permissionsForAssignee, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.manageDashboardPermissions(workspaceId, dashboardId, permissionsForAssignee, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Finds API identifier overrides in given workspace hierarchy.
         * @summary Finds API identifier overrides in given workspace hierarchy.
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async overriddenChildEntities(workspaceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.overriddenChildEntities(workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provides information about platform usage, like amount of users, workspaces, ...
         * @summary Info about the platform usage for particular items.
         * @param {PlatformUsageRequest} platformUsageRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async particularPlatformUsage(platformUsageRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.particularPlatformUsage(platformUsageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Notification sets up all reports to be computed again with new data.
         * @summary Register an upload notification
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUploadNotification(dataSourceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUploadNotification(dataSourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resolves values of available entitlements for the organization.
         * @summary Values for all public entitlements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveAllEntitlements(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveAllEntitlements(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resolves values for all settings without workspace by current user, organization, or default settings.
         * @summary Values for all settings without workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveAllSettingsWithoutWorkspace(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveAllSettingsWithoutWorkspace(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resolves values for requested entitlements in the organization.
         * @summary Values for requested public entitlements.
         * @param {EntitlementsRequest} entitlementsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveRequestedEntitlements(entitlementsRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveRequestedEntitlements(entitlementsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resolves values for selected settings without workspace by current user, organization, or default settings.
         * @summary Values for selected settings without workspace.
         * @param {ResolveSettingsRequest} resolveSettingsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveSettingsWithoutWorkspace(resolveSettingsRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveSettingsWithoutWorkspace(resolveSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resolves values for all settings in a workspace by current user, workspace, organization, or default settings.
         * @summary Values for all settings.
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceResolveAllSettings(workspaceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceResolveAllSettings(workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resolves value for selected settings in a workspace by current user, workspace, organization, or default settings.
         * @summary Values for selected settings.
         * @param {string} workspaceId
         * @param {ResolveSettingsRequest} resolveSettingsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceResolveSettings(workspaceId, resolveSettingsRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceResolveSettings(workspaceId, resolveSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ActionsApiFp(configuration);
    return {
        /**
         * Provides information about platform usage, like amount of users, workspaces, ...
         * @summary Info about the platform usage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allPlatformUsage(options) {
            return localVarFp.allPlatformUsage(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Available Assignees
         * @param {ActionsApiAvailableAssigneesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableAssignees(requestParameters, options) {
            return localVarFp
                .availableAssignees(requestParameters.workspaceId, requestParameters.dashboardId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Finds entities with given ID in hierarchy (e.g. to check possible future conflicts).
         * @summary Finds entities with given ID in hierarchy.
         * @param {ActionsApiCheckEntityOverridesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkEntityOverrides(requestParameters, options) {
            return localVarFp
                .checkEntityOverrides(requestParameters.workspaceId, requestParameters.hierarchyObjectIdentification, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Dashboard Permissions
         * @param {ActionsApiDashboardPermissionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardPermissions(requestParameters, options) {
            return localVarFp
                .dashboardPermissions(requestParameters.workspaceId, requestParameters.dashboardId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Generate logical data model (LDM) from physical data model (PDM) stored in data source.
         * @summary Generate logical data model (LDM) from physical data model (PDM)
         * @param {ActionsApiGenerateLogicalModelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateLogicalModel(requestParameters, options) {
            return localVarFp
                .generateLogicalModel(requestParameters.dataSourceId, requestParameters.generateLdmRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Computes the dependent entities graph
         * @summary Computes the dependent entities graph
         * @param {ActionsApiGetDependentEntitiesGraphRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDependentEntitiesGraph(requestParameters, options) {
            return localVarFp
                .getDependentEntitiesGraph(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Computes the dependent entities graph from given entry points
         * @summary Computes the dependent entities graph from given entry points
         * @param {ActionsApiGetDependentEntitiesGraphFromEntryPointsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDependentEntitiesGraphFromEntryPoints(requestParameters, options) {
            return localVarFp
                .getDependentEntitiesGraphFromEntryPoints(requestParameters.workspaceId, requestParameters.dependentEntitiesRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Finds API identifier conflicts in given workspace hierarchy.
         * @summary Finds API identifier conflicts in given workspace hierarchy.
         * @param {ActionsApiInheritedEntityConflictsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inheritedEntityConflicts(requestParameters, options) {
            return localVarFp
                .inheritedEntityConflicts(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Get used entity prefixes in hierarchy of parent workspaces
         * @summary Get used entity prefixes in hierarchy
         * @param {ActionsApiInheritedEntityPrefixesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inheritedEntityPrefixes(requestParameters, options) {
            return localVarFp
                .inheritedEntityPrefixes(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Manage Permissions for a Dashboard
         * @param {ActionsApiManageDashboardPermissionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageDashboardPermissions(requestParameters, options) {
            return localVarFp
                .manageDashboardPermissions(requestParameters.workspaceId, requestParameters.dashboardId, requestParameters.permissionsForAssignee, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Finds API identifier overrides in given workspace hierarchy.
         * @summary Finds API identifier overrides in given workspace hierarchy.
         * @param {ActionsApiOverriddenChildEntitiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overriddenChildEntities(requestParameters, options) {
            return localVarFp
                .overriddenChildEntities(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Provides information about platform usage, like amount of users, workspaces, ...
         * @summary Info about the platform usage for particular items.
         * @param {ActionsApiParticularPlatformUsageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        particularPlatformUsage(requestParameters, options) {
            return localVarFp
                .particularPlatformUsage(requestParameters.platformUsageRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Notification sets up all reports to be computed again with new data.
         * @summary Register an upload notification
         * @param {ActionsApiRegisterUploadNotificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUploadNotification(requestParameters, options) {
            return localVarFp
                .registerUploadNotification(requestParameters.dataSourceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Resolves values of available entitlements for the organization.
         * @summary Values for all public entitlements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveAllEntitlements(options) {
            return localVarFp.resolveAllEntitlements(options).then((request) => request(axios, basePath));
        },
        /**
         * Resolves values for all settings without workspace by current user, organization, or default settings.
         * @summary Values for all settings without workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveAllSettingsWithoutWorkspace(options) {
            return localVarFp
                .resolveAllSettingsWithoutWorkspace(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Resolves values for requested entitlements in the organization.
         * @summary Values for requested public entitlements.
         * @param {ActionsApiResolveRequestedEntitlementsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveRequestedEntitlements(requestParameters, options) {
            return localVarFp
                .resolveRequestedEntitlements(requestParameters.entitlementsRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Resolves values for selected settings without workspace by current user, organization, or default settings.
         * @summary Values for selected settings without workspace.
         * @param {ActionsApiResolveSettingsWithoutWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveSettingsWithoutWorkspace(requestParameters, options) {
            return localVarFp
                .resolveSettingsWithoutWorkspace(requestParameters.resolveSettingsRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Resolves values for all settings in a workspace by current user, workspace, organization, or default settings.
         * @summary Values for all settings.
         * @param {ActionsApiWorkspaceResolveAllSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceResolveAllSettings(requestParameters, options) {
            return localVarFp
                .workspaceResolveAllSettings(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Resolves value for selected settings in a workspace by current user, workspace, organization, or default settings.
         * @summary Values for selected settings.
         * @param {ActionsApiWorkspaceResolveSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceResolveSettings(requestParameters, options) {
            return localVarFp
                .workspaceResolveSettings(requestParameters.workspaceId, requestParameters.resolveSettingsRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI {
    /**
     * Provides information about platform usage, like amount of users, workspaces, ...
     * @summary Info about the platform usage.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    allPlatformUsage(options) {
        return ActionsApiFp(this.configuration)
            .allPlatformUsage(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Available Assignees
     * @param {ActionsApiAvailableAssigneesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    availableAssignees(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .availableAssignees(requestParameters.workspaceId, requestParameters.dashboardId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Finds entities with given ID in hierarchy (e.g. to check possible future conflicts).
     * @summary Finds entities with given ID in hierarchy.
     * @param {ActionsApiCheckEntityOverridesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    checkEntityOverrides(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .checkEntityOverrides(requestParameters.workspaceId, requestParameters.hierarchyObjectIdentification, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Dashboard Permissions
     * @param {ActionsApiDashboardPermissionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    dashboardPermissions(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .dashboardPermissions(requestParameters.workspaceId, requestParameters.dashboardId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generate logical data model (LDM) from physical data model (PDM) stored in data source.
     * @summary Generate logical data model (LDM) from physical data model (PDM)
     * @param {ActionsApiGenerateLogicalModelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    generateLogicalModel(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .generateLogicalModel(requestParameters.dataSourceId, requestParameters.generateLdmRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Computes the dependent entities graph
     * @summary Computes the dependent entities graph
     * @param {ActionsApiGetDependentEntitiesGraphRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    getDependentEntitiesGraph(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .getDependentEntitiesGraph(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Computes the dependent entities graph from given entry points
     * @summary Computes the dependent entities graph from given entry points
     * @param {ActionsApiGetDependentEntitiesGraphFromEntryPointsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    getDependentEntitiesGraphFromEntryPoints(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .getDependentEntitiesGraphFromEntryPoints(requestParameters.workspaceId, requestParameters.dependentEntitiesRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Finds API identifier conflicts in given workspace hierarchy.
     * @summary Finds API identifier conflicts in given workspace hierarchy.
     * @param {ActionsApiInheritedEntityConflictsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    inheritedEntityConflicts(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .inheritedEntityConflicts(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get used entity prefixes in hierarchy of parent workspaces
     * @summary Get used entity prefixes in hierarchy
     * @param {ActionsApiInheritedEntityPrefixesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    inheritedEntityPrefixes(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .inheritedEntityPrefixes(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Manage Permissions for a Dashboard
     * @param {ActionsApiManageDashboardPermissionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    manageDashboardPermissions(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .manageDashboardPermissions(requestParameters.workspaceId, requestParameters.dashboardId, requestParameters.permissionsForAssignee, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Finds API identifier overrides in given workspace hierarchy.
     * @summary Finds API identifier overrides in given workspace hierarchy.
     * @param {ActionsApiOverriddenChildEntitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    overriddenChildEntities(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .overriddenChildEntities(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Provides information about platform usage, like amount of users, workspaces, ...
     * @summary Info about the platform usage for particular items.
     * @param {ActionsApiParticularPlatformUsageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    particularPlatformUsage(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .particularPlatformUsage(requestParameters.platformUsageRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Notification sets up all reports to be computed again with new data.
     * @summary Register an upload notification
     * @param {ActionsApiRegisterUploadNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    registerUploadNotification(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .registerUploadNotification(requestParameters.dataSourceId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Resolves values of available entitlements for the organization.
     * @summary Values for all public entitlements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    resolveAllEntitlements(options) {
        return ActionsApiFp(this.configuration)
            .resolveAllEntitlements(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Resolves values for all settings without workspace by current user, organization, or default settings.
     * @summary Values for all settings without workspace.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    resolveAllSettingsWithoutWorkspace(options) {
        return ActionsApiFp(this.configuration)
            .resolveAllSettingsWithoutWorkspace(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Resolves values for requested entitlements in the organization.
     * @summary Values for requested public entitlements.
     * @param {ActionsApiResolveRequestedEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    resolveRequestedEntitlements(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .resolveRequestedEntitlements(requestParameters.entitlementsRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Resolves values for selected settings without workspace by current user, organization, or default settings.
     * @summary Values for selected settings without workspace.
     * @param {ActionsApiResolveSettingsWithoutWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    resolveSettingsWithoutWorkspace(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .resolveSettingsWithoutWorkspace(requestParameters.resolveSettingsRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Resolves values for all settings in a workspace by current user, workspace, organization, or default settings.
     * @summary Values for all settings.
     * @param {ActionsApiWorkspaceResolveAllSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    workspaceResolveAllSettings(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .workspaceResolveAllSettings(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Resolves value for selected settings in a workspace by current user, workspace, organization, or default settings.
     * @summary Values for selected settings.
     * @param {ActionsApiWorkspaceResolveSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    workspaceResolveSettings(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .workspaceResolveSettings(requestParameters.workspaceId, requestParameters.resolveSettingsRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * AnalyticsModelApi - axios parameter creator
 * @export
 */
export const AnalyticsModelApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve current analytics model of the workspace.
         * @summary Get analytics model
         * @param {string} workspaceId
         * @param {Array<'ACTIVITY_INFO'>} [exclude]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalyticsModel: async (workspaceId, exclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAnalyticsModel", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/layout/workspaces/{workspaceId}/analyticsModel`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (exclude) {
                localVarQueryParameter["exclude"] = exclude;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set effective analytics model of the workspace.
         * @summary Set analytics model
         * @param {string} workspaceId
         * @param {DeclarativeAnalytics} declarativeAnalytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAnalyticsModel: async (workspaceId, declarativeAnalytics, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("setAnalyticsModel", "workspaceId", workspaceId);
            // verify required parameter 'declarativeAnalytics' is not null or undefined
            assertParamExists("setAnalyticsModel", "declarativeAnalytics", declarativeAnalytics);
            const localVarPath = `/api/v1/layout/workspaces/{workspaceId}/analyticsModel`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeAnalytics !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeAnalytics !== undefined ? declarativeAnalytics : {})
                : declarativeAnalytics || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AnalyticsModelApi - functional programming interface
 * @export
 */
export const AnalyticsModelApiFp = function (configuration) {
    const localVarAxiosParamCreator = AnalyticsModelApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieve current analytics model of the workspace.
         * @summary Get analytics model
         * @param {string} workspaceId
         * @param {Array<'ACTIVITY_INFO'>} [exclude]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnalyticsModel(workspaceId, exclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnalyticsModel(workspaceId, exclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set effective analytics model of the workspace.
         * @summary Set analytics model
         * @param {string} workspaceId
         * @param {DeclarativeAnalytics} declarativeAnalytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAnalyticsModel(workspaceId, declarativeAnalytics, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAnalyticsModel(workspaceId, declarativeAnalytics, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * AnalyticsModelApi - factory interface
 * @export
 */
export const AnalyticsModelApiFactory = function (configuration, basePath, axios) {
    const localVarFp = AnalyticsModelApiFp(configuration);
    return {
        /**
         * Retrieve current analytics model of the workspace.
         * @summary Get analytics model
         * @param {AnalyticsModelApiGetAnalyticsModelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalyticsModel(requestParameters, options) {
            return localVarFp
                .getAnalyticsModel(requestParameters.workspaceId, requestParameters.exclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Set effective analytics model of the workspace.
         * @summary Set analytics model
         * @param {AnalyticsModelApiSetAnalyticsModelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAnalyticsModel(requestParameters, options) {
            return localVarFp
                .setAnalyticsModel(requestParameters.workspaceId, requestParameters.declarativeAnalytics, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * AnalyticsModelApi - object-oriented interface
 * @export
 * @class AnalyticsModelApi
 * @extends {BaseAPI}
 */
export class AnalyticsModelApi extends BaseAPI {
    /**
     * Retrieve current analytics model of the workspace.
     * @summary Get analytics model
     * @param {AnalyticsModelApiGetAnalyticsModelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsModelApi
     */
    getAnalyticsModel(requestParameters, options) {
        return AnalyticsModelApiFp(this.configuration)
            .getAnalyticsModel(requestParameters.workspaceId, requestParameters.exclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Set effective analytics model of the workspace.
     * @summary Set analytics model
     * @param {AnalyticsModelApiSetAnalyticsModelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsModelApi
     */
    setAnalyticsModel(requestParameters, options) {
        return AnalyticsModelApiFp(this.configuration)
            .setAnalyticsModel(requestParameters.workspaceId, requestParameters.declarativeAnalytics, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * AppearanceApi - axios parameter creator
 * @export
 */
export const AppearanceApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Post Color Pallettes
         * @param {JsonApiColorPaletteInDocument} jsonApiColorPaletteInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityColorPalettes: async (jsonApiColorPaletteInDocument, options = {}) => {
            // verify required parameter 'jsonApiColorPaletteInDocument' is not null or undefined
            assertParamExists("createEntityColorPalettes", "jsonApiColorPaletteInDocument", jsonApiColorPaletteInDocument);
            const localVarPath = `/api/v1/entities/colorPalettes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiColorPaletteInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiColorPaletteInDocument !== undefined ? jsonApiColorPaletteInDocument : {})
                : jsonApiColorPaletteInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Theming
         * @param {JsonApiThemeInDocument} jsonApiThemeInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityThemes: async (jsonApiThemeInDocument, options = {}) => {
            // verify required parameter 'jsonApiThemeInDocument' is not null or undefined
            assertParamExists("createEntityThemes", "jsonApiThemeInDocument", jsonApiThemeInDocument);
            const localVarPath = `/api/v1/entities/themes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiThemeInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiThemeInDocument !== undefined ? jsonApiThemeInDocument : {})
                : jsonApiThemeInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Color Pallette
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityColorPalettes: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityColorPalettes", "id", id);
            const localVarPath = `/api/v1/entities/colorPalettes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete Theming
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityThemes: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityThemes", "id", id);
            const localVarPath = `/api/v1/entities/themes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Color Pallettes
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesColorPalettes: async (filter, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/colorPalettes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Theming entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesThemes: async (filter, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/themes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Color Pallette
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityColorPalettes: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityColorPalettes", "id", id);
            const localVarPath = `/api/v1/entities/colorPalettes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Theming
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityThemes: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityThemes", "id", id);
            const localVarPath = `/api/v1/entities/themes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch Color Pallette
         * @param {string} id
         * @param {JsonApiColorPalettePatchDocument} jsonApiColorPalettePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityColorPalettes: async (id, jsonApiColorPalettePatchDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityColorPalettes", "id", id);
            // verify required parameter 'jsonApiColorPalettePatchDocument' is not null or undefined
            assertParamExists("patchEntityColorPalettes", "jsonApiColorPalettePatchDocument", jsonApiColorPalettePatchDocument);
            const localVarPath = `/api/v1/entities/colorPalettes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiColorPalettePatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiColorPalettePatchDocument !== undefined ? jsonApiColorPalettePatchDocument : {})
                : jsonApiColorPalettePatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch Theming
         * @param {string} id
         * @param {JsonApiThemePatchDocument} jsonApiThemePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityThemes: async (id, jsonApiThemePatchDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityThemes", "id", id);
            // verify required parameter 'jsonApiThemePatchDocument' is not null or undefined
            assertParamExists("patchEntityThemes", "jsonApiThemePatchDocument", jsonApiThemePatchDocument);
            const localVarPath = `/api/v1/entities/themes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiThemePatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiThemePatchDocument !== undefined ? jsonApiThemePatchDocument : {})
                : jsonApiThemePatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put Color Pallette
         * @param {string} id
         * @param {JsonApiColorPaletteInDocument} jsonApiColorPaletteInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityColorPalettes: async (id, jsonApiColorPaletteInDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityColorPalettes", "id", id);
            // verify required parameter 'jsonApiColorPaletteInDocument' is not null or undefined
            assertParamExists("updateEntityColorPalettes", "jsonApiColorPaletteInDocument", jsonApiColorPaletteInDocument);
            const localVarPath = `/api/v1/entities/colorPalettes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiColorPaletteInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiColorPaletteInDocument !== undefined ? jsonApiColorPaletteInDocument : {})
                : jsonApiColorPaletteInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put Theming
         * @param {string} id
         * @param {JsonApiThemeInDocument} jsonApiThemeInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityThemes: async (id, jsonApiThemeInDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityThemes", "id", id);
            // verify required parameter 'jsonApiThemeInDocument' is not null or undefined
            assertParamExists("updateEntityThemes", "jsonApiThemeInDocument", jsonApiThemeInDocument);
            const localVarPath = `/api/v1/entities/themes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiThemeInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiThemeInDocument !== undefined ? jsonApiThemeInDocument : {})
                : jsonApiThemeInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AppearanceApi - functional programming interface
 * @export
 */
export const AppearanceApiFp = function (configuration) {
    const localVarAxiosParamCreator = AppearanceApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Post Color Pallettes
         * @param {JsonApiColorPaletteInDocument} jsonApiColorPaletteInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityColorPalettes(jsonApiColorPaletteInDocument, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityColorPalettes(jsonApiColorPaletteInDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Theming
         * @param {JsonApiThemeInDocument} jsonApiThemeInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityThemes(jsonApiThemeInDocument, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityThemes(jsonApiThemeInDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Color Pallette
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityColorPalettes(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityColorPalettes(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete Theming
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityThemes(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityThemes(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Color Pallettes
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesColorPalettes(filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesColorPalettes(filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Theming entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesThemes(filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesThemes(filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Color Pallette
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityColorPalettes(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityColorPalettes(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Theming
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityThemes(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityThemes(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch Color Pallette
         * @param {string} id
         * @param {JsonApiColorPalettePatchDocument} jsonApiColorPalettePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityColorPalettes(id, jsonApiColorPalettePatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityColorPalettes(id, jsonApiColorPalettePatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch Theming
         * @param {string} id
         * @param {JsonApiThemePatchDocument} jsonApiThemePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityThemes(id, jsonApiThemePatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityThemes(id, jsonApiThemePatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put Color Pallette
         * @param {string} id
         * @param {JsonApiColorPaletteInDocument} jsonApiColorPaletteInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityColorPalettes(id, jsonApiColorPaletteInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityColorPalettes(id, jsonApiColorPaletteInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put Theming
         * @param {string} id
         * @param {JsonApiThemeInDocument} jsonApiThemeInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityThemes(id, jsonApiThemeInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityThemes(id, jsonApiThemeInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * AppearanceApi - factory interface
 * @export
 */
export const AppearanceApiFactory = function (configuration, basePath, axios) {
    const localVarFp = AppearanceApiFp(configuration);
    return {
        /**
         *
         * @summary Post Color Pallettes
         * @param {AppearanceApiCreateEntityColorPalettesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityColorPalettes(requestParameters, options) {
            return localVarFp
                .createEntityColorPalettes(requestParameters.jsonApiColorPaletteInDocument, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Theming
         * @param {AppearanceApiCreateEntityThemesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityThemes(requestParameters, options) {
            return localVarFp
                .createEntityThemes(requestParameters.jsonApiThemeInDocument, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Color Pallette
         * @param {AppearanceApiDeleteEntityColorPalettesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityColorPalettes(requestParameters, options) {
            return localVarFp
                .deleteEntityColorPalettes(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete Theming
         * @param {AppearanceApiDeleteEntityThemesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityThemes(requestParameters, options) {
            return localVarFp
                .deleteEntityThemes(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Color Pallettes
         * @param {AppearanceApiGetAllEntitiesColorPalettesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesColorPalettes(requestParameters, options) {
            return localVarFp
                .getAllEntitiesColorPalettes(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Theming entities
         * @param {AppearanceApiGetAllEntitiesThemesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesThemes(requestParameters, options) {
            return localVarFp
                .getAllEntitiesThemes(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Color Pallette
         * @param {AppearanceApiGetEntityColorPalettesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityColorPalettes(requestParameters, options) {
            return localVarFp
                .getEntityColorPalettes(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Theming
         * @param {AppearanceApiGetEntityThemesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityThemes(requestParameters, options) {
            return localVarFp
                .getEntityThemes(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch Color Pallette
         * @param {AppearanceApiPatchEntityColorPalettesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityColorPalettes(requestParameters, options) {
            return localVarFp
                .patchEntityColorPalettes(requestParameters.id, requestParameters.jsonApiColorPalettePatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch Theming
         * @param {AppearanceApiPatchEntityThemesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityThemes(requestParameters, options) {
            return localVarFp
                .patchEntityThemes(requestParameters.id, requestParameters.jsonApiThemePatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put Color Pallette
         * @param {AppearanceApiUpdateEntityColorPalettesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityColorPalettes(requestParameters, options) {
            return localVarFp
                .updateEntityColorPalettes(requestParameters.id, requestParameters.jsonApiColorPaletteInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put Theming
         * @param {AppearanceApiUpdateEntityThemesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityThemes(requestParameters, options) {
            return localVarFp
                .updateEntityThemes(requestParameters.id, requestParameters.jsonApiThemeInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * AppearanceApi - object-oriented interface
 * @export
 * @class AppearanceApi
 * @extends {BaseAPI}
 */
export class AppearanceApi extends BaseAPI {
    /**
     *
     * @summary Post Color Pallettes
     * @param {AppearanceApiCreateEntityColorPalettesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppearanceApi
     */
    createEntityColorPalettes(requestParameters, options) {
        return AppearanceApiFp(this.configuration)
            .createEntityColorPalettes(requestParameters.jsonApiColorPaletteInDocument, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Theming
     * @param {AppearanceApiCreateEntityThemesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppearanceApi
     */
    createEntityThemes(requestParameters, options) {
        return AppearanceApiFp(this.configuration)
            .createEntityThemes(requestParameters.jsonApiThemeInDocument, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Color Pallette
     * @param {AppearanceApiDeleteEntityColorPalettesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppearanceApi
     */
    deleteEntityColorPalettes(requestParameters, options) {
        return AppearanceApiFp(this.configuration)
            .deleteEntityColorPalettes(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete Theming
     * @param {AppearanceApiDeleteEntityThemesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppearanceApi
     */
    deleteEntityThemes(requestParameters, options) {
        return AppearanceApiFp(this.configuration)
            .deleteEntityThemes(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Color Pallettes
     * @param {AppearanceApiGetAllEntitiesColorPalettesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppearanceApi
     */
    getAllEntitiesColorPalettes(requestParameters = {}, options) {
        return AppearanceApiFp(this.configuration)
            .getAllEntitiesColorPalettes(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Theming entities
     * @param {AppearanceApiGetAllEntitiesThemesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppearanceApi
     */
    getAllEntitiesThemes(requestParameters = {}, options) {
        return AppearanceApiFp(this.configuration)
            .getAllEntitiesThemes(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Color Pallette
     * @param {AppearanceApiGetEntityColorPalettesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppearanceApi
     */
    getEntityColorPalettes(requestParameters, options) {
        return AppearanceApiFp(this.configuration)
            .getEntityColorPalettes(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Theming
     * @param {AppearanceApiGetEntityThemesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppearanceApi
     */
    getEntityThemes(requestParameters, options) {
        return AppearanceApiFp(this.configuration)
            .getEntityThemes(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch Color Pallette
     * @param {AppearanceApiPatchEntityColorPalettesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppearanceApi
     */
    patchEntityColorPalettes(requestParameters, options) {
        return AppearanceApiFp(this.configuration)
            .patchEntityColorPalettes(requestParameters.id, requestParameters.jsonApiColorPalettePatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch Theming
     * @param {AppearanceApiPatchEntityThemesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppearanceApi
     */
    patchEntityThemes(requestParameters, options) {
        return AppearanceApiFp(this.configuration)
            .patchEntityThemes(requestParameters.id, requestParameters.jsonApiThemePatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put Color Pallette
     * @param {AppearanceApiUpdateEntityColorPalettesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppearanceApi
     */
    updateEntityColorPalettes(requestParameters, options) {
        return AppearanceApiFp(this.configuration)
            .updateEntityColorPalettes(requestParameters.id, requestParameters.jsonApiColorPaletteInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put Theming
     * @param {AppearanceApiUpdateEntityThemesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppearanceApi
     */
    updateEntityThemes(requestParameters, options) {
        return AppearanceApiFp(this.configuration)
            .updateEntityThemes(requestParameters.id, requestParameters.jsonApiThemeInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * AttributeHierarchiesApi - axios parameter creator
 * @export
 */
export const AttributeHierarchiesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Post Attribute Hierarchies
         * @param {string} workspaceId
         * @param {JsonApiAttributeHierarchyInDocument} jsonApiAttributeHierarchyInDocument
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityAttributeHierarchies: async (workspaceId, jsonApiAttributeHierarchyInDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityAttributeHierarchies", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiAttributeHierarchyInDocument' is not null or undefined
            assertParamExists("createEntityAttributeHierarchies", "jsonApiAttributeHierarchyInDocument", jsonApiAttributeHierarchyInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributeHierarchies`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiAttributeHierarchyInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiAttributeHierarchyInDocument !== undefined
                    ? jsonApiAttributeHierarchyInDocument
                    : {})
                : jsonApiAttributeHierarchyInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityAttributeHierarchies: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityAttributeHierarchies", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityAttributeHierarchies", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributeHierarchies/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Attribute Hierarchies
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAttributeHierarchies: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesAttributeHierarchies", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributeHierarchies`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAttributeHierarchies: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityAttributeHierarchies", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityAttributeHierarchies", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributeHierarchies/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAttributeHierarchyPatchDocument} jsonApiAttributeHierarchyPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityAttributeHierarchies: async (workspaceId, objectId, jsonApiAttributeHierarchyPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityAttributeHierarchies", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityAttributeHierarchies", "objectId", objectId);
            // verify required parameter 'jsonApiAttributeHierarchyPatchDocument' is not null or undefined
            assertParamExists("patchEntityAttributeHierarchies", "jsonApiAttributeHierarchyPatchDocument", jsonApiAttributeHierarchyPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributeHierarchies/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiAttributeHierarchyPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiAttributeHierarchyPatchDocument !== undefined
                    ? jsonApiAttributeHierarchyPatchDocument
                    : {})
                : jsonApiAttributeHierarchyPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAttributeHierarchyInDocument} jsonApiAttributeHierarchyInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityAttributeHierarchies: async (workspaceId, objectId, jsonApiAttributeHierarchyInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityAttributeHierarchies", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityAttributeHierarchies", "objectId", objectId);
            // verify required parameter 'jsonApiAttributeHierarchyInDocument' is not null or undefined
            assertParamExists("updateEntityAttributeHierarchies", "jsonApiAttributeHierarchyInDocument", jsonApiAttributeHierarchyInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributeHierarchies/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiAttributeHierarchyInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiAttributeHierarchyInDocument !== undefined
                    ? jsonApiAttributeHierarchyInDocument
                    : {})
                : jsonApiAttributeHierarchyInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AttributeHierarchiesApi - functional programming interface
 * @export
 */
export const AttributeHierarchiesApiFp = function (configuration) {
    const localVarAxiosParamCreator = AttributeHierarchiesApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Post Attribute Hierarchies
         * @param {string} workspaceId
         * @param {JsonApiAttributeHierarchyInDocument} jsonApiAttributeHierarchyInDocument
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityAttributeHierarchies(workspaceId, jsonApiAttributeHierarchyInDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityAttributeHierarchies(workspaceId, jsonApiAttributeHierarchyInDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityAttributeHierarchies(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityAttributeHierarchies(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Attribute Hierarchies
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesAttributeHierarchies(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesAttributeHierarchies(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityAttributeHierarchies(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityAttributeHierarchies(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAttributeHierarchyPatchDocument} jsonApiAttributeHierarchyPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityAttributeHierarchies(workspaceId, objectId, jsonApiAttributeHierarchyPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityAttributeHierarchies(workspaceId, objectId, jsonApiAttributeHierarchyPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAttributeHierarchyInDocument} jsonApiAttributeHierarchyInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityAttributeHierarchies(workspaceId, objectId, jsonApiAttributeHierarchyInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityAttributeHierarchies(workspaceId, objectId, jsonApiAttributeHierarchyInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * AttributeHierarchiesApi - factory interface
 * @export
 */
export const AttributeHierarchiesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = AttributeHierarchiesApiFp(configuration);
    return {
        /**
         *
         * @summary Post Attribute Hierarchies
         * @param {AttributeHierarchiesApiCreateEntityAttributeHierarchiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityAttributeHierarchies(requestParameters, options) {
            return localVarFp
                .createEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.jsonApiAttributeHierarchyInDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete an Attribute Hierarchy
         * @param {AttributeHierarchiesApiDeleteEntityAttributeHierarchiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityAttributeHierarchies(requestParameters, options) {
            return localVarFp
                .deleteEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Attribute Hierarchies
         * @param {AttributeHierarchiesApiGetAllEntitiesAttributeHierarchiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAttributeHierarchies(requestParameters, options) {
            return localVarFp
                .getAllEntitiesAttributeHierarchies(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get an Attribute Hierarchy
         * @param {AttributeHierarchiesApiGetEntityAttributeHierarchiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAttributeHierarchies(requestParameters, options) {
            return localVarFp
                .getEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch an Attribute Hierarchy
         * @param {AttributeHierarchiesApiPatchEntityAttributeHierarchiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityAttributeHierarchies(requestParameters, options) {
            return localVarFp
                .patchEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAttributeHierarchyPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put an Attribute Hierarchy
         * @param {AttributeHierarchiesApiUpdateEntityAttributeHierarchiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityAttributeHierarchies(requestParameters, options) {
            return localVarFp
                .updateEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAttributeHierarchyInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * AttributeHierarchiesApi - object-oriented interface
 * @export
 * @class AttributeHierarchiesApi
 * @extends {BaseAPI}
 */
export class AttributeHierarchiesApi extends BaseAPI {
    /**
     *
     * @summary Post Attribute Hierarchies
     * @param {AttributeHierarchiesApiCreateEntityAttributeHierarchiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributeHierarchiesApi
     */
    createEntityAttributeHierarchies(requestParameters, options) {
        return AttributeHierarchiesApiFp(this.configuration)
            .createEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.jsonApiAttributeHierarchyInDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete an Attribute Hierarchy
     * @param {AttributeHierarchiesApiDeleteEntityAttributeHierarchiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributeHierarchiesApi
     */
    deleteEntityAttributeHierarchies(requestParameters, options) {
        return AttributeHierarchiesApiFp(this.configuration)
            .deleteEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Attribute Hierarchies
     * @param {AttributeHierarchiesApiGetAllEntitiesAttributeHierarchiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributeHierarchiesApi
     */
    getAllEntitiesAttributeHierarchies(requestParameters, options) {
        return AttributeHierarchiesApiFp(this.configuration)
            .getAllEntitiesAttributeHierarchies(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get an Attribute Hierarchy
     * @param {AttributeHierarchiesApiGetEntityAttributeHierarchiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributeHierarchiesApi
     */
    getEntityAttributeHierarchies(requestParameters, options) {
        return AttributeHierarchiesApiFp(this.configuration)
            .getEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch an Attribute Hierarchy
     * @param {AttributeHierarchiesApiPatchEntityAttributeHierarchiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributeHierarchiesApi
     */
    patchEntityAttributeHierarchies(requestParameters, options) {
        return AttributeHierarchiesApiFp(this.configuration)
            .patchEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAttributeHierarchyPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put an Attribute Hierarchy
     * @param {AttributeHierarchiesApiUpdateEntityAttributeHierarchiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributeHierarchiesApi
     */
    updateEntityAttributeHierarchies(requestParameters, options) {
        return AttributeHierarchiesApiFp(this.configuration)
            .updateEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAttributeHierarchyInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * AttributesApi - axios parameter creator
 * @export
 */
export const AttributesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get all Attributes
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'labels' | 'attributeHierarchies' | 'dataset' | 'defaultView' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAttributes: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesAttributes", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributes`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get an Attribute
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'labels' | 'attributeHierarchies' | 'dataset' | 'defaultView' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAttributes: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityAttributes", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityAttributes", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributes/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AttributesApi - functional programming interface
 * @export
 */
export const AttributesApiFp = function (configuration) {
    const localVarAxiosParamCreator = AttributesApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get all Attributes
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'labels' | 'attributeHierarchies' | 'dataset' | 'defaultView' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesAttributes(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesAttributes(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get an Attribute
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'labels' | 'attributeHierarchies' | 'dataset' | 'defaultView' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityAttributes(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityAttributes(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * AttributesApi - factory interface
 * @export
 */
export const AttributesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = AttributesApiFp(configuration);
    return {
        /**
         *
         * @summary Get all Attributes
         * @param {AttributesApiGetAllEntitiesAttributesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAttributes(requestParameters, options) {
            return localVarFp
                .getAllEntitiesAttributes(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get an Attribute
         * @param {AttributesApiGetEntityAttributesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAttributes(requestParameters, options) {
            return localVarFp
                .getEntityAttributes(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * AttributesApi - object-oriented interface
 * @export
 * @class AttributesApi
 * @extends {BaseAPI}
 */
export class AttributesApi extends BaseAPI {
    /**
     *
     * @summary Get all Attributes
     * @param {AttributesApiGetAllEntitiesAttributesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    getAllEntitiesAttributes(requestParameters, options) {
        return AttributesApiFp(this.configuration)
            .getAllEntitiesAttributes(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get an Attribute
     * @param {AttributesApiGetEntityAttributesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    getEntityAttributes(requestParameters, options) {
        return AttributesApiFp(this.configuration)
            .getEntityAttributes(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * AvailableDriversApi - axios parameter creator
 * @export
 */
export const AvailableDriversApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves a list of all supported data sources along with information about the used drivers.
         * @summary Get all available data source drivers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceDrivers: async (options = {}) => {
            const localVarPath = `/api/v1/options/availableDrivers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AvailableDriversApi - functional programming interface
 * @export
 */
export const AvailableDriversApiFp = function (configuration) {
    const localVarAxiosParamCreator = AvailableDriversApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieves a list of all supported data sources along with information about the used drivers.
         * @summary Get all available data source drivers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataSourceDrivers(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataSourceDrivers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * AvailableDriversApi - factory interface
 * @export
 */
export const AvailableDriversApiFactory = function (configuration, basePath, axios) {
    const localVarFp = AvailableDriversApiFp(configuration);
    return {
        /**
         * Retrieves a list of all supported data sources along with information about the used drivers.
         * @summary Get all available data source drivers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceDrivers(options) {
            return localVarFp.getDataSourceDrivers(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AvailableDriversApi - object-oriented interface
 * @export
 * @class AvailableDriversApi
 * @extends {BaseAPI}
 */
export class AvailableDriversApi extends BaseAPI {
    /**
     * Retrieves a list of all supported data sources along with information about the used drivers.
     * @summary Get all available data source drivers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailableDriversApi
     */
    getDataSourceDrivers(options) {
        return AvailableDriversApiFp(this.configuration)
            .getDataSourceDrivers(options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * CSPDirectivesApi - axios parameter creator
 * @export
 */
export const CSPDirectivesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Context Security Police Directive
         * @summary Post CSP Directives
         * @param {JsonApiCspDirectiveInDocument} jsonApiCspDirectiveInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityCspDirectives: async (jsonApiCspDirectiveInDocument, options = {}) => {
            // verify required parameter 'jsonApiCspDirectiveInDocument' is not null or undefined
            assertParamExists("createEntityCspDirectives", "jsonApiCspDirectiveInDocument", jsonApiCspDirectiveInDocument);
            const localVarPath = `/api/v1/entities/cspDirectives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCspDirectiveInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCspDirectiveInDocument !== undefined ? jsonApiCspDirectiveInDocument : {})
                : jsonApiCspDirectiveInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Context Security Police Directive
         * @summary Delete CSP Directives
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityCspDirectives: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityCspDirectives", "id", id);
            const localVarPath = `/api/v1/entities/cspDirectives/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Context Security Police Directive
         * @summary Get CSP Directives
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesCspDirectives: async (filter, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/cspDirectives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Context Security Police Directive
         * @summary Get CSP Directives
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityCspDirectives: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityCspDirectives", "id", id);
            const localVarPath = `/api/v1/entities/cspDirectives/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Context Security Police Directive
         * @summary Patch CSP Directives
         * @param {string} id
         * @param {JsonApiCspDirectivePatchDocument} jsonApiCspDirectivePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityCspDirectives: async (id, jsonApiCspDirectivePatchDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityCspDirectives", "id", id);
            // verify required parameter 'jsonApiCspDirectivePatchDocument' is not null or undefined
            assertParamExists("patchEntityCspDirectives", "jsonApiCspDirectivePatchDocument", jsonApiCspDirectivePatchDocument);
            const localVarPath = `/api/v1/entities/cspDirectives/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCspDirectivePatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCspDirectivePatchDocument !== undefined ? jsonApiCspDirectivePatchDocument : {})
                : jsonApiCspDirectivePatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Context Security Police Directive
         * @summary Put CSP Directives
         * @param {string} id
         * @param {JsonApiCspDirectiveInDocument} jsonApiCspDirectiveInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityCspDirectives: async (id, jsonApiCspDirectiveInDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityCspDirectives", "id", id);
            // verify required parameter 'jsonApiCspDirectiveInDocument' is not null or undefined
            assertParamExists("updateEntityCspDirectives", "jsonApiCspDirectiveInDocument", jsonApiCspDirectiveInDocument);
            const localVarPath = `/api/v1/entities/cspDirectives/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCspDirectiveInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCspDirectiveInDocument !== undefined ? jsonApiCspDirectiveInDocument : {})
                : jsonApiCspDirectiveInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CSPDirectivesApi - functional programming interface
 * @export
 */
export const CSPDirectivesApiFp = function (configuration) {
    const localVarAxiosParamCreator = CSPDirectivesApiAxiosParamCreator(configuration);
    return {
        /**
         *  Context Security Police Directive
         * @summary Post CSP Directives
         * @param {JsonApiCspDirectiveInDocument} jsonApiCspDirectiveInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityCspDirectives(jsonApiCspDirectiveInDocument, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityCspDirectives(jsonApiCspDirectiveInDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Context Security Police Directive
         * @summary Delete CSP Directives
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityCspDirectives(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityCspDirectives(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Context Security Police Directive
         * @summary Get CSP Directives
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesCspDirectives(filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesCspDirectives(filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Context Security Police Directive
         * @summary Get CSP Directives
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityCspDirectives(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityCspDirectives(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Context Security Police Directive
         * @summary Patch CSP Directives
         * @param {string} id
         * @param {JsonApiCspDirectivePatchDocument} jsonApiCspDirectivePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityCspDirectives(id, jsonApiCspDirectivePatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityCspDirectives(id, jsonApiCspDirectivePatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Context Security Police Directive
         * @summary Put CSP Directives
         * @param {string} id
         * @param {JsonApiCspDirectiveInDocument} jsonApiCspDirectiveInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityCspDirectives(id, jsonApiCspDirectiveInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityCspDirectives(id, jsonApiCspDirectiveInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * CSPDirectivesApi - factory interface
 * @export
 */
export const CSPDirectivesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = CSPDirectivesApiFp(configuration);
    return {
        /**
         *  Context Security Police Directive
         * @summary Post CSP Directives
         * @param {CSPDirectivesApiCreateEntityCspDirectivesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityCspDirectives(requestParameters, options) {
            return localVarFp
                .createEntityCspDirectives(requestParameters.jsonApiCspDirectiveInDocument, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *  Context Security Police Directive
         * @summary Delete CSP Directives
         * @param {CSPDirectivesApiDeleteEntityCspDirectivesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityCspDirectives(requestParameters, options) {
            return localVarFp
                .deleteEntityCspDirectives(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *  Context Security Police Directive
         * @summary Get CSP Directives
         * @param {CSPDirectivesApiGetAllEntitiesCspDirectivesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesCspDirectives(requestParameters, options) {
            return localVarFp
                .getAllEntitiesCspDirectives(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *  Context Security Police Directive
         * @summary Get CSP Directives
         * @param {CSPDirectivesApiGetEntityCspDirectivesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityCspDirectives(requestParameters, options) {
            return localVarFp
                .getEntityCspDirectives(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *  Context Security Police Directive
         * @summary Patch CSP Directives
         * @param {CSPDirectivesApiPatchEntityCspDirectivesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityCspDirectives(requestParameters, options) {
            return localVarFp
                .patchEntityCspDirectives(requestParameters.id, requestParameters.jsonApiCspDirectivePatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *  Context Security Police Directive
         * @summary Put CSP Directives
         * @param {CSPDirectivesApiUpdateEntityCspDirectivesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityCspDirectives(requestParameters, options) {
            return localVarFp
                .updateEntityCspDirectives(requestParameters.id, requestParameters.jsonApiCspDirectiveInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * CSPDirectivesApi - object-oriented interface
 * @export
 * @class CSPDirectivesApi
 * @extends {BaseAPI}
 */
export class CSPDirectivesApi extends BaseAPI {
    /**
     *  Context Security Police Directive
     * @summary Post CSP Directives
     * @param {CSPDirectivesApiCreateEntityCspDirectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CSPDirectivesApi
     */
    createEntityCspDirectives(requestParameters, options) {
        return CSPDirectivesApiFp(this.configuration)
            .createEntityCspDirectives(requestParameters.jsonApiCspDirectiveInDocument, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Context Security Police Directive
     * @summary Delete CSP Directives
     * @param {CSPDirectivesApiDeleteEntityCspDirectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CSPDirectivesApi
     */
    deleteEntityCspDirectives(requestParameters, options) {
        return CSPDirectivesApiFp(this.configuration)
            .deleteEntityCspDirectives(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Context Security Police Directive
     * @summary Get CSP Directives
     * @param {CSPDirectivesApiGetAllEntitiesCspDirectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CSPDirectivesApi
     */
    getAllEntitiesCspDirectives(requestParameters = {}, options) {
        return CSPDirectivesApiFp(this.configuration)
            .getAllEntitiesCspDirectives(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Context Security Police Directive
     * @summary Get CSP Directives
     * @param {CSPDirectivesApiGetEntityCspDirectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CSPDirectivesApi
     */
    getEntityCspDirectives(requestParameters, options) {
        return CSPDirectivesApiFp(this.configuration)
            .getEntityCspDirectives(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Context Security Police Directive
     * @summary Patch CSP Directives
     * @param {CSPDirectivesApiPatchEntityCspDirectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CSPDirectivesApi
     */
    patchEntityCspDirectives(requestParameters, options) {
        return CSPDirectivesApiFp(this.configuration)
            .patchEntityCspDirectives(requestParameters.id, requestParameters.jsonApiCspDirectivePatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Context Security Police Directive
     * @summary Put CSP Directives
     * @param {CSPDirectivesApiUpdateEntityCspDirectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CSPDirectivesApi
     */
    updateEntityCspDirectives(requestParameters, options) {
        return CSPDirectivesApiFp(this.configuration)
            .updateEntityCspDirectives(requestParameters.id, requestParameters.jsonApiCspDirectiveInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ContextFiltersApi - axios parameter creator
 * @export
 */
export const ContextFiltersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Post Context Filters
         * @param {string} workspaceId
         * @param {JsonApiFilterContextPostOptionalIdDocument} jsonApiFilterContextPostOptionalIdDocument
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityFilterContexts: async (workspaceId, jsonApiFilterContextPostOptionalIdDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityFilterContexts", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiFilterContextPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityFilterContexts", "jsonApiFilterContextPostOptionalIdDocument", jsonApiFilterContextPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/filterContexts`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiFilterContextPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiFilterContextPostOptionalIdDocument !== undefined
                    ? jsonApiFilterContextPostOptionalIdDocument
                    : {})
                : jsonApiFilterContextPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityFilterContexts: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityFilterContexts", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityFilterContexts", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/filterContexts/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Context Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesFilterContexts: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesFilterContexts", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/filterContexts`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityFilterContexts: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityFilterContexts", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityFilterContexts", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/filterContexts/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiFilterContextPatchDocument} jsonApiFilterContextPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityFilterContexts: async (workspaceId, objectId, jsonApiFilterContextPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityFilterContexts", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityFilterContexts", "objectId", objectId);
            // verify required parameter 'jsonApiFilterContextPatchDocument' is not null or undefined
            assertParamExists("patchEntityFilterContexts", "jsonApiFilterContextPatchDocument", jsonApiFilterContextPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/filterContexts/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiFilterContextPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiFilterContextPatchDocument !== undefined
                    ? jsonApiFilterContextPatchDocument
                    : {})
                : jsonApiFilterContextPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiFilterContextInDocument} jsonApiFilterContextInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityFilterContexts: async (workspaceId, objectId, jsonApiFilterContextInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityFilterContexts", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityFilterContexts", "objectId", objectId);
            // verify required parameter 'jsonApiFilterContextInDocument' is not null or undefined
            assertParamExists("updateEntityFilterContexts", "jsonApiFilterContextInDocument", jsonApiFilterContextInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/filterContexts/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiFilterContextInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiFilterContextInDocument !== undefined ? jsonApiFilterContextInDocument : {})
                : jsonApiFilterContextInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ContextFiltersApi - functional programming interface
 * @export
 */
export const ContextFiltersApiFp = function (configuration) {
    const localVarAxiosParamCreator = ContextFiltersApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Post Context Filters
         * @param {string} workspaceId
         * @param {JsonApiFilterContextPostOptionalIdDocument} jsonApiFilterContextPostOptionalIdDocument
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityFilterContexts(workspaceId, jsonApiFilterContextPostOptionalIdDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityFilterContexts(workspaceId, jsonApiFilterContextPostOptionalIdDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityFilterContexts(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityFilterContexts(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Context Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesFilterContexts(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesFilterContexts(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityFilterContexts(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityFilterContexts(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiFilterContextPatchDocument} jsonApiFilterContextPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityFilterContexts(workspaceId, objectId, jsonApiFilterContextPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityFilterContexts(workspaceId, objectId, jsonApiFilterContextPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiFilterContextInDocument} jsonApiFilterContextInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityFilterContexts(workspaceId, objectId, jsonApiFilterContextInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityFilterContexts(workspaceId, objectId, jsonApiFilterContextInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ContextFiltersApi - factory interface
 * @export
 */
export const ContextFiltersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ContextFiltersApiFp(configuration);
    return {
        /**
         *
         * @summary Post Context Filters
         * @param {ContextFiltersApiCreateEntityFilterContextsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityFilterContexts(requestParameters, options) {
            return localVarFp
                .createEntityFilterContexts(requestParameters.workspaceId, requestParameters.jsonApiFilterContextPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Context Filter
         * @param {ContextFiltersApiDeleteEntityFilterContextsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityFilterContexts(requestParameters, options) {
            return localVarFp
                .deleteEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Context Filters
         * @param {ContextFiltersApiGetAllEntitiesFilterContextsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesFilterContexts(requestParameters, options) {
            return localVarFp
                .getAllEntitiesFilterContexts(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Context Filter
         * @param {ContextFiltersApiGetEntityFilterContextsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityFilterContexts(requestParameters, options) {
            return localVarFp
                .getEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Context Filter
         * @param {ContextFiltersApiPatchEntityFilterContextsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityFilterContexts(requestParameters, options) {
            return localVarFp
                .patchEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiFilterContextPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Context Filter
         * @param {ContextFiltersApiUpdateEntityFilterContextsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityFilterContexts(requestParameters, options) {
            return localVarFp
                .updateEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiFilterContextInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * ContextFiltersApi - object-oriented interface
 * @export
 * @class ContextFiltersApi
 * @extends {BaseAPI}
 */
export class ContextFiltersApi extends BaseAPI {
    /**
     *
     * @summary Post Context Filters
     * @param {ContextFiltersApiCreateEntityFilterContextsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextFiltersApi
     */
    createEntityFilterContexts(requestParameters, options) {
        return ContextFiltersApiFp(this.configuration)
            .createEntityFilterContexts(requestParameters.workspaceId, requestParameters.jsonApiFilterContextPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Context Filter
     * @param {ContextFiltersApiDeleteEntityFilterContextsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextFiltersApi
     */
    deleteEntityFilterContexts(requestParameters, options) {
        return ContextFiltersApiFp(this.configuration)
            .deleteEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Context Filters
     * @param {ContextFiltersApiGetAllEntitiesFilterContextsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextFiltersApi
     */
    getAllEntitiesFilterContexts(requestParameters, options) {
        return ContextFiltersApiFp(this.configuration)
            .getAllEntitiesFilterContexts(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Context Filter
     * @param {ContextFiltersApiGetEntityFilterContextsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextFiltersApi
     */
    getEntityFilterContexts(requestParameters, options) {
        return ContextFiltersApiFp(this.configuration)
            .getEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Context Filter
     * @param {ContextFiltersApiPatchEntityFilterContextsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextFiltersApi
     */
    patchEntityFilterContexts(requestParameters, options) {
        return ContextFiltersApiFp(this.configuration)
            .patchEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiFilterContextPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Context Filter
     * @param {ContextFiltersApiUpdateEntityFilterContextsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContextFiltersApi
     */
    updateEntityFilterContexts(requestParameters, options) {
        return ContextFiltersApiFp(this.configuration)
            .updateEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiFilterContextInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * CookieSecurityConfigurationApi - axios parameter creator
 * @export
 */
export const CookieSecurityConfigurationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get CookieSecurityConfiguration
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityCookieSecurityConfigurations: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityCookieSecurityConfigurations", "id", id);
            const localVarPath = `/api/v1/entities/admin/cookieSecurityConfigurations/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch CookieSecurityConfiguration
         * @param {string} id
         * @param {JsonApiCookieSecurityConfigurationPatchDocument} jsonApiCookieSecurityConfigurationPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityCookieSecurityConfigurations: async (id, jsonApiCookieSecurityConfigurationPatchDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityCookieSecurityConfigurations", "id", id);
            // verify required parameter 'jsonApiCookieSecurityConfigurationPatchDocument' is not null or undefined
            assertParamExists("patchEntityCookieSecurityConfigurations", "jsonApiCookieSecurityConfigurationPatchDocument", jsonApiCookieSecurityConfigurationPatchDocument);
            const localVarPath = `/api/v1/entities/admin/cookieSecurityConfigurations/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCookieSecurityConfigurationPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCookieSecurityConfigurationPatchDocument !== undefined
                    ? jsonApiCookieSecurityConfigurationPatchDocument
                    : {})
                : jsonApiCookieSecurityConfigurationPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put CookieSecurityConfiguration
         * @param {string} id
         * @param {JsonApiCookieSecurityConfigurationInDocument} jsonApiCookieSecurityConfigurationInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityCookieSecurityConfigurations: async (id, jsonApiCookieSecurityConfigurationInDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityCookieSecurityConfigurations", "id", id);
            // verify required parameter 'jsonApiCookieSecurityConfigurationInDocument' is not null or undefined
            assertParamExists("updateEntityCookieSecurityConfigurations", "jsonApiCookieSecurityConfigurationInDocument", jsonApiCookieSecurityConfigurationInDocument);
            const localVarPath = `/api/v1/entities/admin/cookieSecurityConfigurations/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCookieSecurityConfigurationInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCookieSecurityConfigurationInDocument !== undefined
                    ? jsonApiCookieSecurityConfigurationInDocument
                    : {})
                : jsonApiCookieSecurityConfigurationInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CookieSecurityConfigurationApi - functional programming interface
 * @export
 */
export const CookieSecurityConfigurationApiFp = function (configuration) {
    const localVarAxiosParamCreator = CookieSecurityConfigurationApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get CookieSecurityConfiguration
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityCookieSecurityConfigurations(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityCookieSecurityConfigurations(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch CookieSecurityConfiguration
         * @param {string} id
         * @param {JsonApiCookieSecurityConfigurationPatchDocument} jsonApiCookieSecurityConfigurationPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityCookieSecurityConfigurations(id, jsonApiCookieSecurityConfigurationPatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityCookieSecurityConfigurations(id, jsonApiCookieSecurityConfigurationPatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put CookieSecurityConfiguration
         * @param {string} id
         * @param {JsonApiCookieSecurityConfigurationInDocument} jsonApiCookieSecurityConfigurationInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityCookieSecurityConfigurations(id, jsonApiCookieSecurityConfigurationInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityCookieSecurityConfigurations(id, jsonApiCookieSecurityConfigurationInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * CookieSecurityConfigurationApi - factory interface
 * @export
 */
export const CookieSecurityConfigurationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = CookieSecurityConfigurationApiFp(configuration);
    return {
        /**
         *
         * @summary Get CookieSecurityConfiguration
         * @param {CookieSecurityConfigurationApiGetEntityCookieSecurityConfigurationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityCookieSecurityConfigurations(requestParameters, options) {
            return localVarFp
                .getEntityCookieSecurityConfigurations(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch CookieSecurityConfiguration
         * @param {CookieSecurityConfigurationApiPatchEntityCookieSecurityConfigurationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityCookieSecurityConfigurations(requestParameters, options) {
            return localVarFp
                .patchEntityCookieSecurityConfigurations(requestParameters.id, requestParameters.jsonApiCookieSecurityConfigurationPatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put CookieSecurityConfiguration
         * @param {CookieSecurityConfigurationApiUpdateEntityCookieSecurityConfigurationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityCookieSecurityConfigurations(requestParameters, options) {
            return localVarFp
                .updateEntityCookieSecurityConfigurations(requestParameters.id, requestParameters.jsonApiCookieSecurityConfigurationInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * CookieSecurityConfigurationApi - object-oriented interface
 * @export
 * @class CookieSecurityConfigurationApi
 * @extends {BaseAPI}
 */
export class CookieSecurityConfigurationApi extends BaseAPI {
    /**
     *
     * @summary Get CookieSecurityConfiguration
     * @param {CookieSecurityConfigurationApiGetEntityCookieSecurityConfigurationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CookieSecurityConfigurationApi
     */
    getEntityCookieSecurityConfigurations(requestParameters, options) {
        return CookieSecurityConfigurationApiFp(this.configuration)
            .getEntityCookieSecurityConfigurations(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch CookieSecurityConfiguration
     * @param {CookieSecurityConfigurationApiPatchEntityCookieSecurityConfigurationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CookieSecurityConfigurationApi
     */
    patchEntityCookieSecurityConfigurations(requestParameters, options) {
        return CookieSecurityConfigurationApiFp(this.configuration)
            .patchEntityCookieSecurityConfigurations(requestParameters.id, requestParameters.jsonApiCookieSecurityConfigurationPatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put CookieSecurityConfiguration
     * @param {CookieSecurityConfigurationApiUpdateEntityCookieSecurityConfigurationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CookieSecurityConfigurationApi
     */
    updateEntityCookieSecurityConfigurations(requestParameters, options) {
        return CookieSecurityConfigurationApiFp(this.configuration)
            .updateEntityCookieSecurityConfigurations(requestParameters.id, requestParameters.jsonApiCookieSecurityConfigurationInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DashboardsApi - axios parameter creator
 * @export
 */
export const DashboardsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Post Dashboards
         * @param {string} workspaceId
         * @param {JsonApiAnalyticalDashboardPostOptionalIdDocument} jsonApiAnalyticalDashboardPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'permissions' | 'origin' | 'accessInfo' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityAnalyticalDashboards: async (workspaceId, jsonApiAnalyticalDashboardPostOptionalIdDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityAnalyticalDashboards", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiAnalyticalDashboardPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityAnalyticalDashboards", "jsonApiAnalyticalDashboardPostOptionalIdDocument", jsonApiAnalyticalDashboardPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/analyticalDashboards`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiAnalyticalDashboardPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiAnalyticalDashboardPostOptionalIdDocument !== undefined
                    ? jsonApiAnalyticalDashboardPostOptionalIdDocument
                    : {})
                : jsonApiAnalyticalDashboardPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Dashboard
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityAnalyticalDashboards: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityAnalyticalDashboards", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityAnalyticalDashboards", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/analyticalDashboards/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Dashboards
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'permissions' | 'origin' | 'accessInfo' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAnalyticalDashboards: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesAnalyticalDashboards", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/analyticalDashboards`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Dashboard
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'permissions' | 'origin' | 'accessInfo' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAnalyticalDashboards: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityAnalyticalDashboards", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityAnalyticalDashboards", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/analyticalDashboards/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Dashboard
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAnalyticalDashboardPatchDocument} jsonApiAnalyticalDashboardPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityAnalyticalDashboards: async (workspaceId, objectId, jsonApiAnalyticalDashboardPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityAnalyticalDashboards", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityAnalyticalDashboards", "objectId", objectId);
            // verify required parameter 'jsonApiAnalyticalDashboardPatchDocument' is not null or undefined
            assertParamExists("patchEntityAnalyticalDashboards", "jsonApiAnalyticalDashboardPatchDocument", jsonApiAnalyticalDashboardPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/analyticalDashboards/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiAnalyticalDashboardPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiAnalyticalDashboardPatchDocument !== undefined
                    ? jsonApiAnalyticalDashboardPatchDocument
                    : {})
                : jsonApiAnalyticalDashboardPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put Dashboards
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAnalyticalDashboardInDocument} jsonApiAnalyticalDashboardInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityAnalyticalDashboards: async (workspaceId, objectId, jsonApiAnalyticalDashboardInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityAnalyticalDashboards", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityAnalyticalDashboards", "objectId", objectId);
            // verify required parameter 'jsonApiAnalyticalDashboardInDocument' is not null or undefined
            assertParamExists("updateEntityAnalyticalDashboards", "jsonApiAnalyticalDashboardInDocument", jsonApiAnalyticalDashboardInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/analyticalDashboards/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiAnalyticalDashboardInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiAnalyticalDashboardInDocument !== undefined
                    ? jsonApiAnalyticalDashboardInDocument
                    : {})
                : jsonApiAnalyticalDashboardInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DashboardsApi - functional programming interface
 * @export
 */
export const DashboardsApiFp = function (configuration) {
    const localVarAxiosParamCreator = DashboardsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Post Dashboards
         * @param {string} workspaceId
         * @param {JsonApiAnalyticalDashboardPostOptionalIdDocument} jsonApiAnalyticalDashboardPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'permissions' | 'origin' | 'accessInfo' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityAnalyticalDashboards(workspaceId, jsonApiAnalyticalDashboardPostOptionalIdDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityAnalyticalDashboards(workspaceId, jsonApiAnalyticalDashboardPostOptionalIdDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Dashboard
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityAnalyticalDashboards(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityAnalyticalDashboards(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Dashboards
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'permissions' | 'origin' | 'accessInfo' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesAnalyticalDashboards(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesAnalyticalDashboards(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Dashboard
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'permissions' | 'origin' | 'accessInfo' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityAnalyticalDashboards(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityAnalyticalDashboards(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Dashboard
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAnalyticalDashboardPatchDocument} jsonApiAnalyticalDashboardPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityAnalyticalDashboards(workspaceId, objectId, jsonApiAnalyticalDashboardPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityAnalyticalDashboards(workspaceId, objectId, jsonApiAnalyticalDashboardPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put Dashboards
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAnalyticalDashboardInDocument} jsonApiAnalyticalDashboardInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityAnalyticalDashboards(workspaceId, objectId, jsonApiAnalyticalDashboardInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityAnalyticalDashboards(workspaceId, objectId, jsonApiAnalyticalDashboardInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * DashboardsApi - factory interface
 * @export
 */
export const DashboardsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DashboardsApiFp(configuration);
    return {
        /**
         *
         * @summary Post Dashboards
         * @param {DashboardsApiCreateEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityAnalyticalDashboards(requestParameters, options) {
            return localVarFp
                .createEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.jsonApiAnalyticalDashboardPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Dashboard
         * @param {DashboardsApiDeleteEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityAnalyticalDashboards(requestParameters, options) {
            return localVarFp
                .deleteEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Dashboards
         * @param {DashboardsApiGetAllEntitiesAnalyticalDashboardsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAnalyticalDashboards(requestParameters, options) {
            return localVarFp
                .getAllEntitiesAnalyticalDashboards(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Dashboard
         * @param {DashboardsApiGetEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAnalyticalDashboards(requestParameters, options) {
            return localVarFp
                .getEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Dashboard
         * @param {DashboardsApiPatchEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityAnalyticalDashboards(requestParameters, options) {
            return localVarFp
                .patchEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAnalyticalDashboardPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put Dashboards
         * @param {DashboardsApiUpdateEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityAnalyticalDashboards(requestParameters, options) {
            return localVarFp
                .updateEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAnalyticalDashboardInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * DashboardsApi - object-oriented interface
 * @export
 * @class DashboardsApi
 * @extends {BaseAPI}
 */
export class DashboardsApi extends BaseAPI {
    /**
     *
     * @summary Post Dashboards
     * @param {DashboardsApiCreateEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    createEntityAnalyticalDashboards(requestParameters, options) {
        return DashboardsApiFp(this.configuration)
            .createEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.jsonApiAnalyticalDashboardPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Dashboard
     * @param {DashboardsApiDeleteEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    deleteEntityAnalyticalDashboards(requestParameters, options) {
        return DashboardsApiFp(this.configuration)
            .deleteEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Dashboards
     * @param {DashboardsApiGetAllEntitiesAnalyticalDashboardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    getAllEntitiesAnalyticalDashboards(requestParameters, options) {
        return DashboardsApiFp(this.configuration)
            .getAllEntitiesAnalyticalDashboards(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Dashboard
     * @param {DashboardsApiGetEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    getEntityAnalyticalDashboards(requestParameters, options) {
        return DashboardsApiFp(this.configuration)
            .getEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Dashboard
     * @param {DashboardsApiPatchEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    patchEntityAnalyticalDashboards(requestParameters, options) {
        return DashboardsApiFp(this.configuration)
            .patchEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAnalyticalDashboardPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put Dashboards
     * @param {DashboardsApiUpdateEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    updateEntityAnalyticalDashboards(requestParameters, options) {
        return DashboardsApiFp(this.configuration)
            .updateEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAnalyticalDashboardInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DataFiltersApi - axios parameter creator
 * @export
 */
export const DataFiltersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Post User Data Filters
         * @param {string} workspaceId
         * @param {JsonApiUserDataFilterPostOptionalIdDocument} jsonApiUserDataFilterPostOptionalIdDocument
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUserDataFilters: async (workspaceId, jsonApiUserDataFilterPostOptionalIdDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityUserDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiUserDataFilterPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityUserDataFilters", "jsonApiUserDataFilterPostOptionalIdDocument", jsonApiUserDataFilterPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/userDataFilters`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserDataFilterPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserDataFilterPostOptionalIdDocument !== undefined
                    ? jsonApiUserDataFilterPostOptionalIdDocument
                    : {})
                : jsonApiUserDataFilterPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Settings for Workspace Data Filters
         * @param {string} workspaceId
         * @param {JsonApiWorkspaceDataFilterSettingInDocument} jsonApiWorkspaceDataFilterSettingInDocument
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaceDataFilterSettings: async (workspaceId, jsonApiWorkspaceDataFilterSettingInDocument, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityWorkspaceDataFilterSettings", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiWorkspaceDataFilterSettingInDocument' is not null or undefined
            assertParamExists("createEntityWorkspaceDataFilterSettings", "jsonApiWorkspaceDataFilterSettingInDocument", jsonApiWorkspaceDataFilterSettingInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilterSettings`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceDataFilterSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceDataFilterSettingInDocument !== undefined
                    ? jsonApiWorkspaceDataFilterSettingInDocument
                    : {})
                : jsonApiWorkspaceDataFilterSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Workspace Data Filters
         * @param {string} workspaceId
         * @param {JsonApiWorkspaceDataFilterInDocument} jsonApiWorkspaceDataFilterInDocument
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaceDataFilters: async (workspaceId, jsonApiWorkspaceDataFilterInDocument, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityWorkspaceDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiWorkspaceDataFilterInDocument' is not null or undefined
            assertParamExists("createEntityWorkspaceDataFilters", "jsonApiWorkspaceDataFilterInDocument", jsonApiWorkspaceDataFilterInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilters`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceDataFilterInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceDataFilterInDocument !== undefined
                    ? jsonApiWorkspaceDataFilterInDocument
                    : {})
                : jsonApiWorkspaceDataFilterInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUserDataFilters: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityUserDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityUserDataFilters", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/userDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Settings for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaceDataFilterSettings: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityWorkspaceDataFilterSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityWorkspaceDataFilterSettings", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilterSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaceDataFilters: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityWorkspaceDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityWorkspaceDataFilters", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all User Data Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserDataFilters: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesUserDataFilters", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/userDataFilters`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Settings for Workspace Data Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceDataFilterSettings: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesWorkspaceDataFilterSettings", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilterSettings`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Workspace Data Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceDataFilters: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesWorkspaceDataFilters", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilters`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserDataFilters: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityUserDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityUserDataFilters", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/userDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Setting for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceDataFilterSettings: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityWorkspaceDataFilterSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityWorkspaceDataFilterSettings", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilterSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceDataFilters: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityWorkspaceDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityWorkspaceDataFilters", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all workspaces and related workspace data filters (and their settings / values).
         * @summary Get workspace data filters for all workspaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceDataFiltersLayout: async (options = {}) => {
            const localVarPath = `/api/v1/layout/workspaceDataFilters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiUserDataFilterPatchDocument} jsonApiUserDataFilterPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUserDataFilters: async (workspaceId, objectId, jsonApiUserDataFilterPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityUserDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityUserDataFilters", "objectId", objectId);
            // verify required parameter 'jsonApiUserDataFilterPatchDocument' is not null or undefined
            assertParamExists("patchEntityUserDataFilters", "jsonApiUserDataFilterPatchDocument", jsonApiUserDataFilterPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/userDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserDataFilterPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserDataFilterPatchDocument !== undefined
                    ? jsonApiUserDataFilterPatchDocument
                    : {})
                : jsonApiUserDataFilterPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Settings for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterSettingPatchDocument} jsonApiWorkspaceDataFilterSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaceDataFilterSettings: async (workspaceId, objectId, jsonApiWorkspaceDataFilterSettingPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityWorkspaceDataFilterSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityWorkspaceDataFilterSettings", "objectId", objectId);
            // verify required parameter 'jsonApiWorkspaceDataFilterSettingPatchDocument' is not null or undefined
            assertParamExists("patchEntityWorkspaceDataFilterSettings", "jsonApiWorkspaceDataFilterSettingPatchDocument", jsonApiWorkspaceDataFilterSettingPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilterSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceDataFilterSettingPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceDataFilterSettingPatchDocument !== undefined
                    ? jsonApiWorkspaceDataFilterSettingPatchDocument
                    : {})
                : jsonApiWorkspaceDataFilterSettingPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterPatchDocument} jsonApiWorkspaceDataFilterPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaceDataFilters: async (workspaceId, objectId, jsonApiWorkspaceDataFilterPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityWorkspaceDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityWorkspaceDataFilters", "objectId", objectId);
            // verify required parameter 'jsonApiWorkspaceDataFilterPatchDocument' is not null or undefined
            assertParamExists("patchEntityWorkspaceDataFilters", "jsonApiWorkspaceDataFilterPatchDocument", jsonApiWorkspaceDataFilterPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceDataFilterPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceDataFilterPatchDocument !== undefined
                    ? jsonApiWorkspaceDataFilterPatchDocument
                    : {})
                : jsonApiWorkspaceDataFilterPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets workspace data filters in all workspaces in entire organization.
         * @summary Set all workspace data filters
         * @param {DeclarativeWorkspaceDataFilters} declarativeWorkspaceDataFilters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspaceDataFiltersLayout: async (declarativeWorkspaceDataFilters, options = {}) => {
            // verify required parameter 'declarativeWorkspaceDataFilters' is not null or undefined
            assertParamExists("setWorkspaceDataFiltersLayout", "declarativeWorkspaceDataFilters", declarativeWorkspaceDataFilters);
            const localVarPath = `/api/v1/layout/workspaceDataFilters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeWorkspaceDataFilters !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeWorkspaceDataFilters !== undefined ? declarativeWorkspaceDataFilters : {})
                : declarativeWorkspaceDataFilters || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiUserDataFilterInDocument} jsonApiUserDataFilterInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUserDataFilters: async (workspaceId, objectId, jsonApiUserDataFilterInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityUserDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityUserDataFilters", "objectId", objectId);
            // verify required parameter 'jsonApiUserDataFilterInDocument' is not null or undefined
            assertParamExists("updateEntityUserDataFilters", "jsonApiUserDataFilterInDocument", jsonApiUserDataFilterInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/userDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserDataFilterInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserDataFilterInDocument !== undefined ? jsonApiUserDataFilterInDocument : {})
                : jsonApiUserDataFilterInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Settings for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterSettingInDocument} jsonApiWorkspaceDataFilterSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaceDataFilterSettings: async (workspaceId, objectId, jsonApiWorkspaceDataFilterSettingInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityWorkspaceDataFilterSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityWorkspaceDataFilterSettings", "objectId", objectId);
            // verify required parameter 'jsonApiWorkspaceDataFilterSettingInDocument' is not null or undefined
            assertParamExists("updateEntityWorkspaceDataFilterSettings", "jsonApiWorkspaceDataFilterSettingInDocument", jsonApiWorkspaceDataFilterSettingInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilterSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceDataFilterSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceDataFilterSettingInDocument !== undefined
                    ? jsonApiWorkspaceDataFilterSettingInDocument
                    : {})
                : jsonApiWorkspaceDataFilterSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterInDocument} jsonApiWorkspaceDataFilterInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaceDataFilters: async (workspaceId, objectId, jsonApiWorkspaceDataFilterInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityWorkspaceDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityWorkspaceDataFilters", "objectId", objectId);
            // verify required parameter 'jsonApiWorkspaceDataFilterInDocument' is not null or undefined
            assertParamExists("updateEntityWorkspaceDataFilters", "jsonApiWorkspaceDataFilterInDocument", jsonApiWorkspaceDataFilterInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceDataFilterInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceDataFilterInDocument !== undefined
                    ? jsonApiWorkspaceDataFilterInDocument
                    : {})
                : jsonApiWorkspaceDataFilterInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DataFiltersApi - functional programming interface
 * @export
 */
export const DataFiltersApiFp = function (configuration) {
    const localVarAxiosParamCreator = DataFiltersApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Post User Data Filters
         * @param {string} workspaceId
         * @param {JsonApiUserDataFilterPostOptionalIdDocument} jsonApiUserDataFilterPostOptionalIdDocument
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityUserDataFilters(workspaceId, jsonApiUserDataFilterPostOptionalIdDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityUserDataFilters(workspaceId, jsonApiUserDataFilterPostOptionalIdDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Settings for Workspace Data Filters
         * @param {string} workspaceId
         * @param {JsonApiWorkspaceDataFilterSettingInDocument} jsonApiWorkspaceDataFilterSettingInDocument
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityWorkspaceDataFilterSettings(workspaceId, jsonApiWorkspaceDataFilterSettingInDocument, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityWorkspaceDataFilterSettings(workspaceId, jsonApiWorkspaceDataFilterSettingInDocument, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Workspace Data Filters
         * @param {string} workspaceId
         * @param {JsonApiWorkspaceDataFilterInDocument} jsonApiWorkspaceDataFilterInDocument
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityWorkspaceDataFilters(workspaceId, jsonApiWorkspaceDataFilterInDocument, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityWorkspaceDataFilters(workspaceId, jsonApiWorkspaceDataFilterInDocument, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityUserDataFilters(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityUserDataFilters(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Settings for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityWorkspaceDataFilterSettings(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityWorkspaceDataFilterSettings(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityWorkspaceDataFilters(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityWorkspaceDataFilters(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all User Data Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesUserDataFilters(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesUserDataFilters(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Settings for Workspace Data Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesWorkspaceDataFilterSettings(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesWorkspaceDataFilterSettings(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Workspace Data Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesWorkspaceDataFilters(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesWorkspaceDataFilters(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityUserDataFilters(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityUserDataFilters(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Setting for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityWorkspaceDataFilterSettings(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityWorkspaceDataFilterSettings(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityWorkspaceDataFilters(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityWorkspaceDataFilters(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all workspaces and related workspace data filters (and their settings / values).
         * @summary Get workspace data filters for all workspaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceDataFiltersLayout(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceDataFiltersLayout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiUserDataFilterPatchDocument} jsonApiUserDataFilterPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityUserDataFilters(workspaceId, objectId, jsonApiUserDataFilterPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityUserDataFilters(workspaceId, objectId, jsonApiUserDataFilterPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Settings for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterSettingPatchDocument} jsonApiWorkspaceDataFilterSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityWorkspaceDataFilterSettings(workspaceId, objectId, jsonApiWorkspaceDataFilterSettingPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityWorkspaceDataFilterSettings(workspaceId, objectId, jsonApiWorkspaceDataFilterSettingPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterPatchDocument} jsonApiWorkspaceDataFilterPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityWorkspaceDataFilters(workspaceId, objectId, jsonApiWorkspaceDataFilterPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityWorkspaceDataFilters(workspaceId, objectId, jsonApiWorkspaceDataFilterPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets workspace data filters in all workspaces in entire organization.
         * @summary Set all workspace data filters
         * @param {DeclarativeWorkspaceDataFilters} declarativeWorkspaceDataFilters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setWorkspaceDataFiltersLayout(declarativeWorkspaceDataFilters, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setWorkspaceDataFiltersLayout(declarativeWorkspaceDataFilters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiUserDataFilterInDocument} jsonApiUserDataFilterInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityUserDataFilters(workspaceId, objectId, jsonApiUserDataFilterInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityUserDataFilters(workspaceId, objectId, jsonApiUserDataFilterInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Settings for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterSettingInDocument} jsonApiWorkspaceDataFilterSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityWorkspaceDataFilterSettings(workspaceId, objectId, jsonApiWorkspaceDataFilterSettingInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityWorkspaceDataFilterSettings(workspaceId, objectId, jsonApiWorkspaceDataFilterSettingInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterInDocument} jsonApiWorkspaceDataFilterInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityWorkspaceDataFilters(workspaceId, objectId, jsonApiWorkspaceDataFilterInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityWorkspaceDataFilters(workspaceId, objectId, jsonApiWorkspaceDataFilterInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * DataFiltersApi - factory interface
 * @export
 */
export const DataFiltersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DataFiltersApiFp(configuration);
    return {
        /**
         *
         * @summary Post User Data Filters
         * @param {DataFiltersApiCreateEntityUserDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUserDataFilters(requestParameters, options) {
            return localVarFp
                .createEntityUserDataFilters(requestParameters.workspaceId, requestParameters.jsonApiUserDataFilterPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Settings for Workspace Data Filters
         * @param {DataFiltersApiCreateEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaceDataFilterSettings(requestParameters, options) {
            return localVarFp
                .createEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.jsonApiWorkspaceDataFilterSettingInDocument, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Workspace Data Filters
         * @param {DataFiltersApiCreateEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaceDataFilters(requestParameters, options) {
            return localVarFp
                .createEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.jsonApiWorkspaceDataFilterInDocument, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a User Data Filter
         * @param {DataFiltersApiDeleteEntityUserDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUserDataFilters(requestParameters, options) {
            return localVarFp
                .deleteEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Settings for Workspace Data Filter
         * @param {DataFiltersApiDeleteEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaceDataFilterSettings(requestParameters, options) {
            return localVarFp
                .deleteEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Workspace Data Filter
         * @param {DataFiltersApiDeleteEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaceDataFilters(requestParameters, options) {
            return localVarFp
                .deleteEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all User Data Filters
         * @param {DataFiltersApiGetAllEntitiesUserDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserDataFilters(requestParameters, options) {
            return localVarFp
                .getAllEntitiesUserDataFilters(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Settings for Workspace Data Filters
         * @param {DataFiltersApiGetAllEntitiesWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceDataFilterSettings(requestParameters, options) {
            return localVarFp
                .getAllEntitiesWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Workspace Data Filters
         * @param {DataFiltersApiGetAllEntitiesWorkspaceDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceDataFilters(requestParameters, options) {
            return localVarFp
                .getAllEntitiesWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a User Data Filter
         * @param {DataFiltersApiGetEntityUserDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserDataFilters(requestParameters, options) {
            return localVarFp
                .getEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Setting for Workspace Data Filter
         * @param {DataFiltersApiGetEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceDataFilterSettings(requestParameters, options) {
            return localVarFp
                .getEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Workspace Data Filter
         * @param {DataFiltersApiGetEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceDataFilters(requestParameters, options) {
            return localVarFp
                .getEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all workspaces and related workspace data filters (and their settings / values).
         * @summary Get workspace data filters for all workspaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceDataFiltersLayout(options) {
            return localVarFp
                .getWorkspaceDataFiltersLayout(options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a User Data Filter
         * @param {DataFiltersApiPatchEntityUserDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUserDataFilters(requestParameters, options) {
            return localVarFp
                .patchEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiUserDataFilterPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Settings for Workspace Data Filter
         * @param {DataFiltersApiPatchEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaceDataFilterSettings(requestParameters, options) {
            return localVarFp
                .patchEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterSettingPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Workspace Data Filter
         * @param {DataFiltersApiPatchEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaceDataFilters(requestParameters, options) {
            return localVarFp
                .patchEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Sets workspace data filters in all workspaces in entire organization.
         * @summary Set all workspace data filters
         * @param {DataFiltersApiSetWorkspaceDataFiltersLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspaceDataFiltersLayout(requestParameters, options) {
            return localVarFp
                .setWorkspaceDataFiltersLayout(requestParameters.declarativeWorkspaceDataFilters, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a User Data Filter
         * @param {DataFiltersApiUpdateEntityUserDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUserDataFilters(requestParameters, options) {
            return localVarFp
                .updateEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiUserDataFilterInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Settings for Workspace Data Filter
         * @param {DataFiltersApiUpdateEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaceDataFilterSettings(requestParameters, options) {
            return localVarFp
                .updateEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterSettingInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Workspace Data Filter
         * @param {DataFiltersApiUpdateEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaceDataFilters(requestParameters, options) {
            return localVarFp
                .updateEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * DataFiltersApi - object-oriented interface
 * @export
 * @class DataFiltersApi
 * @extends {BaseAPI}
 */
export class DataFiltersApi extends BaseAPI {
    /**
     *
     * @summary Post User Data Filters
     * @param {DataFiltersApiCreateEntityUserDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataFiltersApi
     */
    createEntityUserDataFilters(requestParameters, options) {
        return DataFiltersApiFp(this.configuration)
            .createEntityUserDataFilters(requestParameters.workspaceId, requestParameters.jsonApiUserDataFilterPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Settings for Workspace Data Filters
     * @param {DataFiltersApiCreateEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataFiltersApi
     */
    createEntityWorkspaceDataFilterSettings(requestParameters, options) {
        return DataFiltersApiFp(this.configuration)
            .createEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.jsonApiWorkspaceDataFilterSettingInDocument, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Workspace Data Filters
     * @param {DataFiltersApiCreateEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataFiltersApi
     */
    createEntityWorkspaceDataFilters(requestParameters, options) {
        return DataFiltersApiFp(this.configuration)
            .createEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.jsonApiWorkspaceDataFilterInDocument, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a User Data Filter
     * @param {DataFiltersApiDeleteEntityUserDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataFiltersApi
     */
    deleteEntityUserDataFilters(requestParameters, options) {
        return DataFiltersApiFp(this.configuration)
            .deleteEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Settings for Workspace Data Filter
     * @param {DataFiltersApiDeleteEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataFiltersApi
     */
    deleteEntityWorkspaceDataFilterSettings(requestParameters, options) {
        return DataFiltersApiFp(this.configuration)
            .deleteEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Workspace Data Filter
     * @param {DataFiltersApiDeleteEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataFiltersApi
     */
    deleteEntityWorkspaceDataFilters(requestParameters, options) {
        return DataFiltersApiFp(this.configuration)
            .deleteEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all User Data Filters
     * @param {DataFiltersApiGetAllEntitiesUserDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataFiltersApi
     */
    getAllEntitiesUserDataFilters(requestParameters, options) {
        return DataFiltersApiFp(this.configuration)
            .getAllEntitiesUserDataFilters(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Settings for Workspace Data Filters
     * @param {DataFiltersApiGetAllEntitiesWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataFiltersApi
     */
    getAllEntitiesWorkspaceDataFilterSettings(requestParameters, options) {
        return DataFiltersApiFp(this.configuration)
            .getAllEntitiesWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Workspace Data Filters
     * @param {DataFiltersApiGetAllEntitiesWorkspaceDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataFiltersApi
     */
    getAllEntitiesWorkspaceDataFilters(requestParameters, options) {
        return DataFiltersApiFp(this.configuration)
            .getAllEntitiesWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a User Data Filter
     * @param {DataFiltersApiGetEntityUserDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataFiltersApi
     */
    getEntityUserDataFilters(requestParameters, options) {
        return DataFiltersApiFp(this.configuration)
            .getEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Setting for Workspace Data Filter
     * @param {DataFiltersApiGetEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataFiltersApi
     */
    getEntityWorkspaceDataFilterSettings(requestParameters, options) {
        return DataFiltersApiFp(this.configuration)
            .getEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Workspace Data Filter
     * @param {DataFiltersApiGetEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataFiltersApi
     */
    getEntityWorkspaceDataFilters(requestParameters, options) {
        return DataFiltersApiFp(this.configuration)
            .getEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve all workspaces and related workspace data filters (and their settings / values).
     * @summary Get workspace data filters for all workspaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataFiltersApi
     */
    getWorkspaceDataFiltersLayout(options) {
        return DataFiltersApiFp(this.configuration)
            .getWorkspaceDataFiltersLayout(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a User Data Filter
     * @param {DataFiltersApiPatchEntityUserDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataFiltersApi
     */
    patchEntityUserDataFilters(requestParameters, options) {
        return DataFiltersApiFp(this.configuration)
            .patchEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiUserDataFilterPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Settings for Workspace Data Filter
     * @param {DataFiltersApiPatchEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataFiltersApi
     */
    patchEntityWorkspaceDataFilterSettings(requestParameters, options) {
        return DataFiltersApiFp(this.configuration)
            .patchEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterSettingPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Workspace Data Filter
     * @param {DataFiltersApiPatchEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataFiltersApi
     */
    patchEntityWorkspaceDataFilters(requestParameters, options) {
        return DataFiltersApiFp(this.configuration)
            .patchEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets workspace data filters in all workspaces in entire organization.
     * @summary Set all workspace data filters
     * @param {DataFiltersApiSetWorkspaceDataFiltersLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataFiltersApi
     */
    setWorkspaceDataFiltersLayout(requestParameters, options) {
        return DataFiltersApiFp(this.configuration)
            .setWorkspaceDataFiltersLayout(requestParameters.declarativeWorkspaceDataFilters, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a User Data Filter
     * @param {DataFiltersApiUpdateEntityUserDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataFiltersApi
     */
    updateEntityUserDataFilters(requestParameters, options) {
        return DataFiltersApiFp(this.configuration)
            .updateEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiUserDataFilterInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Settings for Workspace Data Filter
     * @param {DataFiltersApiUpdateEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataFiltersApi
     */
    updateEntityWorkspaceDataFilterSettings(requestParameters, options) {
        return DataFiltersApiFp(this.configuration)
            .updateEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterSettingInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Workspace Data Filter
     * @param {DataFiltersApiUpdateEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataFiltersApi
     */
    updateEntityWorkspaceDataFilters(requestParameters, options) {
        return DataFiltersApiFp(this.configuration)
            .updateEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DataSourceDeclarativeAPIsApi - axios parameter creator
 * @export
 */
export const DataSourceDeclarativeAPIsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve all data sources including related physical model.
         * @summary Get all data sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourcesLayout: async (options = {}) => {
            const localVarPath = `/api/v1/layout/dataSources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set all data sources including related physical model.
         * @summary Put all data sources
         * @param {DeclarativeDataSources} declarativeDataSources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDataSourcesLayout: async (declarativeDataSources, options = {}) => {
            // verify required parameter 'declarativeDataSources' is not null or undefined
            assertParamExists("putDataSourcesLayout", "declarativeDataSources", declarativeDataSources);
            const localVarPath = `/api/v1/layout/dataSources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeDataSources !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeDataSources !== undefined ? declarativeDataSources : {})
                : declarativeDataSources || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DataSourceDeclarativeAPIsApi - functional programming interface
 * @export
 */
export const DataSourceDeclarativeAPIsApiFp = function (configuration) {
    const localVarAxiosParamCreator = DataSourceDeclarativeAPIsApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieve all data sources including related physical model.
         * @summary Get all data sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataSourcesLayout(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataSourcesLayout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set all data sources including related physical model.
         * @summary Put all data sources
         * @param {DeclarativeDataSources} declarativeDataSources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putDataSourcesLayout(declarativeDataSources, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putDataSourcesLayout(declarativeDataSources, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * DataSourceDeclarativeAPIsApi - factory interface
 * @export
 */
export const DataSourceDeclarativeAPIsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DataSourceDeclarativeAPIsApiFp(configuration);
    return {
        /**
         * Retrieve all data sources including related physical model.
         * @summary Get all data sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourcesLayout(options) {
            return localVarFp.getDataSourcesLayout(options).then((request) => request(axios, basePath));
        },
        /**
         * Set all data sources including related physical model.
         * @summary Put all data sources
         * @param {DataSourceDeclarativeAPIsApiPutDataSourcesLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDataSourcesLayout(requestParameters, options) {
            return localVarFp
                .putDataSourcesLayout(requestParameters.declarativeDataSources, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * DataSourceDeclarativeAPIsApi - object-oriented interface
 * @export
 * @class DataSourceDeclarativeAPIsApi
 * @extends {BaseAPI}
 */
export class DataSourceDeclarativeAPIsApi extends BaseAPI {
    /**
     * Retrieve all data sources including related physical model.
     * @summary Get all data sources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceDeclarativeAPIsApi
     */
    getDataSourcesLayout(options) {
        return DataSourceDeclarativeAPIsApiFp(this.configuration)
            .getDataSourcesLayout(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Set all data sources including related physical model.
     * @summary Put all data sources
     * @param {DataSourceDeclarativeAPIsApiPutDataSourcesLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceDeclarativeAPIsApi
     */
    putDataSourcesLayout(requestParameters, options) {
        return DataSourceDeclarativeAPIsApiFp(this.configuration)
            .putDataSourcesLayout(requestParameters.declarativeDataSources, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DataSourceEntitiesControllerApi - axios parameter creator
 * @export
 */
export const DataSourceEntitiesControllerApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {string} dataSourceId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSourceTables: async (dataSourceId, filter, page, size, sort, options = {}) => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("getAllEntitiesDataSourceTables", "dataSourceId", dataSourceId);
            const localVarPath = `/api/v1/entities/dataSources/{dataSourceId}/dataSourceTables`.replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} dataSourceId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSourceTables: async (dataSourceId, id, filter, options = {}) => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("getEntityDataSourceTables", "dataSourceId", dataSourceId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityDataSourceTables", "id", id);
            const localVarPath = `/api/v1/entities/dataSources/{dataSourceId}/dataSourceTables/{id}`
                .replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DataSourceEntitiesControllerApi - functional programming interface
 * @export
 */
export const DataSourceEntitiesControllerApiFp = function (configuration) {
    const localVarAxiosParamCreator = DataSourceEntitiesControllerApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @param {string} dataSourceId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesDataSourceTables(dataSourceId, filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesDataSourceTables(dataSourceId, filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} dataSourceId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityDataSourceTables(dataSourceId, id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityDataSourceTables(dataSourceId, id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * DataSourceEntitiesControllerApi - factory interface
 * @export
 */
export const DataSourceEntitiesControllerApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DataSourceEntitiesControllerApiFp(configuration);
    return {
        /**
         *
         * @param {DataSourceEntitiesControllerApiGetAllEntitiesDataSourceTablesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSourceTables(requestParameters, options) {
            return localVarFp
                .getAllEntitiesDataSourceTables(requestParameters.dataSourceId, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {DataSourceEntitiesControllerApiGetEntityDataSourceTablesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSourceTables(requestParameters, options) {
            return localVarFp
                .getEntityDataSourceTables(requestParameters.dataSourceId, requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * DataSourceEntitiesControllerApi - object-oriented interface
 * @export
 * @class DataSourceEntitiesControllerApi
 * @extends {BaseAPI}
 */
export class DataSourceEntitiesControllerApi extends BaseAPI {
    /**
     *
     * @param {DataSourceEntitiesControllerApiGetAllEntitiesDataSourceTablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceEntitiesControllerApi
     */
    getAllEntitiesDataSourceTables(requestParameters, options) {
        return DataSourceEntitiesControllerApiFp(this.configuration)
            .getAllEntitiesDataSourceTables(requestParameters.dataSourceId, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {DataSourceEntitiesControllerApiGetEntityDataSourceTablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceEntitiesControllerApi
     */
    getEntityDataSourceTables(requestParameters, options) {
        return DataSourceEntitiesControllerApiFp(this.configuration)
            .getEntityDataSourceTables(requestParameters.dataSourceId, requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DataSourceEntityAPIsApi - axios parameter creator
 * @export
 */
export const DataSourceEntityAPIsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Data Source - represents data source for the workspace
         * @summary Post Data Sources
         * @param {JsonApiDataSourceInDocument} jsonApiDataSourceInDocument
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityDataSources: async (jsonApiDataSourceInDocument, metaInclude, options = {}) => {
            // verify required parameter 'jsonApiDataSourceInDocument' is not null or undefined
            assertParamExists("createEntityDataSources", "jsonApiDataSourceInDocument", jsonApiDataSourceInDocument);
            const localVarPath = `/api/v1/entities/dataSources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiDataSourceInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiDataSourceInDocument !== undefined ? jsonApiDataSourceInDocument : {})
                : jsonApiDataSourceInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Delete Data Source entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityDataSources: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityDataSources", "id", id);
            const localVarPath = `/api/v1/entities/dataSources/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Data Source Identifiers
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSourceIdentifiers: async (filter, page, size, sort, metaInclude, options = {}) => {
            const localVarPath = `/api/v1/entities/dataSourceIdentifiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} dataSourceId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSourceTables: async (dataSourceId, filter, page, size, sort, options = {}) => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("getAllEntitiesDataSourceTables", "dataSourceId", dataSourceId);
            const localVarPath = `/api/v1/entities/dataSources/{dataSourceId}/dataSourceTables`.replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Get Data Source entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSources: async (filter, page, size, sort, metaInclude, options = {}) => {
            const localVarPath = `/api/v1/entities/dataSources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Data Source Identifier
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSourceIdentifiers: async (id, filter, metaInclude, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityDataSourceIdentifiers", "id", id);
            const localVarPath = `/api/v1/entities/dataSourceIdentifiers/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} dataSourceId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSourceTables: async (dataSourceId, id, filter, options = {}) => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("getEntityDataSourceTables", "dataSourceId", dataSourceId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityDataSourceTables", "id", id);
            const localVarPath = `/api/v1/entities/dataSources/{dataSourceId}/dataSourceTables/{id}`
                .replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Get Data Source entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSources: async (id, filter, metaInclude, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityDataSources", "id", id);
            const localVarPath = `/api/v1/entities/dataSources/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Patch Data Source entity
         * @param {string} id
         * @param {JsonApiDataSourcePatchDocument} jsonApiDataSourcePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityDataSources: async (id, jsonApiDataSourcePatchDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityDataSources", "id", id);
            // verify required parameter 'jsonApiDataSourcePatchDocument' is not null or undefined
            assertParamExists("patchEntityDataSources", "jsonApiDataSourcePatchDocument", jsonApiDataSourcePatchDocument);
            const localVarPath = `/api/v1/entities/dataSources/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiDataSourcePatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiDataSourcePatchDocument !== undefined ? jsonApiDataSourcePatchDocument : {})
                : jsonApiDataSourcePatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Put Data Source entity
         * @param {string} id
         * @param {JsonApiDataSourceInDocument} jsonApiDataSourceInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityDataSources: async (id, jsonApiDataSourceInDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityDataSources", "id", id);
            // verify required parameter 'jsonApiDataSourceInDocument' is not null or undefined
            assertParamExists("updateEntityDataSources", "jsonApiDataSourceInDocument", jsonApiDataSourceInDocument);
            const localVarPath = `/api/v1/entities/dataSources/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiDataSourceInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiDataSourceInDocument !== undefined ? jsonApiDataSourceInDocument : {})
                : jsonApiDataSourceInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DataSourceEntityAPIsApi - functional programming interface
 * @export
 */
export const DataSourceEntityAPIsApiFp = function (configuration) {
    const localVarAxiosParamCreator = DataSourceEntityAPIsApiAxiosParamCreator(configuration);
    return {
        /**
         * Data Source - represents data source for the workspace
         * @summary Post Data Sources
         * @param {JsonApiDataSourceInDocument} jsonApiDataSourceInDocument
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityDataSources(jsonApiDataSourceInDocument, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityDataSources(jsonApiDataSourceInDocument, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Delete Data Source entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityDataSources(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityDataSources(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Data Source Identifiers
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesDataSourceIdentifiers(filter, page, size, sort, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesDataSourceIdentifiers(filter, page, size, sort, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} dataSourceId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesDataSourceTables(dataSourceId, filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesDataSourceTables(dataSourceId, filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Get Data Source entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesDataSources(filter, page, size, sort, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesDataSources(filter, page, size, sort, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Data Source Identifier
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityDataSourceIdentifiers(id, filter, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityDataSourceIdentifiers(id, filter, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} dataSourceId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityDataSourceTables(dataSourceId, id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityDataSourceTables(dataSourceId, id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Get Data Source entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityDataSources(id, filter, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityDataSources(id, filter, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Patch Data Source entity
         * @param {string} id
         * @param {JsonApiDataSourcePatchDocument} jsonApiDataSourcePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityDataSources(id, jsonApiDataSourcePatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityDataSources(id, jsonApiDataSourcePatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Put Data Source entity
         * @param {string} id
         * @param {JsonApiDataSourceInDocument} jsonApiDataSourceInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityDataSources(id, jsonApiDataSourceInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityDataSources(id, jsonApiDataSourceInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * DataSourceEntityAPIsApi - factory interface
 * @export
 */
export const DataSourceEntityAPIsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DataSourceEntityAPIsApiFp(configuration);
    return {
        /**
         * Data Source - represents data source for the workspace
         * @summary Post Data Sources
         * @param {DataSourceEntityAPIsApiCreateEntityDataSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityDataSources(requestParameters, options) {
            return localVarFp
                .createEntityDataSources(requestParameters.jsonApiDataSourceInDocument, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Delete Data Source entity
         * @param {DataSourceEntityAPIsApiDeleteEntityDataSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityDataSources(requestParameters, options) {
            return localVarFp
                .deleteEntityDataSources(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Data Source Identifiers
         * @param {DataSourceEntityAPIsApiGetAllEntitiesDataSourceIdentifiersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSourceIdentifiers(requestParameters, options) {
            return localVarFp
                .getAllEntitiesDataSourceIdentifiers(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {DataSourceEntityAPIsApiGetAllEntitiesDataSourceTablesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSourceTables(requestParameters, options) {
            return localVarFp
                .getAllEntitiesDataSourceTables(requestParameters.dataSourceId, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Get Data Source entities
         * @param {DataSourceEntityAPIsApiGetAllEntitiesDataSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSources(requestParameters, options) {
            return localVarFp
                .getAllEntitiesDataSources(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Data Source Identifier
         * @param {DataSourceEntityAPIsApiGetEntityDataSourceIdentifiersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSourceIdentifiers(requestParameters, options) {
            return localVarFp
                .getEntityDataSourceIdentifiers(requestParameters.id, requestParameters.filter, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {DataSourceEntityAPIsApiGetEntityDataSourceTablesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSourceTables(requestParameters, options) {
            return localVarFp
                .getEntityDataSourceTables(requestParameters.dataSourceId, requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Get Data Source entity
         * @param {DataSourceEntityAPIsApiGetEntityDataSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSources(requestParameters, options) {
            return localVarFp
                .getEntityDataSources(requestParameters.id, requestParameters.filter, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Patch Data Source entity
         * @param {DataSourceEntityAPIsApiPatchEntityDataSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityDataSources(requestParameters, options) {
            return localVarFp
                .patchEntityDataSources(requestParameters.id, requestParameters.jsonApiDataSourcePatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Put Data Source entity
         * @param {DataSourceEntityAPIsApiUpdateEntityDataSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityDataSources(requestParameters, options) {
            return localVarFp
                .updateEntityDataSources(requestParameters.id, requestParameters.jsonApiDataSourceInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * DataSourceEntityAPIsApi - object-oriented interface
 * @export
 * @class DataSourceEntityAPIsApi
 * @extends {BaseAPI}
 */
export class DataSourceEntityAPIsApi extends BaseAPI {
    /**
     * Data Source - represents data source for the workspace
     * @summary Post Data Sources
     * @param {DataSourceEntityAPIsApiCreateEntityDataSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceEntityAPIsApi
     */
    createEntityDataSources(requestParameters, options) {
        return DataSourceEntityAPIsApiFp(this.configuration)
            .createEntityDataSources(requestParameters.jsonApiDataSourceInDocument, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Data Source - represents data source for the workspace
     * @summary Delete Data Source entity
     * @param {DataSourceEntityAPIsApiDeleteEntityDataSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceEntityAPIsApi
     */
    deleteEntityDataSources(requestParameters, options) {
        return DataSourceEntityAPIsApiFp(this.configuration)
            .deleteEntityDataSources(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Data Source Identifiers
     * @param {DataSourceEntityAPIsApiGetAllEntitiesDataSourceIdentifiersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceEntityAPIsApi
     */
    getAllEntitiesDataSourceIdentifiers(requestParameters = {}, options) {
        return DataSourceEntityAPIsApiFp(this.configuration)
            .getAllEntitiesDataSourceIdentifiers(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {DataSourceEntityAPIsApiGetAllEntitiesDataSourceTablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceEntityAPIsApi
     */
    getAllEntitiesDataSourceTables(requestParameters, options) {
        return DataSourceEntityAPIsApiFp(this.configuration)
            .getAllEntitiesDataSourceTables(requestParameters.dataSourceId, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Data Source - represents data source for the workspace
     * @summary Get Data Source entities
     * @param {DataSourceEntityAPIsApiGetAllEntitiesDataSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceEntityAPIsApi
     */
    getAllEntitiesDataSources(requestParameters = {}, options) {
        return DataSourceEntityAPIsApiFp(this.configuration)
            .getAllEntitiesDataSources(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Data Source Identifier
     * @param {DataSourceEntityAPIsApiGetEntityDataSourceIdentifiersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceEntityAPIsApi
     */
    getEntityDataSourceIdentifiers(requestParameters, options) {
        return DataSourceEntityAPIsApiFp(this.configuration)
            .getEntityDataSourceIdentifiers(requestParameters.id, requestParameters.filter, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {DataSourceEntityAPIsApiGetEntityDataSourceTablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceEntityAPIsApi
     */
    getEntityDataSourceTables(requestParameters, options) {
        return DataSourceEntityAPIsApiFp(this.configuration)
            .getEntityDataSourceTables(requestParameters.dataSourceId, requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Data Source - represents data source for the workspace
     * @summary Get Data Source entity
     * @param {DataSourceEntityAPIsApiGetEntityDataSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceEntityAPIsApi
     */
    getEntityDataSources(requestParameters, options) {
        return DataSourceEntityAPIsApiFp(this.configuration)
            .getEntityDataSources(requestParameters.id, requestParameters.filter, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Data Source - represents data source for the workspace
     * @summary Patch Data Source entity
     * @param {DataSourceEntityAPIsApiPatchEntityDataSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceEntityAPIsApi
     */
    patchEntityDataSources(requestParameters, options) {
        return DataSourceEntityAPIsApiFp(this.configuration)
            .patchEntityDataSources(requestParameters.id, requestParameters.jsonApiDataSourcePatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Data Source - represents data source for the workspace
     * @summary Put Data Source entity
     * @param {DataSourceEntityAPIsApiUpdateEntityDataSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceEntityAPIsApi
     */
    updateEntityDataSources(requestParameters, options) {
        return DataSourceEntityAPIsApiFp(this.configuration)
            .updateEntityDataSources(requestParameters.id, requestParameters.jsonApiDataSourceInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DatasetsApi - axios parameter creator
 * @export
 */
export const DatasetsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get all Datasets
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'facts' | 'datasets' | 'workspaceDataFilters' | 'references' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDatasets: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesDatasets", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/datasets`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Dataset
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'facts' | 'datasets' | 'workspaceDataFilters' | 'references' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDatasets: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityDatasets", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityDatasets", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/datasets/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DatasetsApi - functional programming interface
 * @export
 */
export const DatasetsApiFp = function (configuration) {
    const localVarAxiosParamCreator = DatasetsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get all Datasets
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'facts' | 'datasets' | 'workspaceDataFilters' | 'references' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesDatasets(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesDatasets(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Dataset
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'facts' | 'datasets' | 'workspaceDataFilters' | 'references' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityDatasets(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityDatasets(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * DatasetsApi - factory interface
 * @export
 */
export const DatasetsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DatasetsApiFp(configuration);
    return {
        /**
         *
         * @summary Get all Datasets
         * @param {DatasetsApiGetAllEntitiesDatasetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDatasets(requestParameters, options) {
            return localVarFp
                .getAllEntitiesDatasets(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Dataset
         * @param {DatasetsApiGetEntityDatasetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDatasets(requestParameters, options) {
            return localVarFp
                .getEntityDatasets(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * DatasetsApi - object-oriented interface
 * @export
 * @class DatasetsApi
 * @extends {BaseAPI}
 */
export class DatasetsApi extends BaseAPI {
    /**
     *
     * @summary Get all Datasets
     * @param {DatasetsApiGetAllEntitiesDatasetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    getAllEntitiesDatasets(requestParameters, options) {
        return DatasetsApiFp(this.configuration)
            .getAllEntitiesDatasets(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Dataset
     * @param {DatasetsApiGetEntityDatasetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    getEntityDatasets(requestParameters, options) {
        return DatasetsApiFp(this.configuration)
            .getEntityDatasets(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DependencyGraphApi - axios parameter creator
 * @export
 */
export const DependencyGraphApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Computes the dependent entities graph
         * @summary Computes the dependent entities graph
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDependentEntitiesGraph: async (workspaceId, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getDependentEntitiesGraph", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/dependentEntitiesGraph`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Computes the dependent entities graph from given entry points
         * @summary Computes the dependent entities graph from given entry points
         * @param {string} workspaceId
         * @param {DependentEntitiesRequest} dependentEntitiesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDependentEntitiesGraphFromEntryPoints: async (workspaceId, dependentEntitiesRequest, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getDependentEntitiesGraphFromEntryPoints", "workspaceId", workspaceId);
            // verify required parameter 'dependentEntitiesRequest' is not null or undefined
            assertParamExists("getDependentEntitiesGraphFromEntryPoints", "dependentEntitiesRequest", dependentEntitiesRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/dependentEntitiesGraph`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof dependentEntitiesRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(dependentEntitiesRequest !== undefined ? dependentEntitiesRequest : {})
                : dependentEntitiesRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DependencyGraphApi - functional programming interface
 * @export
 */
export const DependencyGraphApiFp = function (configuration) {
    const localVarAxiosParamCreator = DependencyGraphApiAxiosParamCreator(configuration);
    return {
        /**
         * Computes the dependent entities graph
         * @summary Computes the dependent entities graph
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDependentEntitiesGraph(workspaceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDependentEntitiesGraph(workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Computes the dependent entities graph from given entry points
         * @summary Computes the dependent entities graph from given entry points
         * @param {string} workspaceId
         * @param {DependentEntitiesRequest} dependentEntitiesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDependentEntitiesGraphFromEntryPoints(workspaceId, dependentEntitiesRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDependentEntitiesGraphFromEntryPoints(workspaceId, dependentEntitiesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * DependencyGraphApi - factory interface
 * @export
 */
export const DependencyGraphApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DependencyGraphApiFp(configuration);
    return {
        /**
         * Computes the dependent entities graph
         * @summary Computes the dependent entities graph
         * @param {DependencyGraphApiGetDependentEntitiesGraphRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDependentEntitiesGraph(requestParameters, options) {
            return localVarFp
                .getDependentEntitiesGraph(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Computes the dependent entities graph from given entry points
         * @summary Computes the dependent entities graph from given entry points
         * @param {DependencyGraphApiGetDependentEntitiesGraphFromEntryPointsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDependentEntitiesGraphFromEntryPoints(requestParameters, options) {
            return localVarFp
                .getDependentEntitiesGraphFromEntryPoints(requestParameters.workspaceId, requestParameters.dependentEntitiesRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * DependencyGraphApi - object-oriented interface
 * @export
 * @class DependencyGraphApi
 * @extends {BaseAPI}
 */
export class DependencyGraphApi extends BaseAPI {
    /**
     * Computes the dependent entities graph
     * @summary Computes the dependent entities graph
     * @param {DependencyGraphApiGetDependentEntitiesGraphRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DependencyGraphApi
     */
    getDependentEntitiesGraph(requestParameters, options) {
        return DependencyGraphApiFp(this.configuration)
            .getDependentEntitiesGraph(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Computes the dependent entities graph from given entry points
     * @summary Computes the dependent entities graph from given entry points
     * @param {DependencyGraphApiGetDependentEntitiesGraphFromEntryPointsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DependencyGraphApi
     */
    getDependentEntitiesGraphFromEntryPoints(requestParameters, options) {
        return DependencyGraphApiFp(this.configuration)
            .getDependentEntitiesGraphFromEntryPoints(requestParameters.workspaceId, requestParameters.dependentEntitiesRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * EntitiesApi - axios parameter creator
 * @export
 */
export const EntitiesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Post Dashboards
         * @param {string} workspaceId
         * @param {JsonApiAnalyticalDashboardPostOptionalIdDocument} jsonApiAnalyticalDashboardPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'permissions' | 'origin' | 'accessInfo' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityAnalyticalDashboards: async (workspaceId, jsonApiAnalyticalDashboardPostOptionalIdDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityAnalyticalDashboards", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiAnalyticalDashboardPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityAnalyticalDashboards", "jsonApiAnalyticalDashboardPostOptionalIdDocument", jsonApiAnalyticalDashboardPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/analyticalDashboards`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiAnalyticalDashboardPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiAnalyticalDashboardPostOptionalIdDocument !== undefined
                    ? jsonApiAnalyticalDashboardPostOptionalIdDocument
                    : {})
                : jsonApiAnalyticalDashboardPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post a new API token for the user
         * @param {string} userId
         * @param {JsonApiApiTokenInDocument} jsonApiApiTokenInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityApiTokens: async (userId, jsonApiApiTokenInDocument, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("createEntityApiTokens", "userId", userId);
            // verify required parameter 'jsonApiApiTokenInDocument' is not null or undefined
            assertParamExists("createEntityApiTokens", "jsonApiApiTokenInDocument", jsonApiApiTokenInDocument);
            const localVarPath = `/api/v1/entities/users/{userId}/apiTokens`.replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiApiTokenInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiApiTokenInDocument !== undefined ? jsonApiApiTokenInDocument : {})
                : jsonApiApiTokenInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Attribute Hierarchies
         * @param {string} workspaceId
         * @param {JsonApiAttributeHierarchyInDocument} jsonApiAttributeHierarchyInDocument
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityAttributeHierarchies: async (workspaceId, jsonApiAttributeHierarchyInDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityAttributeHierarchies", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiAttributeHierarchyInDocument' is not null or undefined
            assertParamExists("createEntityAttributeHierarchies", "jsonApiAttributeHierarchyInDocument", jsonApiAttributeHierarchyInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributeHierarchies`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiAttributeHierarchyInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiAttributeHierarchyInDocument !== undefined
                    ? jsonApiAttributeHierarchyInDocument
                    : {})
                : jsonApiAttributeHierarchyInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Color Pallettes
         * @param {JsonApiColorPaletteInDocument} jsonApiColorPaletteInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityColorPalettes: async (jsonApiColorPaletteInDocument, options = {}) => {
            // verify required parameter 'jsonApiColorPaletteInDocument' is not null or undefined
            assertParamExists("createEntityColorPalettes", "jsonApiColorPaletteInDocument", jsonApiColorPaletteInDocument);
            const localVarPath = `/api/v1/entities/colorPalettes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiColorPaletteInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiColorPaletteInDocument !== undefined ? jsonApiColorPaletteInDocument : {})
                : jsonApiColorPaletteInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Context Security Police Directive
         * @summary Post CSP Directives
         * @param {JsonApiCspDirectiveInDocument} jsonApiCspDirectiveInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityCspDirectives: async (jsonApiCspDirectiveInDocument, options = {}) => {
            // verify required parameter 'jsonApiCspDirectiveInDocument' is not null or undefined
            assertParamExists("createEntityCspDirectives", "jsonApiCspDirectiveInDocument", jsonApiCspDirectiveInDocument);
            const localVarPath = `/api/v1/entities/cspDirectives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCspDirectiveInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCspDirectiveInDocument !== undefined ? jsonApiCspDirectiveInDocument : {})
                : jsonApiCspDirectiveInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Custom Application Settings
         * @param {string} workspaceId
         * @param {JsonApiCustomApplicationSettingPostOptionalIdDocument} jsonApiCustomApplicationSettingPostOptionalIdDocument
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityCustomApplicationSettings: async (workspaceId, jsonApiCustomApplicationSettingPostOptionalIdDocument, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityCustomApplicationSettings", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiCustomApplicationSettingPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityCustomApplicationSettings", "jsonApiCustomApplicationSettingPostOptionalIdDocument", jsonApiCustomApplicationSettingPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/customApplicationSettings`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCustomApplicationSettingPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCustomApplicationSettingPostOptionalIdDocument !== undefined
                    ? jsonApiCustomApplicationSettingPostOptionalIdDocument
                    : {})
                : jsonApiCustomApplicationSettingPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Plugins
         * @param {string} workspaceId
         * @param {JsonApiDashboardPluginPostOptionalIdDocument} jsonApiDashboardPluginPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityDashboardPlugins: async (workspaceId, jsonApiDashboardPluginPostOptionalIdDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityDashboardPlugins", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiDashboardPluginPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityDashboardPlugins", "jsonApiDashboardPluginPostOptionalIdDocument", jsonApiDashboardPluginPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/dashboardPlugins`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiDashboardPluginPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiDashboardPluginPostOptionalIdDocument !== undefined
                    ? jsonApiDashboardPluginPostOptionalIdDocument
                    : {})
                : jsonApiDashboardPluginPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Post Data Sources
         * @param {JsonApiDataSourceInDocument} jsonApiDataSourceInDocument
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityDataSources: async (jsonApiDataSourceInDocument, metaInclude, options = {}) => {
            // verify required parameter 'jsonApiDataSourceInDocument' is not null or undefined
            assertParamExists("createEntityDataSources", "jsonApiDataSourceInDocument", jsonApiDataSourceInDocument);
            const localVarPath = `/api/v1/entities/dataSources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiDataSourceInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiDataSourceInDocument !== undefined ? jsonApiDataSourceInDocument : {})
                : jsonApiDataSourceInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Context Filters
         * @param {string} workspaceId
         * @param {JsonApiFilterContextPostOptionalIdDocument} jsonApiFilterContextPostOptionalIdDocument
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityFilterContexts: async (workspaceId, jsonApiFilterContextPostOptionalIdDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityFilterContexts", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiFilterContextPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityFilterContexts", "jsonApiFilterContextPostOptionalIdDocument", jsonApiFilterContextPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/filterContexts`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiFilterContextPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiFilterContextPostOptionalIdDocument !== undefined
                    ? jsonApiFilterContextPostOptionalIdDocument
                    : {})
                : jsonApiFilterContextPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Post Jwks
         * @param {JsonApiJwkInDocument} jsonApiJwkInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityJwks: async (jsonApiJwkInDocument, options = {}) => {
            // verify required parameter 'jsonApiJwkInDocument' is not null or undefined
            assertParamExists("createEntityJwks", "jsonApiJwkInDocument", jsonApiJwkInDocument);
            const localVarPath = `/api/v1/entities/jwks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiJwkInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiJwkInDocument !== undefined ? jsonApiJwkInDocument : {})
                : jsonApiJwkInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Metrics
         * @param {string} workspaceId
         * @param {JsonApiMetricPostOptionalIdDocument} jsonApiMetricPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityMetrics: async (workspaceId, jsonApiMetricPostOptionalIdDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityMetrics", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiMetricPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityMetrics", "jsonApiMetricPostOptionalIdDocument", jsonApiMetricPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/metrics`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiMetricPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiMetricPostOptionalIdDocument !== undefined
                    ? jsonApiMetricPostOptionalIdDocument
                    : {})
                : jsonApiMetricPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Organization Setting entities
         * @param {JsonApiOrganizationSettingInDocument} jsonApiOrganizationSettingInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityOrganizationSettings: async (jsonApiOrganizationSettingInDocument, options = {}) => {
            // verify required parameter 'jsonApiOrganizationSettingInDocument' is not null or undefined
            assertParamExists("createEntityOrganizationSettings", "jsonApiOrganizationSettingInDocument", jsonApiOrganizationSettingInDocument);
            const localVarPath = `/api/v1/entities/organizationSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiOrganizationSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiOrganizationSettingInDocument !== undefined
                    ? jsonApiOrganizationSettingInDocument
                    : {})
                : jsonApiOrganizationSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Theming
         * @param {JsonApiThemeInDocument} jsonApiThemeInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityThemes: async (jsonApiThemeInDocument, options = {}) => {
            // verify required parameter 'jsonApiThemeInDocument' is not null or undefined
            assertParamExists("createEntityThemes", "jsonApiThemeInDocument", jsonApiThemeInDocument);
            const localVarPath = `/api/v1/entities/themes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiThemeInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiThemeInDocument !== undefined ? jsonApiThemeInDocument : {})
                : jsonApiThemeInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post User Data Filters
         * @param {string} workspaceId
         * @param {JsonApiUserDataFilterPostOptionalIdDocument} jsonApiUserDataFilterPostOptionalIdDocument
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUserDataFilters: async (workspaceId, jsonApiUserDataFilterPostOptionalIdDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityUserDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiUserDataFilterPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityUserDataFilters", "jsonApiUserDataFilterPostOptionalIdDocument", jsonApiUserDataFilterPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/userDataFilters`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserDataFilterPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserDataFilterPostOptionalIdDocument !== undefined
                    ? jsonApiUserDataFilterPostOptionalIdDocument
                    : {})
                : jsonApiUserDataFilterPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Post User Group entities
         * @param {JsonApiUserGroupInDocument} jsonApiUserGroupInDocument
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUserGroups: async (jsonApiUserGroupInDocument, include, options = {}) => {
            // verify required parameter 'jsonApiUserGroupInDocument' is not null or undefined
            assertParamExists("createEntityUserGroups", "jsonApiUserGroupInDocument", jsonApiUserGroupInDocument);
            const localVarPath = `/api/v1/entities/userGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserGroupInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserGroupInDocument !== undefined ? jsonApiUserGroupInDocument : {})
                : jsonApiUserGroupInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post new user settings for the user
         * @param {string} userId
         * @param {JsonApiUserSettingInDocument} jsonApiUserSettingInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUserSettings: async (userId, jsonApiUserSettingInDocument, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("createEntityUserSettings", "userId", userId);
            // verify required parameter 'jsonApiUserSettingInDocument' is not null or undefined
            assertParamExists("createEntityUserSettings", "jsonApiUserSettingInDocument", jsonApiUserSettingInDocument);
            const localVarPath = `/api/v1/entities/users/{userId}/userSettings`.replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserSettingInDocument !== undefined ? jsonApiUserSettingInDocument : {})
                : jsonApiUserSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User - represents entity interacting with platform
         * @summary Post User entities
         * @param {JsonApiUserInDocument} jsonApiUserInDocument
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUsers: async (jsonApiUserInDocument, include, options = {}) => {
            // verify required parameter 'jsonApiUserInDocument' is not null or undefined
            assertParamExists("createEntityUsers", "jsonApiUserInDocument", jsonApiUserInDocument);
            const localVarPath = `/api/v1/entities/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserInDocument !== undefined ? jsonApiUserInDocument : {})
                : jsonApiUserInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Visualization Objects
         * @param {string} workspaceId
         * @param {JsonApiVisualizationObjectPostOptionalIdDocument} jsonApiVisualizationObjectPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityVisualizationObjects: async (workspaceId, jsonApiVisualizationObjectPostOptionalIdDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityVisualizationObjects", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiVisualizationObjectPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityVisualizationObjects", "jsonApiVisualizationObjectPostOptionalIdDocument", jsonApiVisualizationObjectPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/visualizationObjects`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiVisualizationObjectPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiVisualizationObjectPostOptionalIdDocument !== undefined
                    ? jsonApiVisualizationObjectPostOptionalIdDocument
                    : {})
                : jsonApiVisualizationObjectPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Settings for Workspace Data Filters
         * @param {string} workspaceId
         * @param {JsonApiWorkspaceDataFilterSettingInDocument} jsonApiWorkspaceDataFilterSettingInDocument
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaceDataFilterSettings: async (workspaceId, jsonApiWorkspaceDataFilterSettingInDocument, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityWorkspaceDataFilterSettings", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiWorkspaceDataFilterSettingInDocument' is not null or undefined
            assertParamExists("createEntityWorkspaceDataFilterSettings", "jsonApiWorkspaceDataFilterSettingInDocument", jsonApiWorkspaceDataFilterSettingInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilterSettings`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceDataFilterSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceDataFilterSettingInDocument !== undefined
                    ? jsonApiWorkspaceDataFilterSettingInDocument
                    : {})
                : jsonApiWorkspaceDataFilterSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Workspace Data Filters
         * @param {string} workspaceId
         * @param {JsonApiWorkspaceDataFilterInDocument} jsonApiWorkspaceDataFilterInDocument
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaceDataFilters: async (workspaceId, jsonApiWorkspaceDataFilterInDocument, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityWorkspaceDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiWorkspaceDataFilterInDocument' is not null or undefined
            assertParamExists("createEntityWorkspaceDataFilters", "jsonApiWorkspaceDataFilterInDocument", jsonApiWorkspaceDataFilterInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilters`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceDataFilterInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceDataFilterInDocument !== undefined
                    ? jsonApiWorkspaceDataFilterInDocument
                    : {})
                : jsonApiWorkspaceDataFilterInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Settings for Workspaces
         * @param {string} workspaceId
         * @param {JsonApiWorkspaceSettingPostOptionalIdDocument} jsonApiWorkspaceSettingPostOptionalIdDocument
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaceSettings: async (workspaceId, jsonApiWorkspaceSettingPostOptionalIdDocument, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityWorkspaceSettings", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiWorkspaceSettingPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityWorkspaceSettings", "jsonApiWorkspaceSettingPostOptionalIdDocument", jsonApiWorkspaceSettingPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceSettings`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceSettingPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceSettingPostOptionalIdDocument !== undefined
                    ? jsonApiWorkspaceSettingPostOptionalIdDocument
                    : {})
                : jsonApiWorkspaceSettingPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Space of the shared interest
         * @summary Post Workspace entities
         * @param {JsonApiWorkspaceInDocument} jsonApiWorkspaceInDocument
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaces: async (jsonApiWorkspaceInDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'jsonApiWorkspaceInDocument' is not null or undefined
            assertParamExists("createEntityWorkspaces", "jsonApiWorkspaceInDocument", jsonApiWorkspaceInDocument);
            const localVarPath = `/api/v1/entities/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceInDocument !== undefined ? jsonApiWorkspaceInDocument : {})
                : jsonApiWorkspaceInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Dashboard
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityAnalyticalDashboards: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityAnalyticalDashboards", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityAnalyticalDashboards", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/analyticalDashboards/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete an API Token for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityApiTokens: async (userId, id, filter, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("deleteEntityApiTokens", "userId", userId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityApiTokens", "id", id);
            const localVarPath = `/api/v1/entities/users/{userId}/apiTokens/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityAttributeHierarchies: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityAttributeHierarchies", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityAttributeHierarchies", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributeHierarchies/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Color Pallette
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityColorPalettes: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityColorPalettes", "id", id);
            const localVarPath = `/api/v1/entities/colorPalettes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Context Security Police Directive
         * @summary Delete CSP Directives
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityCspDirectives: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityCspDirectives", "id", id);
            const localVarPath = `/api/v1/entities/cspDirectives/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityCustomApplicationSettings: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityCustomApplicationSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityCustomApplicationSettings", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/customApplicationSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityDashboardPlugins: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityDashboardPlugins", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityDashboardPlugins", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/dashboardPlugins/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Delete Data Source entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityDataSources: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityDataSources", "id", id);
            const localVarPath = `/api/v1/entities/dataSources/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityFilterContexts: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityFilterContexts", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityFilterContexts", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/filterContexts/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Delete Jwk
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityJwks: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityJwks", "id", id);
            const localVarPath = `/api/v1/entities/jwks/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityMetrics: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityMetrics", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityMetrics", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/metrics/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete Organization entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityOrganizationSettings: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityOrganizationSettings", "id", id);
            const localVarPath = `/api/v1/entities/organizationSettings/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete Theming
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityThemes: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityThemes", "id", id);
            const localVarPath = `/api/v1/entities/themes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUserDataFilters: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityUserDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityUserDataFilters", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/userDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Delete UserGroup entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUserGroups: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityUserGroups", "id", id);
            const localVarPath = `/api/v1/entities/userGroups/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a setting for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUserSettings: async (userId, id, filter, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("deleteEntityUserSettings", "userId", userId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityUserSettings", "id", id);
            const localVarPath = `/api/v1/entities/users/{userId}/userSettings/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User - represents entity interacting with platform
         * @summary Delete User entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUsers: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityUsers", "id", id);
            const localVarPath = `/api/v1/entities/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityVisualizationObjects: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityVisualizationObjects", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityVisualizationObjects", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/visualizationObjects/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Settings for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaceDataFilterSettings: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityWorkspaceDataFilterSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityWorkspaceDataFilterSettings", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilterSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaceDataFilters: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityWorkspaceDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityWorkspaceDataFilters", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Setting for Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaceSettings: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityWorkspaceSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityWorkspaceSettings", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Space of the shared interest
         * @summary Delete Workspace entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaces: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityWorkspaces", "id", id);
            const localVarPath = `/api/v1/entities/workspaces/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Dashboards
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'permissions' | 'origin' | 'accessInfo' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAnalyticalDashboards: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesAnalyticalDashboards", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/analyticalDashboards`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List all api tokens for a user
         * @param {string} userId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesApiTokens: async (userId, filter, page, size, sort, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("getAllEntitiesApiTokens", "userId", userId);
            const localVarPath = `/api/v1/entities/users/{userId}/apiTokens`.replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Attribute Hierarchies
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAttributeHierarchies: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesAttributeHierarchies", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributeHierarchies`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Attributes
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'labels' | 'attributeHierarchies' | 'dataset' | 'defaultView' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAttributes: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesAttributes", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributes`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Color Pallettes
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesColorPalettes: async (filter, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/colorPalettes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Context Security Police Directive
         * @summary Get CSP Directives
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesCspDirectives: async (filter, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/cspDirectives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Custom Application Settings
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesCustomApplicationSettings: async (workspaceId, origin, filter, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesCustomApplicationSettings", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/customApplicationSettings`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Plugins
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDashboardPlugins: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesDashboardPlugins", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/dashboardPlugins`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Data Source Identifiers
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSourceIdentifiers: async (filter, page, size, sort, metaInclude, options = {}) => {
            const localVarPath = `/api/v1/entities/dataSourceIdentifiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} dataSourceId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSourceTables: async (dataSourceId, filter, page, size, sort, options = {}) => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("getAllEntitiesDataSourceTables", "dataSourceId", dataSourceId);
            const localVarPath = `/api/v1/entities/dataSources/{dataSourceId}/dataSourceTables`.replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Get Data Source entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSources: async (filter, page, size, sort, metaInclude, options = {}) => {
            const localVarPath = `/api/v1/entities/dataSources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Datasets
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'facts' | 'datasets' | 'workspaceDataFilters' | 'references' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDatasets: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesDatasets", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/datasets`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Space of the shared interest
         * @summary Get Entitlements
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesEntitlements: async (filter, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/entitlements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Facts
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'dataset' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesFacts: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesFacts", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/facts`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Context Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesFilterContexts: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesFilterContexts", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/filterContexts`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all JSON web keys - used to verify JSON web tokens (Jwts)
         * @summary Get all Jwks
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesJwks: async (filter, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/jwks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Labels
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'attribute' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesLabels: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesLabels", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/labels`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Metrics
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesMetrics: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesMetrics", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/metrics`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Organization entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesOrganizationSettings: async (filter, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/organizationSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Theming entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesThemes: async (filter, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/themes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all User Data Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserDataFilters: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesUserDataFilters", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/userDataFilters`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Get UserGroup entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserGroups: async (filter, include, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/userGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * UserIdentifier - represents entity interacting with platform
         * @summary Get UserIdentifier entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserIdentifiers: async (filter, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/userIdentifiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List all settings for a user
         * @param {string} userId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserSettings: async (userId, filter, page, size, sort, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("getAllEntitiesUserSettings", "userId", userId);
            const localVarPath = `/api/v1/entities/users/{userId}/userSettings`.replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User - represents entity interacting with platform
         * @summary Get User entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUsers: async (filter, include, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Visualization Objects
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesVisualizationObjects: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesVisualizationObjects", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/visualizationObjects`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Settings for Workspace Data Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceDataFilterSettings: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesWorkspaceDataFilterSettings", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilterSettings`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Workspace Data Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceDataFilters: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesWorkspaceDataFilters", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilters`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Setting for Workspaces
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceSettings: async (workspaceId, origin, filter, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesWorkspaceSettings", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceSettings`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Space of the shared interest
         * @summary Get Workspace entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaces: async (filter, include, page, size, sort, metaInclude, options = {}) => {
            const localVarPath = `/api/v1/entities/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves links for all options for different configurations.
         * @summary Links for all configuration options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOptions: async (options = {}) => {
            const localVarPath = `/api/v1/options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all supported data sources along with information about the used drivers.
         * @summary Get all available data source drivers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceDrivers: async (options = {}) => {
            const localVarPath = `/api/v1/options/availableDrivers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Dashboard
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'permissions' | 'origin' | 'accessInfo' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAnalyticalDashboards: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityAnalyticalDashboards", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityAnalyticalDashboards", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/analyticalDashboards/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get an API Token for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityApiTokens: async (userId, id, filter, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("getEntityApiTokens", "userId", userId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityApiTokens", "id", id);
            const localVarPath = `/api/v1/entities/users/{userId}/apiTokens/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAttributeHierarchies: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityAttributeHierarchies", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityAttributeHierarchies", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributeHierarchies/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get an Attribute
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'labels' | 'attributeHierarchies' | 'dataset' | 'defaultView' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAttributes: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityAttributes", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityAttributes", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributes/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Color Pallette
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityColorPalettes: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityColorPalettes", "id", id);
            const localVarPath = `/api/v1/entities/colorPalettes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get CookieSecurityConfiguration
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityCookieSecurityConfigurations: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityCookieSecurityConfigurations", "id", id);
            const localVarPath = `/api/v1/entities/admin/cookieSecurityConfigurations/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Context Security Police Directive
         * @summary Get CSP Directives
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityCspDirectives: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityCspDirectives", "id", id);
            const localVarPath = `/api/v1/entities/cspDirectives/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityCustomApplicationSettings: async (workspaceId, objectId, filter, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityCustomApplicationSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityCustomApplicationSettings", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/customApplicationSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDashboardPlugins: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityDashboardPlugins", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityDashboardPlugins", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/dashboardPlugins/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Data Source Identifier
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSourceIdentifiers: async (id, filter, metaInclude, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityDataSourceIdentifiers", "id", id);
            const localVarPath = `/api/v1/entities/dataSourceIdentifiers/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} dataSourceId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSourceTables: async (dataSourceId, id, filter, options = {}) => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("getEntityDataSourceTables", "dataSourceId", dataSourceId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityDataSourceTables", "id", id);
            const localVarPath = `/api/v1/entities/dataSources/{dataSourceId}/dataSourceTables/{id}`
                .replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Get Data Source entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSources: async (id, filter, metaInclude, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityDataSources", "id", id);
            const localVarPath = `/api/v1/entities/dataSources/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Dataset
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'facts' | 'datasets' | 'workspaceDataFilters' | 'references' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDatasets: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityDatasets", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityDatasets", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/datasets/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Space of the shared interest
         * @summary Get Entitlement
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityEntitlements: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityEntitlements", "id", id);
            const localVarPath = `/api/v1/entities/entitlements/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Fact
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'dataset' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityFacts: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityFacts", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityFacts", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/facts/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityFilterContexts: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityFilterContexts", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityFilterContexts", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/filterContexts/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Get Jwk
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityJwks: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityJwks", "id", id);
            const localVarPath = `/api/v1/entities/jwks/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Label
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'attribute' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityLabels: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityLabels", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityLabels", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/labels/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityMetrics: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityMetrics", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityMetrics", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/metrics/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Organization entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityOrganizationSettings: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityOrganizationSettings", "id", id);
            const localVarPath = `/api/v1/entities/organizationSettings/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Organizations
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityOrganizations: async (id, filter, include, metaInclude, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityOrganizations", "id", id);
            const localVarPath = `/api/v1/entities/admin/organizations/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Theming
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityThemes: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityThemes", "id", id);
            const localVarPath = `/api/v1/entities/themes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserDataFilters: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityUserDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityUserDataFilters", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/userDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Get UserGroup entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserGroups: async (id, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityUserGroups", "id", id);
            const localVarPath = `/api/v1/entities/userGroups/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * UserIdentifier - represents basic informationZ about entity interacting with platform
         * @summary Get UserIdentifier entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserIdentifiers: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityUserIdentifiers", "id", id);
            const localVarPath = `/api/v1/entities/userIdentifiers/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a setting for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserSettings: async (userId, id, filter, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("getEntityUserSettings", "userId", userId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityUserSettings", "id", id);
            const localVarPath = `/api/v1/entities/users/{userId}/userSettings/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User - represents entity interacting with platform
         * @summary Get User entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUsers: async (id, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityUsers", "id", id);
            const localVarPath = `/api/v1/entities/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityVisualizationObjects: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityVisualizationObjects", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityVisualizationObjects", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/visualizationObjects/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Setting for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceDataFilterSettings: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityWorkspaceDataFilterSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityWorkspaceDataFilterSettings", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilterSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceDataFilters: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityWorkspaceDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityWorkspaceDataFilters", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Setting for Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceSettings: async (workspaceId, objectId, filter, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityWorkspaceSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityWorkspaceSettings", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Space of the shared interest
         * @summary Get Workspace entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaces: async (id, filter, include, metaInclude, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityWorkspaces", "id", id);
            const localVarPath = `/api/v1/entities/workspaces/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a basic information about organization.
         * @summary Get current organization info
         * @param {Array<'permissions' | 'all'>} [metaInclude] Return list of permissions available to logged user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: async (metaInclude, options = {}) => {
            const localVarPath = `/api/v1/entities/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Dashboard
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAnalyticalDashboardPatchDocument} jsonApiAnalyticalDashboardPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityAnalyticalDashboards: async (workspaceId, objectId, jsonApiAnalyticalDashboardPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityAnalyticalDashboards", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityAnalyticalDashboards", "objectId", objectId);
            // verify required parameter 'jsonApiAnalyticalDashboardPatchDocument' is not null or undefined
            assertParamExists("patchEntityAnalyticalDashboards", "jsonApiAnalyticalDashboardPatchDocument", jsonApiAnalyticalDashboardPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/analyticalDashboards/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiAnalyticalDashboardPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiAnalyticalDashboardPatchDocument !== undefined
                    ? jsonApiAnalyticalDashboardPatchDocument
                    : {})
                : jsonApiAnalyticalDashboardPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAttributeHierarchyPatchDocument} jsonApiAttributeHierarchyPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityAttributeHierarchies: async (workspaceId, objectId, jsonApiAttributeHierarchyPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityAttributeHierarchies", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityAttributeHierarchies", "objectId", objectId);
            // verify required parameter 'jsonApiAttributeHierarchyPatchDocument' is not null or undefined
            assertParamExists("patchEntityAttributeHierarchies", "jsonApiAttributeHierarchyPatchDocument", jsonApiAttributeHierarchyPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributeHierarchies/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiAttributeHierarchyPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiAttributeHierarchyPatchDocument !== undefined
                    ? jsonApiAttributeHierarchyPatchDocument
                    : {})
                : jsonApiAttributeHierarchyPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch Color Pallette
         * @param {string} id
         * @param {JsonApiColorPalettePatchDocument} jsonApiColorPalettePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityColorPalettes: async (id, jsonApiColorPalettePatchDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityColorPalettes", "id", id);
            // verify required parameter 'jsonApiColorPalettePatchDocument' is not null or undefined
            assertParamExists("patchEntityColorPalettes", "jsonApiColorPalettePatchDocument", jsonApiColorPalettePatchDocument);
            const localVarPath = `/api/v1/entities/colorPalettes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiColorPalettePatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiColorPalettePatchDocument !== undefined ? jsonApiColorPalettePatchDocument : {})
                : jsonApiColorPalettePatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch CookieSecurityConfiguration
         * @param {string} id
         * @param {JsonApiCookieSecurityConfigurationPatchDocument} jsonApiCookieSecurityConfigurationPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityCookieSecurityConfigurations: async (id, jsonApiCookieSecurityConfigurationPatchDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityCookieSecurityConfigurations", "id", id);
            // verify required parameter 'jsonApiCookieSecurityConfigurationPatchDocument' is not null or undefined
            assertParamExists("patchEntityCookieSecurityConfigurations", "jsonApiCookieSecurityConfigurationPatchDocument", jsonApiCookieSecurityConfigurationPatchDocument);
            const localVarPath = `/api/v1/entities/admin/cookieSecurityConfigurations/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCookieSecurityConfigurationPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCookieSecurityConfigurationPatchDocument !== undefined
                    ? jsonApiCookieSecurityConfigurationPatchDocument
                    : {})
                : jsonApiCookieSecurityConfigurationPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Context Security Police Directive
         * @summary Patch CSP Directives
         * @param {string} id
         * @param {JsonApiCspDirectivePatchDocument} jsonApiCspDirectivePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityCspDirectives: async (id, jsonApiCspDirectivePatchDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityCspDirectives", "id", id);
            // verify required parameter 'jsonApiCspDirectivePatchDocument' is not null or undefined
            assertParamExists("patchEntityCspDirectives", "jsonApiCspDirectivePatchDocument", jsonApiCspDirectivePatchDocument);
            const localVarPath = `/api/v1/entities/cspDirectives/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCspDirectivePatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCspDirectivePatchDocument !== undefined ? jsonApiCspDirectivePatchDocument : {})
                : jsonApiCspDirectivePatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiCustomApplicationSettingPatchDocument} jsonApiCustomApplicationSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityCustomApplicationSettings: async (workspaceId, objectId, jsonApiCustomApplicationSettingPatchDocument, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityCustomApplicationSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityCustomApplicationSettings", "objectId", objectId);
            // verify required parameter 'jsonApiCustomApplicationSettingPatchDocument' is not null or undefined
            assertParamExists("patchEntityCustomApplicationSettings", "jsonApiCustomApplicationSettingPatchDocument", jsonApiCustomApplicationSettingPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/customApplicationSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCustomApplicationSettingPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCustomApplicationSettingPatchDocument !== undefined
                    ? jsonApiCustomApplicationSettingPatchDocument
                    : {})
                : jsonApiCustomApplicationSettingPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiDashboardPluginPatchDocument} jsonApiDashboardPluginPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityDashboardPlugins: async (workspaceId, objectId, jsonApiDashboardPluginPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityDashboardPlugins", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityDashboardPlugins", "objectId", objectId);
            // verify required parameter 'jsonApiDashboardPluginPatchDocument' is not null or undefined
            assertParamExists("patchEntityDashboardPlugins", "jsonApiDashboardPluginPatchDocument", jsonApiDashboardPluginPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/dashboardPlugins/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiDashboardPluginPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiDashboardPluginPatchDocument !== undefined
                    ? jsonApiDashboardPluginPatchDocument
                    : {})
                : jsonApiDashboardPluginPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Patch Data Source entity
         * @param {string} id
         * @param {JsonApiDataSourcePatchDocument} jsonApiDataSourcePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityDataSources: async (id, jsonApiDataSourcePatchDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityDataSources", "id", id);
            // verify required parameter 'jsonApiDataSourcePatchDocument' is not null or undefined
            assertParamExists("patchEntityDataSources", "jsonApiDataSourcePatchDocument", jsonApiDataSourcePatchDocument);
            const localVarPath = `/api/v1/entities/dataSources/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiDataSourcePatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiDataSourcePatchDocument !== undefined ? jsonApiDataSourcePatchDocument : {})
                : jsonApiDataSourcePatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiFilterContextPatchDocument} jsonApiFilterContextPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityFilterContexts: async (workspaceId, objectId, jsonApiFilterContextPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityFilterContexts", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityFilterContexts", "objectId", objectId);
            // verify required parameter 'jsonApiFilterContextPatchDocument' is not null or undefined
            assertParamExists("patchEntityFilterContexts", "jsonApiFilterContextPatchDocument", jsonApiFilterContextPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/filterContexts/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiFilterContextPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiFilterContextPatchDocument !== undefined
                    ? jsonApiFilterContextPatchDocument
                    : {})
                : jsonApiFilterContextPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Patches JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Patch Jwk
         * @param {string} id
         * @param {JsonApiJwkPatchDocument} jsonApiJwkPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityJwks: async (id, jsonApiJwkPatchDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityJwks", "id", id);
            // verify required parameter 'jsonApiJwkPatchDocument' is not null or undefined
            assertParamExists("patchEntityJwks", "jsonApiJwkPatchDocument", jsonApiJwkPatchDocument);
            const localVarPath = `/api/v1/entities/jwks/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiJwkPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiJwkPatchDocument !== undefined ? jsonApiJwkPatchDocument : {})
                : jsonApiJwkPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiMetricPatchDocument} jsonApiMetricPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityMetrics: async (workspaceId, objectId, jsonApiMetricPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityMetrics", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityMetrics", "objectId", objectId);
            // verify required parameter 'jsonApiMetricPatchDocument' is not null or undefined
            assertParamExists("patchEntityMetrics", "jsonApiMetricPatchDocument", jsonApiMetricPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/metrics/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiMetricPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiMetricPatchDocument !== undefined ? jsonApiMetricPatchDocument : {})
                : jsonApiMetricPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch Organization entity
         * @param {string} id
         * @param {JsonApiOrganizationSettingPatchDocument} jsonApiOrganizationSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityOrganizationSettings: async (id, jsonApiOrganizationSettingPatchDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityOrganizationSettings", "id", id);
            // verify required parameter 'jsonApiOrganizationSettingPatchDocument' is not null or undefined
            assertParamExists("patchEntityOrganizationSettings", "jsonApiOrganizationSettingPatchDocument", jsonApiOrganizationSettingPatchDocument);
            const localVarPath = `/api/v1/entities/organizationSettings/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiOrganizationSettingPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiOrganizationSettingPatchDocument !== undefined
                    ? jsonApiOrganizationSettingPatchDocument
                    : {})
                : jsonApiOrganizationSettingPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch Organization
         * @param {string} id
         * @param {JsonApiOrganizationPatchDocument} jsonApiOrganizationPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityOrganizations: async (id, jsonApiOrganizationPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityOrganizations", "id", id);
            // verify required parameter 'jsonApiOrganizationPatchDocument' is not null or undefined
            assertParamExists("patchEntityOrganizations", "jsonApiOrganizationPatchDocument", jsonApiOrganizationPatchDocument);
            const localVarPath = `/api/v1/entities/admin/organizations/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiOrganizationPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiOrganizationPatchDocument !== undefined ? jsonApiOrganizationPatchDocument : {})
                : jsonApiOrganizationPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch Theming
         * @param {string} id
         * @param {JsonApiThemePatchDocument} jsonApiThemePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityThemes: async (id, jsonApiThemePatchDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityThemes", "id", id);
            // verify required parameter 'jsonApiThemePatchDocument' is not null or undefined
            assertParamExists("patchEntityThemes", "jsonApiThemePatchDocument", jsonApiThemePatchDocument);
            const localVarPath = `/api/v1/entities/themes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiThemePatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiThemePatchDocument !== undefined ? jsonApiThemePatchDocument : {})
                : jsonApiThemePatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiUserDataFilterPatchDocument} jsonApiUserDataFilterPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUserDataFilters: async (workspaceId, objectId, jsonApiUserDataFilterPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityUserDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityUserDataFilters", "objectId", objectId);
            // verify required parameter 'jsonApiUserDataFilterPatchDocument' is not null or undefined
            assertParamExists("patchEntityUserDataFilters", "jsonApiUserDataFilterPatchDocument", jsonApiUserDataFilterPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/userDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserDataFilterPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserDataFilterPatchDocument !== undefined
                    ? jsonApiUserDataFilterPatchDocument
                    : {})
                : jsonApiUserDataFilterPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Patch UserGroup entity
         * @param {string} id
         * @param {JsonApiUserGroupPatchDocument} jsonApiUserGroupPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUserGroups: async (id, jsonApiUserGroupPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityUserGroups", "id", id);
            // verify required parameter 'jsonApiUserGroupPatchDocument' is not null or undefined
            assertParamExists("patchEntityUserGroups", "jsonApiUserGroupPatchDocument", jsonApiUserGroupPatchDocument);
            const localVarPath = `/api/v1/entities/userGroups/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserGroupPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserGroupPatchDocument !== undefined ? jsonApiUserGroupPatchDocument : {})
                : jsonApiUserGroupPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User - represents entity interacting with platform
         * @summary Patch User entity
         * @param {string} id
         * @param {JsonApiUserPatchDocument} jsonApiUserPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUsers: async (id, jsonApiUserPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityUsers", "id", id);
            // verify required parameter 'jsonApiUserPatchDocument' is not null or undefined
            assertParamExists("patchEntityUsers", "jsonApiUserPatchDocument", jsonApiUserPatchDocument);
            const localVarPath = `/api/v1/entities/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserPatchDocument !== undefined ? jsonApiUserPatchDocument : {})
                : jsonApiUserPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiVisualizationObjectPatchDocument} jsonApiVisualizationObjectPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityVisualizationObjects: async (workspaceId, objectId, jsonApiVisualizationObjectPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityVisualizationObjects", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityVisualizationObjects", "objectId", objectId);
            // verify required parameter 'jsonApiVisualizationObjectPatchDocument' is not null or undefined
            assertParamExists("patchEntityVisualizationObjects", "jsonApiVisualizationObjectPatchDocument", jsonApiVisualizationObjectPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/visualizationObjects/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiVisualizationObjectPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiVisualizationObjectPatchDocument !== undefined
                    ? jsonApiVisualizationObjectPatchDocument
                    : {})
                : jsonApiVisualizationObjectPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Settings for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterSettingPatchDocument} jsonApiWorkspaceDataFilterSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaceDataFilterSettings: async (workspaceId, objectId, jsonApiWorkspaceDataFilterSettingPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityWorkspaceDataFilterSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityWorkspaceDataFilterSettings", "objectId", objectId);
            // verify required parameter 'jsonApiWorkspaceDataFilterSettingPatchDocument' is not null or undefined
            assertParamExists("patchEntityWorkspaceDataFilterSettings", "jsonApiWorkspaceDataFilterSettingPatchDocument", jsonApiWorkspaceDataFilterSettingPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilterSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceDataFilterSettingPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceDataFilterSettingPatchDocument !== undefined
                    ? jsonApiWorkspaceDataFilterSettingPatchDocument
                    : {})
                : jsonApiWorkspaceDataFilterSettingPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterPatchDocument} jsonApiWorkspaceDataFilterPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaceDataFilters: async (workspaceId, objectId, jsonApiWorkspaceDataFilterPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityWorkspaceDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityWorkspaceDataFilters", "objectId", objectId);
            // verify required parameter 'jsonApiWorkspaceDataFilterPatchDocument' is not null or undefined
            assertParamExists("patchEntityWorkspaceDataFilters", "jsonApiWorkspaceDataFilterPatchDocument", jsonApiWorkspaceDataFilterPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceDataFilterPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceDataFilterPatchDocument !== undefined
                    ? jsonApiWorkspaceDataFilterPatchDocument
                    : {})
                : jsonApiWorkspaceDataFilterPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Setting for Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceSettingPatchDocument} jsonApiWorkspaceSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaceSettings: async (workspaceId, objectId, jsonApiWorkspaceSettingPatchDocument, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityWorkspaceSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityWorkspaceSettings", "objectId", objectId);
            // verify required parameter 'jsonApiWorkspaceSettingPatchDocument' is not null or undefined
            assertParamExists("patchEntityWorkspaceSettings", "jsonApiWorkspaceSettingPatchDocument", jsonApiWorkspaceSettingPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceSettingPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceSettingPatchDocument !== undefined
                    ? jsonApiWorkspaceSettingPatchDocument
                    : {})
                : jsonApiWorkspaceSettingPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Space of the shared interest
         * @summary Patch Workspace entity
         * @param {string} id
         * @param {JsonApiWorkspacePatchDocument} jsonApiWorkspacePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaces: async (id, jsonApiWorkspacePatchDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityWorkspaces", "id", id);
            // verify required parameter 'jsonApiWorkspacePatchDocument' is not null or undefined
            assertParamExists("patchEntityWorkspaces", "jsonApiWorkspacePatchDocument", jsonApiWorkspacePatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspacePatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspacePatchDocument !== undefined ? jsonApiWorkspacePatchDocument : {})
                : jsonApiWorkspacePatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put Dashboards
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAnalyticalDashboardInDocument} jsonApiAnalyticalDashboardInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityAnalyticalDashboards: async (workspaceId, objectId, jsonApiAnalyticalDashboardInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityAnalyticalDashboards", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityAnalyticalDashboards", "objectId", objectId);
            // verify required parameter 'jsonApiAnalyticalDashboardInDocument' is not null or undefined
            assertParamExists("updateEntityAnalyticalDashboards", "jsonApiAnalyticalDashboardInDocument", jsonApiAnalyticalDashboardInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/analyticalDashboards/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiAnalyticalDashboardInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiAnalyticalDashboardInDocument !== undefined
                    ? jsonApiAnalyticalDashboardInDocument
                    : {})
                : jsonApiAnalyticalDashboardInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put new API token for the user
         * @param {string} userId
         * @param {string} id
         * @param {JsonApiApiTokenInDocument} jsonApiApiTokenInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityApiTokens: async (userId, id, jsonApiApiTokenInDocument, filter, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("updateEntityApiTokens", "userId", userId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityApiTokens", "id", id);
            // verify required parameter 'jsonApiApiTokenInDocument' is not null or undefined
            assertParamExists("updateEntityApiTokens", "jsonApiApiTokenInDocument", jsonApiApiTokenInDocument);
            const localVarPath = `/api/v1/entities/users/{userId}/apiTokens/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiApiTokenInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiApiTokenInDocument !== undefined ? jsonApiApiTokenInDocument : {})
                : jsonApiApiTokenInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAttributeHierarchyInDocument} jsonApiAttributeHierarchyInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityAttributeHierarchies: async (workspaceId, objectId, jsonApiAttributeHierarchyInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityAttributeHierarchies", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityAttributeHierarchies", "objectId", objectId);
            // verify required parameter 'jsonApiAttributeHierarchyInDocument' is not null or undefined
            assertParamExists("updateEntityAttributeHierarchies", "jsonApiAttributeHierarchyInDocument", jsonApiAttributeHierarchyInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributeHierarchies/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiAttributeHierarchyInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiAttributeHierarchyInDocument !== undefined
                    ? jsonApiAttributeHierarchyInDocument
                    : {})
                : jsonApiAttributeHierarchyInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put Color Pallette
         * @param {string} id
         * @param {JsonApiColorPaletteInDocument} jsonApiColorPaletteInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityColorPalettes: async (id, jsonApiColorPaletteInDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityColorPalettes", "id", id);
            // verify required parameter 'jsonApiColorPaletteInDocument' is not null or undefined
            assertParamExists("updateEntityColorPalettes", "jsonApiColorPaletteInDocument", jsonApiColorPaletteInDocument);
            const localVarPath = `/api/v1/entities/colorPalettes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiColorPaletteInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiColorPaletteInDocument !== undefined ? jsonApiColorPaletteInDocument : {})
                : jsonApiColorPaletteInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put CookieSecurityConfiguration
         * @param {string} id
         * @param {JsonApiCookieSecurityConfigurationInDocument} jsonApiCookieSecurityConfigurationInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityCookieSecurityConfigurations: async (id, jsonApiCookieSecurityConfigurationInDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityCookieSecurityConfigurations", "id", id);
            // verify required parameter 'jsonApiCookieSecurityConfigurationInDocument' is not null or undefined
            assertParamExists("updateEntityCookieSecurityConfigurations", "jsonApiCookieSecurityConfigurationInDocument", jsonApiCookieSecurityConfigurationInDocument);
            const localVarPath = `/api/v1/entities/admin/cookieSecurityConfigurations/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCookieSecurityConfigurationInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCookieSecurityConfigurationInDocument !== undefined
                    ? jsonApiCookieSecurityConfigurationInDocument
                    : {})
                : jsonApiCookieSecurityConfigurationInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Context Security Police Directive
         * @summary Put CSP Directives
         * @param {string} id
         * @param {JsonApiCspDirectiveInDocument} jsonApiCspDirectiveInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityCspDirectives: async (id, jsonApiCspDirectiveInDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityCspDirectives", "id", id);
            // verify required parameter 'jsonApiCspDirectiveInDocument' is not null or undefined
            assertParamExists("updateEntityCspDirectives", "jsonApiCspDirectiveInDocument", jsonApiCspDirectiveInDocument);
            const localVarPath = `/api/v1/entities/cspDirectives/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCspDirectiveInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCspDirectiveInDocument !== undefined ? jsonApiCspDirectiveInDocument : {})
                : jsonApiCspDirectiveInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiCustomApplicationSettingInDocument} jsonApiCustomApplicationSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityCustomApplicationSettings: async (workspaceId, objectId, jsonApiCustomApplicationSettingInDocument, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityCustomApplicationSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityCustomApplicationSettings", "objectId", objectId);
            // verify required parameter 'jsonApiCustomApplicationSettingInDocument' is not null or undefined
            assertParamExists("updateEntityCustomApplicationSettings", "jsonApiCustomApplicationSettingInDocument", jsonApiCustomApplicationSettingInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/customApplicationSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCustomApplicationSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCustomApplicationSettingInDocument !== undefined
                    ? jsonApiCustomApplicationSettingInDocument
                    : {})
                : jsonApiCustomApplicationSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiDashboardPluginInDocument} jsonApiDashboardPluginInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityDashboardPlugins: async (workspaceId, objectId, jsonApiDashboardPluginInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityDashboardPlugins", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityDashboardPlugins", "objectId", objectId);
            // verify required parameter 'jsonApiDashboardPluginInDocument' is not null or undefined
            assertParamExists("updateEntityDashboardPlugins", "jsonApiDashboardPluginInDocument", jsonApiDashboardPluginInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/dashboardPlugins/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiDashboardPluginInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiDashboardPluginInDocument !== undefined ? jsonApiDashboardPluginInDocument : {})
                : jsonApiDashboardPluginInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Put Data Source entity
         * @param {string} id
         * @param {JsonApiDataSourceInDocument} jsonApiDataSourceInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityDataSources: async (id, jsonApiDataSourceInDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityDataSources", "id", id);
            // verify required parameter 'jsonApiDataSourceInDocument' is not null or undefined
            assertParamExists("updateEntityDataSources", "jsonApiDataSourceInDocument", jsonApiDataSourceInDocument);
            const localVarPath = `/api/v1/entities/dataSources/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiDataSourceInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiDataSourceInDocument !== undefined ? jsonApiDataSourceInDocument : {})
                : jsonApiDataSourceInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiFilterContextInDocument} jsonApiFilterContextInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityFilterContexts: async (workspaceId, objectId, jsonApiFilterContextInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityFilterContexts", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityFilterContexts", "objectId", objectId);
            // verify required parameter 'jsonApiFilterContextInDocument' is not null or undefined
            assertParamExists("updateEntityFilterContexts", "jsonApiFilterContextInDocument", jsonApiFilterContextInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/filterContexts/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiFilterContextInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiFilterContextInDocument !== undefined ? jsonApiFilterContextInDocument : {})
                : jsonApiFilterContextInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Put Jwk
         * @param {string} id
         * @param {JsonApiJwkInDocument} jsonApiJwkInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityJwks: async (id, jsonApiJwkInDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityJwks", "id", id);
            // verify required parameter 'jsonApiJwkInDocument' is not null or undefined
            assertParamExists("updateEntityJwks", "jsonApiJwkInDocument", jsonApiJwkInDocument);
            const localVarPath = `/api/v1/entities/jwks/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiJwkInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiJwkInDocument !== undefined ? jsonApiJwkInDocument : {})
                : jsonApiJwkInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiMetricInDocument} jsonApiMetricInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityMetrics: async (workspaceId, objectId, jsonApiMetricInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityMetrics", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityMetrics", "objectId", objectId);
            // verify required parameter 'jsonApiMetricInDocument' is not null or undefined
            assertParamExists("updateEntityMetrics", "jsonApiMetricInDocument", jsonApiMetricInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/metrics/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiMetricInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiMetricInDocument !== undefined ? jsonApiMetricInDocument : {})
                : jsonApiMetricInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put Organization entity
         * @param {string} id
         * @param {JsonApiOrganizationSettingInDocument} jsonApiOrganizationSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityOrganizationSettings: async (id, jsonApiOrganizationSettingInDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityOrganizationSettings", "id", id);
            // verify required parameter 'jsonApiOrganizationSettingInDocument' is not null or undefined
            assertParamExists("updateEntityOrganizationSettings", "jsonApiOrganizationSettingInDocument", jsonApiOrganizationSettingInDocument);
            const localVarPath = `/api/v1/entities/organizationSettings/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiOrganizationSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiOrganizationSettingInDocument !== undefined
                    ? jsonApiOrganizationSettingInDocument
                    : {})
                : jsonApiOrganizationSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put Organization
         * @param {string} id
         * @param {JsonApiOrganizationInDocument} jsonApiOrganizationInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityOrganizations: async (id, jsonApiOrganizationInDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityOrganizations", "id", id);
            // verify required parameter 'jsonApiOrganizationInDocument' is not null or undefined
            assertParamExists("updateEntityOrganizations", "jsonApiOrganizationInDocument", jsonApiOrganizationInDocument);
            const localVarPath = `/api/v1/entities/admin/organizations/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiOrganizationInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiOrganizationInDocument !== undefined ? jsonApiOrganizationInDocument : {})
                : jsonApiOrganizationInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put Theming
         * @param {string} id
         * @param {JsonApiThemeInDocument} jsonApiThemeInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityThemes: async (id, jsonApiThemeInDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityThemes", "id", id);
            // verify required parameter 'jsonApiThemeInDocument' is not null or undefined
            assertParamExists("updateEntityThemes", "jsonApiThemeInDocument", jsonApiThemeInDocument);
            const localVarPath = `/api/v1/entities/themes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiThemeInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiThemeInDocument !== undefined ? jsonApiThemeInDocument : {})
                : jsonApiThemeInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiUserDataFilterInDocument} jsonApiUserDataFilterInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUserDataFilters: async (workspaceId, objectId, jsonApiUserDataFilterInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityUserDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityUserDataFilters", "objectId", objectId);
            // verify required parameter 'jsonApiUserDataFilterInDocument' is not null or undefined
            assertParamExists("updateEntityUserDataFilters", "jsonApiUserDataFilterInDocument", jsonApiUserDataFilterInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/userDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserDataFilterInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserDataFilterInDocument !== undefined ? jsonApiUserDataFilterInDocument : {})
                : jsonApiUserDataFilterInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Put UserGroup entity
         * @param {string} id
         * @param {JsonApiUserGroupInDocument} jsonApiUserGroupInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUserGroups: async (id, jsonApiUserGroupInDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityUserGroups", "id", id);
            // verify required parameter 'jsonApiUserGroupInDocument' is not null or undefined
            assertParamExists("updateEntityUserGroups", "jsonApiUserGroupInDocument", jsonApiUserGroupInDocument);
            const localVarPath = `/api/v1/entities/userGroups/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserGroupInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserGroupInDocument !== undefined ? jsonApiUserGroupInDocument : {})
                : jsonApiUserGroupInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put new user settings for the user
         * @param {string} userId
         * @param {string} id
         * @param {JsonApiUserSettingInDocument} jsonApiUserSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUserSettings: async (userId, id, jsonApiUserSettingInDocument, filter, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("updateEntityUserSettings", "userId", userId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityUserSettings", "id", id);
            // verify required parameter 'jsonApiUserSettingInDocument' is not null or undefined
            assertParamExists("updateEntityUserSettings", "jsonApiUserSettingInDocument", jsonApiUserSettingInDocument);
            const localVarPath = `/api/v1/entities/users/{userId}/userSettings/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserSettingInDocument !== undefined ? jsonApiUserSettingInDocument : {})
                : jsonApiUserSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User - represents entity interacting with platform
         * @summary Put User entity
         * @param {string} id
         * @param {JsonApiUserInDocument} jsonApiUserInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUsers: async (id, jsonApiUserInDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityUsers", "id", id);
            // verify required parameter 'jsonApiUserInDocument' is not null or undefined
            assertParamExists("updateEntityUsers", "jsonApiUserInDocument", jsonApiUserInDocument);
            const localVarPath = `/api/v1/entities/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserInDocument !== undefined ? jsonApiUserInDocument : {})
                : jsonApiUserInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiVisualizationObjectInDocument} jsonApiVisualizationObjectInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityVisualizationObjects: async (workspaceId, objectId, jsonApiVisualizationObjectInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityVisualizationObjects", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityVisualizationObjects", "objectId", objectId);
            // verify required parameter 'jsonApiVisualizationObjectInDocument' is not null or undefined
            assertParamExists("updateEntityVisualizationObjects", "jsonApiVisualizationObjectInDocument", jsonApiVisualizationObjectInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/visualizationObjects/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiVisualizationObjectInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiVisualizationObjectInDocument !== undefined
                    ? jsonApiVisualizationObjectInDocument
                    : {})
                : jsonApiVisualizationObjectInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Settings for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterSettingInDocument} jsonApiWorkspaceDataFilterSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaceDataFilterSettings: async (workspaceId, objectId, jsonApiWorkspaceDataFilterSettingInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityWorkspaceDataFilterSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityWorkspaceDataFilterSettings", "objectId", objectId);
            // verify required parameter 'jsonApiWorkspaceDataFilterSettingInDocument' is not null or undefined
            assertParamExists("updateEntityWorkspaceDataFilterSettings", "jsonApiWorkspaceDataFilterSettingInDocument", jsonApiWorkspaceDataFilterSettingInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilterSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceDataFilterSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceDataFilterSettingInDocument !== undefined
                    ? jsonApiWorkspaceDataFilterSettingInDocument
                    : {})
                : jsonApiWorkspaceDataFilterSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterInDocument} jsonApiWorkspaceDataFilterInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaceDataFilters: async (workspaceId, objectId, jsonApiWorkspaceDataFilterInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityWorkspaceDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityWorkspaceDataFilters", "objectId", objectId);
            // verify required parameter 'jsonApiWorkspaceDataFilterInDocument' is not null or undefined
            assertParamExists("updateEntityWorkspaceDataFilters", "jsonApiWorkspaceDataFilterInDocument", jsonApiWorkspaceDataFilterInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceDataFilterInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceDataFilterInDocument !== undefined
                    ? jsonApiWorkspaceDataFilterInDocument
                    : {})
                : jsonApiWorkspaceDataFilterInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Setting for a Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceSettingInDocument} jsonApiWorkspaceSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaceSettings: async (workspaceId, objectId, jsonApiWorkspaceSettingInDocument, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityWorkspaceSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityWorkspaceSettings", "objectId", objectId);
            // verify required parameter 'jsonApiWorkspaceSettingInDocument' is not null or undefined
            assertParamExists("updateEntityWorkspaceSettings", "jsonApiWorkspaceSettingInDocument", jsonApiWorkspaceSettingInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceSettingInDocument !== undefined
                    ? jsonApiWorkspaceSettingInDocument
                    : {})
                : jsonApiWorkspaceSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Space of the shared interest
         * @summary Put Workspace entity
         * @param {string} id
         * @param {JsonApiWorkspaceInDocument} jsonApiWorkspaceInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaces: async (id, jsonApiWorkspaceInDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityWorkspaces", "id", id);
            // verify required parameter 'jsonApiWorkspaceInDocument' is not null or undefined
            assertParamExists("updateEntityWorkspaces", "jsonApiWorkspaceInDocument", jsonApiWorkspaceInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceInDocument !== undefined ? jsonApiWorkspaceInDocument : {})
                : jsonApiWorkspaceInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * EntitiesApi - functional programming interface
 * @export
 */
export const EntitiesApiFp = function (configuration) {
    const localVarAxiosParamCreator = EntitiesApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Post Dashboards
         * @param {string} workspaceId
         * @param {JsonApiAnalyticalDashboardPostOptionalIdDocument} jsonApiAnalyticalDashboardPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'permissions' | 'origin' | 'accessInfo' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityAnalyticalDashboards(workspaceId, jsonApiAnalyticalDashboardPostOptionalIdDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityAnalyticalDashboards(workspaceId, jsonApiAnalyticalDashboardPostOptionalIdDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post a new API token for the user
         * @param {string} userId
         * @param {JsonApiApiTokenInDocument} jsonApiApiTokenInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityApiTokens(userId, jsonApiApiTokenInDocument, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityApiTokens(userId, jsonApiApiTokenInDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Attribute Hierarchies
         * @param {string} workspaceId
         * @param {JsonApiAttributeHierarchyInDocument} jsonApiAttributeHierarchyInDocument
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityAttributeHierarchies(workspaceId, jsonApiAttributeHierarchyInDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityAttributeHierarchies(workspaceId, jsonApiAttributeHierarchyInDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Color Pallettes
         * @param {JsonApiColorPaletteInDocument} jsonApiColorPaletteInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityColorPalettes(jsonApiColorPaletteInDocument, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityColorPalettes(jsonApiColorPaletteInDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Context Security Police Directive
         * @summary Post CSP Directives
         * @param {JsonApiCspDirectiveInDocument} jsonApiCspDirectiveInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityCspDirectives(jsonApiCspDirectiveInDocument, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityCspDirectives(jsonApiCspDirectiveInDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Custom Application Settings
         * @param {string} workspaceId
         * @param {JsonApiCustomApplicationSettingPostOptionalIdDocument} jsonApiCustomApplicationSettingPostOptionalIdDocument
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityCustomApplicationSettings(workspaceId, jsonApiCustomApplicationSettingPostOptionalIdDocument, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityCustomApplicationSettings(workspaceId, jsonApiCustomApplicationSettingPostOptionalIdDocument, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Plugins
         * @param {string} workspaceId
         * @param {JsonApiDashboardPluginPostOptionalIdDocument} jsonApiDashboardPluginPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityDashboardPlugins(workspaceId, jsonApiDashboardPluginPostOptionalIdDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityDashboardPlugins(workspaceId, jsonApiDashboardPluginPostOptionalIdDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Post Data Sources
         * @param {JsonApiDataSourceInDocument} jsonApiDataSourceInDocument
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityDataSources(jsonApiDataSourceInDocument, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityDataSources(jsonApiDataSourceInDocument, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Context Filters
         * @param {string} workspaceId
         * @param {JsonApiFilterContextPostOptionalIdDocument} jsonApiFilterContextPostOptionalIdDocument
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityFilterContexts(workspaceId, jsonApiFilterContextPostOptionalIdDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityFilterContexts(workspaceId, jsonApiFilterContextPostOptionalIdDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Post Jwks
         * @param {JsonApiJwkInDocument} jsonApiJwkInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityJwks(jsonApiJwkInDocument, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityJwks(jsonApiJwkInDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Metrics
         * @param {string} workspaceId
         * @param {JsonApiMetricPostOptionalIdDocument} jsonApiMetricPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityMetrics(workspaceId, jsonApiMetricPostOptionalIdDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityMetrics(workspaceId, jsonApiMetricPostOptionalIdDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Organization Setting entities
         * @param {JsonApiOrganizationSettingInDocument} jsonApiOrganizationSettingInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityOrganizationSettings(jsonApiOrganizationSettingInDocument, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityOrganizationSettings(jsonApiOrganizationSettingInDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Theming
         * @param {JsonApiThemeInDocument} jsonApiThemeInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityThemes(jsonApiThemeInDocument, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityThemes(jsonApiThemeInDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post User Data Filters
         * @param {string} workspaceId
         * @param {JsonApiUserDataFilterPostOptionalIdDocument} jsonApiUserDataFilterPostOptionalIdDocument
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityUserDataFilters(workspaceId, jsonApiUserDataFilterPostOptionalIdDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityUserDataFilters(workspaceId, jsonApiUserDataFilterPostOptionalIdDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Post User Group entities
         * @param {JsonApiUserGroupInDocument} jsonApiUserGroupInDocument
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityUserGroups(jsonApiUserGroupInDocument, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityUserGroups(jsonApiUserGroupInDocument, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post new user settings for the user
         * @param {string} userId
         * @param {JsonApiUserSettingInDocument} jsonApiUserSettingInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityUserSettings(userId, jsonApiUserSettingInDocument, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityUserSettings(userId, jsonApiUserSettingInDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User - represents entity interacting with platform
         * @summary Post User entities
         * @param {JsonApiUserInDocument} jsonApiUserInDocument
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityUsers(jsonApiUserInDocument, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityUsers(jsonApiUserInDocument, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Visualization Objects
         * @param {string} workspaceId
         * @param {JsonApiVisualizationObjectPostOptionalIdDocument} jsonApiVisualizationObjectPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityVisualizationObjects(workspaceId, jsonApiVisualizationObjectPostOptionalIdDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityVisualizationObjects(workspaceId, jsonApiVisualizationObjectPostOptionalIdDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Settings for Workspace Data Filters
         * @param {string} workspaceId
         * @param {JsonApiWorkspaceDataFilterSettingInDocument} jsonApiWorkspaceDataFilterSettingInDocument
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityWorkspaceDataFilterSettings(workspaceId, jsonApiWorkspaceDataFilterSettingInDocument, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityWorkspaceDataFilterSettings(workspaceId, jsonApiWorkspaceDataFilterSettingInDocument, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Workspace Data Filters
         * @param {string} workspaceId
         * @param {JsonApiWorkspaceDataFilterInDocument} jsonApiWorkspaceDataFilterInDocument
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityWorkspaceDataFilters(workspaceId, jsonApiWorkspaceDataFilterInDocument, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityWorkspaceDataFilters(workspaceId, jsonApiWorkspaceDataFilterInDocument, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Settings for Workspaces
         * @param {string} workspaceId
         * @param {JsonApiWorkspaceSettingPostOptionalIdDocument} jsonApiWorkspaceSettingPostOptionalIdDocument
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityWorkspaceSettings(workspaceId, jsonApiWorkspaceSettingPostOptionalIdDocument, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityWorkspaceSettings(workspaceId, jsonApiWorkspaceSettingPostOptionalIdDocument, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Space of the shared interest
         * @summary Post Workspace entities
         * @param {JsonApiWorkspaceInDocument} jsonApiWorkspaceInDocument
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityWorkspaces(jsonApiWorkspaceInDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityWorkspaces(jsonApiWorkspaceInDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Dashboard
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityAnalyticalDashboards(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityAnalyticalDashboards(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete an API Token for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityApiTokens(userId, id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityApiTokens(userId, id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityAttributeHierarchies(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityAttributeHierarchies(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Color Pallette
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityColorPalettes(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityColorPalettes(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Context Security Police Directive
         * @summary Delete CSP Directives
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityCspDirectives(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityCspDirectives(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityCustomApplicationSettings(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityCustomApplicationSettings(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityDashboardPlugins(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityDashboardPlugins(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Delete Data Source entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityDataSources(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityDataSources(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityFilterContexts(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityFilterContexts(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Delete Jwk
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityJwks(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityJwks(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityMetrics(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityMetrics(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete Organization entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityOrganizationSettings(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityOrganizationSettings(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete Theming
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityThemes(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityThemes(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityUserDataFilters(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityUserDataFilters(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Delete UserGroup entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityUserGroups(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityUserGroups(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a setting for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityUserSettings(userId, id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityUserSettings(userId, id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User - represents entity interacting with platform
         * @summary Delete User entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityUsers(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityUsers(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityVisualizationObjects(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityVisualizationObjects(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Settings for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityWorkspaceDataFilterSettings(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityWorkspaceDataFilterSettings(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityWorkspaceDataFilters(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityWorkspaceDataFilters(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Setting for Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityWorkspaceSettings(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityWorkspaceSettings(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Space of the shared interest
         * @summary Delete Workspace entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityWorkspaces(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityWorkspaces(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Dashboards
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'permissions' | 'origin' | 'accessInfo' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesAnalyticalDashboards(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesAnalyticalDashboards(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary List all api tokens for a user
         * @param {string} userId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesApiTokens(userId, filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesApiTokens(userId, filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Attribute Hierarchies
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesAttributeHierarchies(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesAttributeHierarchies(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Attributes
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'labels' | 'attributeHierarchies' | 'dataset' | 'defaultView' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesAttributes(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesAttributes(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Color Pallettes
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesColorPalettes(filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesColorPalettes(filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Context Security Police Directive
         * @summary Get CSP Directives
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesCspDirectives(filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesCspDirectives(filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Custom Application Settings
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesCustomApplicationSettings(workspaceId, origin, filter, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesCustomApplicationSettings(workspaceId, origin, filter, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Plugins
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesDashboardPlugins(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesDashboardPlugins(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Data Source Identifiers
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesDataSourceIdentifiers(filter, page, size, sort, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesDataSourceIdentifiers(filter, page, size, sort, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} dataSourceId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesDataSourceTables(dataSourceId, filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesDataSourceTables(dataSourceId, filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Get Data Source entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesDataSources(filter, page, size, sort, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesDataSources(filter, page, size, sort, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Datasets
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'facts' | 'datasets' | 'workspaceDataFilters' | 'references' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesDatasets(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesDatasets(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Space of the shared interest
         * @summary Get Entitlements
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesEntitlements(filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesEntitlements(filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Facts
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'dataset' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesFacts(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesFacts(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Context Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesFilterContexts(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesFilterContexts(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all JSON web keys - used to verify JSON web tokens (Jwts)
         * @summary Get all Jwks
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesJwks(filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesJwks(filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Labels
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'attribute' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesLabels(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesLabels(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Metrics
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesMetrics(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesMetrics(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Organization entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesOrganizationSettings(filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesOrganizationSettings(filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Theming entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesThemes(filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesThemes(filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all User Data Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesUserDataFilters(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesUserDataFilters(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Get UserGroup entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesUserGroups(filter, include, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesUserGroups(filter, include, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * UserIdentifier - represents entity interacting with platform
         * @summary Get UserIdentifier entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesUserIdentifiers(filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesUserIdentifiers(filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary List all settings for a user
         * @param {string} userId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesUserSettings(userId, filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesUserSettings(userId, filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User - represents entity interacting with platform
         * @summary Get User entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesUsers(filter, include, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesUsers(filter, include, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Visualization Objects
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesVisualizationObjects(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesVisualizationObjects(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Settings for Workspace Data Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesWorkspaceDataFilterSettings(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesWorkspaceDataFilterSettings(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Workspace Data Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesWorkspaceDataFilters(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesWorkspaceDataFilters(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Setting for Workspaces
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesWorkspaceSettings(workspaceId, origin, filter, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesWorkspaceSettings(workspaceId, origin, filter, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Space of the shared interest
         * @summary Get Workspace entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesWorkspaces(filter, include, page, size, sort, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesWorkspaces(filter, include, page, size, sort, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves links for all options for different configurations.
         * @summary Links for all configuration options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOptions(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of all supported data sources along with information about the used drivers.
         * @summary Get all available data source drivers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataSourceDrivers(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataSourceDrivers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Dashboard
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'permissions' | 'origin' | 'accessInfo' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityAnalyticalDashboards(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityAnalyticalDashboards(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get an API Token for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityApiTokens(userId, id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityApiTokens(userId, id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityAttributeHierarchies(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityAttributeHierarchies(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get an Attribute
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'labels' | 'attributeHierarchies' | 'dataset' | 'defaultView' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityAttributes(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityAttributes(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Color Pallette
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityColorPalettes(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityColorPalettes(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get CookieSecurityConfiguration
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityCookieSecurityConfigurations(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityCookieSecurityConfigurations(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Context Security Police Directive
         * @summary Get CSP Directives
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityCspDirectives(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityCspDirectives(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityCustomApplicationSettings(workspaceId, objectId, filter, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityCustomApplicationSettings(workspaceId, objectId, filter, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityDashboardPlugins(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityDashboardPlugins(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Data Source Identifier
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityDataSourceIdentifiers(id, filter, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityDataSourceIdentifiers(id, filter, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} dataSourceId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityDataSourceTables(dataSourceId, id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityDataSourceTables(dataSourceId, id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Get Data Source entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityDataSources(id, filter, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityDataSources(id, filter, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Dataset
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'facts' | 'datasets' | 'workspaceDataFilters' | 'references' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityDatasets(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityDatasets(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Space of the shared interest
         * @summary Get Entitlement
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityEntitlements(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityEntitlements(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Fact
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'dataset' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityFacts(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityFacts(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityFilterContexts(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityFilterContexts(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Get Jwk
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityJwks(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityJwks(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Label
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'attribute' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityLabels(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityLabels(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityMetrics(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityMetrics(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Organization entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityOrganizationSettings(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityOrganizationSettings(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Organizations
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityOrganizations(id, filter, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityOrganizations(id, filter, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Theming
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityThemes(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityThemes(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityUserDataFilters(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityUserDataFilters(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Get UserGroup entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityUserGroups(id, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityUserGroups(id, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * UserIdentifier - represents basic informationZ about entity interacting with platform
         * @summary Get UserIdentifier entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityUserIdentifiers(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityUserIdentifiers(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a setting for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityUserSettings(userId, id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityUserSettings(userId, id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User - represents entity interacting with platform
         * @summary Get User entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityUsers(id, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityUsers(id, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityVisualizationObjects(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityVisualizationObjects(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Setting for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityWorkspaceDataFilterSettings(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityWorkspaceDataFilterSettings(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityWorkspaceDataFilters(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityWorkspaceDataFilters(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Setting for Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityWorkspaceSettings(workspaceId, objectId, filter, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityWorkspaceSettings(workspaceId, objectId, filter, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Space of the shared interest
         * @summary Get Workspace entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityWorkspaces(id, filter, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityWorkspaces(id, filter, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a basic information about organization.
         * @summary Get current organization info
         * @param {Array<'permissions' | 'all'>} [metaInclude] Return list of permissions available to logged user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganization(metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganization(metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Dashboard
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAnalyticalDashboardPatchDocument} jsonApiAnalyticalDashboardPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityAnalyticalDashboards(workspaceId, objectId, jsonApiAnalyticalDashboardPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityAnalyticalDashboards(workspaceId, objectId, jsonApiAnalyticalDashboardPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAttributeHierarchyPatchDocument} jsonApiAttributeHierarchyPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityAttributeHierarchies(workspaceId, objectId, jsonApiAttributeHierarchyPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityAttributeHierarchies(workspaceId, objectId, jsonApiAttributeHierarchyPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch Color Pallette
         * @param {string} id
         * @param {JsonApiColorPalettePatchDocument} jsonApiColorPalettePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityColorPalettes(id, jsonApiColorPalettePatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityColorPalettes(id, jsonApiColorPalettePatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch CookieSecurityConfiguration
         * @param {string} id
         * @param {JsonApiCookieSecurityConfigurationPatchDocument} jsonApiCookieSecurityConfigurationPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityCookieSecurityConfigurations(id, jsonApiCookieSecurityConfigurationPatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityCookieSecurityConfigurations(id, jsonApiCookieSecurityConfigurationPatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Context Security Police Directive
         * @summary Patch CSP Directives
         * @param {string} id
         * @param {JsonApiCspDirectivePatchDocument} jsonApiCspDirectivePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityCspDirectives(id, jsonApiCspDirectivePatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityCspDirectives(id, jsonApiCspDirectivePatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiCustomApplicationSettingPatchDocument} jsonApiCustomApplicationSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityCustomApplicationSettings(workspaceId, objectId, jsonApiCustomApplicationSettingPatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityCustomApplicationSettings(workspaceId, objectId, jsonApiCustomApplicationSettingPatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiDashboardPluginPatchDocument} jsonApiDashboardPluginPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityDashboardPlugins(workspaceId, objectId, jsonApiDashboardPluginPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityDashboardPlugins(workspaceId, objectId, jsonApiDashboardPluginPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Patch Data Source entity
         * @param {string} id
         * @param {JsonApiDataSourcePatchDocument} jsonApiDataSourcePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityDataSources(id, jsonApiDataSourcePatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityDataSources(id, jsonApiDataSourcePatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiFilterContextPatchDocument} jsonApiFilterContextPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityFilterContexts(workspaceId, objectId, jsonApiFilterContextPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityFilterContexts(workspaceId, objectId, jsonApiFilterContextPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Patches JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Patch Jwk
         * @param {string} id
         * @param {JsonApiJwkPatchDocument} jsonApiJwkPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityJwks(id, jsonApiJwkPatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityJwks(id, jsonApiJwkPatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiMetricPatchDocument} jsonApiMetricPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityMetrics(workspaceId, objectId, jsonApiMetricPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityMetrics(workspaceId, objectId, jsonApiMetricPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch Organization entity
         * @param {string} id
         * @param {JsonApiOrganizationSettingPatchDocument} jsonApiOrganizationSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityOrganizationSettings(id, jsonApiOrganizationSettingPatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityOrganizationSettings(id, jsonApiOrganizationSettingPatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch Organization
         * @param {string} id
         * @param {JsonApiOrganizationPatchDocument} jsonApiOrganizationPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityOrganizations(id, jsonApiOrganizationPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityOrganizations(id, jsonApiOrganizationPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch Theming
         * @param {string} id
         * @param {JsonApiThemePatchDocument} jsonApiThemePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityThemes(id, jsonApiThemePatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityThemes(id, jsonApiThemePatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiUserDataFilterPatchDocument} jsonApiUserDataFilterPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityUserDataFilters(workspaceId, objectId, jsonApiUserDataFilterPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityUserDataFilters(workspaceId, objectId, jsonApiUserDataFilterPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Patch UserGroup entity
         * @param {string} id
         * @param {JsonApiUserGroupPatchDocument} jsonApiUserGroupPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityUserGroups(id, jsonApiUserGroupPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityUserGroups(id, jsonApiUserGroupPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User - represents entity interacting with platform
         * @summary Patch User entity
         * @param {string} id
         * @param {JsonApiUserPatchDocument} jsonApiUserPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityUsers(id, jsonApiUserPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityUsers(id, jsonApiUserPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiVisualizationObjectPatchDocument} jsonApiVisualizationObjectPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityVisualizationObjects(workspaceId, objectId, jsonApiVisualizationObjectPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityVisualizationObjects(workspaceId, objectId, jsonApiVisualizationObjectPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Settings for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterSettingPatchDocument} jsonApiWorkspaceDataFilterSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityWorkspaceDataFilterSettings(workspaceId, objectId, jsonApiWorkspaceDataFilterSettingPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityWorkspaceDataFilterSettings(workspaceId, objectId, jsonApiWorkspaceDataFilterSettingPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterPatchDocument} jsonApiWorkspaceDataFilterPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityWorkspaceDataFilters(workspaceId, objectId, jsonApiWorkspaceDataFilterPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityWorkspaceDataFilters(workspaceId, objectId, jsonApiWorkspaceDataFilterPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Setting for Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceSettingPatchDocument} jsonApiWorkspaceSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityWorkspaceSettings(workspaceId, objectId, jsonApiWorkspaceSettingPatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityWorkspaceSettings(workspaceId, objectId, jsonApiWorkspaceSettingPatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Space of the shared interest
         * @summary Patch Workspace entity
         * @param {string} id
         * @param {JsonApiWorkspacePatchDocument} jsonApiWorkspacePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityWorkspaces(id, jsonApiWorkspacePatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityWorkspaces(id, jsonApiWorkspacePatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put Dashboards
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAnalyticalDashboardInDocument} jsonApiAnalyticalDashboardInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityAnalyticalDashboards(workspaceId, objectId, jsonApiAnalyticalDashboardInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityAnalyticalDashboards(workspaceId, objectId, jsonApiAnalyticalDashboardInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put new API token for the user
         * @param {string} userId
         * @param {string} id
         * @param {JsonApiApiTokenInDocument} jsonApiApiTokenInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityApiTokens(userId, id, jsonApiApiTokenInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityApiTokens(userId, id, jsonApiApiTokenInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAttributeHierarchyInDocument} jsonApiAttributeHierarchyInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityAttributeHierarchies(workspaceId, objectId, jsonApiAttributeHierarchyInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityAttributeHierarchies(workspaceId, objectId, jsonApiAttributeHierarchyInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put Color Pallette
         * @param {string} id
         * @param {JsonApiColorPaletteInDocument} jsonApiColorPaletteInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityColorPalettes(id, jsonApiColorPaletteInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityColorPalettes(id, jsonApiColorPaletteInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put CookieSecurityConfiguration
         * @param {string} id
         * @param {JsonApiCookieSecurityConfigurationInDocument} jsonApiCookieSecurityConfigurationInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityCookieSecurityConfigurations(id, jsonApiCookieSecurityConfigurationInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityCookieSecurityConfigurations(id, jsonApiCookieSecurityConfigurationInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Context Security Police Directive
         * @summary Put CSP Directives
         * @param {string} id
         * @param {JsonApiCspDirectiveInDocument} jsonApiCspDirectiveInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityCspDirectives(id, jsonApiCspDirectiveInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityCspDirectives(id, jsonApiCspDirectiveInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiCustomApplicationSettingInDocument} jsonApiCustomApplicationSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityCustomApplicationSettings(workspaceId, objectId, jsonApiCustomApplicationSettingInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityCustomApplicationSettings(workspaceId, objectId, jsonApiCustomApplicationSettingInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiDashboardPluginInDocument} jsonApiDashboardPluginInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityDashboardPlugins(workspaceId, objectId, jsonApiDashboardPluginInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityDashboardPlugins(workspaceId, objectId, jsonApiDashboardPluginInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Put Data Source entity
         * @param {string} id
         * @param {JsonApiDataSourceInDocument} jsonApiDataSourceInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityDataSources(id, jsonApiDataSourceInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityDataSources(id, jsonApiDataSourceInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiFilterContextInDocument} jsonApiFilterContextInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityFilterContexts(workspaceId, objectId, jsonApiFilterContextInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityFilterContexts(workspaceId, objectId, jsonApiFilterContextInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Put Jwk
         * @param {string} id
         * @param {JsonApiJwkInDocument} jsonApiJwkInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityJwks(id, jsonApiJwkInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityJwks(id, jsonApiJwkInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiMetricInDocument} jsonApiMetricInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityMetrics(workspaceId, objectId, jsonApiMetricInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityMetrics(workspaceId, objectId, jsonApiMetricInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put Organization entity
         * @param {string} id
         * @param {JsonApiOrganizationSettingInDocument} jsonApiOrganizationSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityOrganizationSettings(id, jsonApiOrganizationSettingInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityOrganizationSettings(id, jsonApiOrganizationSettingInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put Organization
         * @param {string} id
         * @param {JsonApiOrganizationInDocument} jsonApiOrganizationInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityOrganizations(id, jsonApiOrganizationInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityOrganizations(id, jsonApiOrganizationInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put Theming
         * @param {string} id
         * @param {JsonApiThemeInDocument} jsonApiThemeInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityThemes(id, jsonApiThemeInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityThemes(id, jsonApiThemeInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiUserDataFilterInDocument} jsonApiUserDataFilterInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityUserDataFilters(workspaceId, objectId, jsonApiUserDataFilterInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityUserDataFilters(workspaceId, objectId, jsonApiUserDataFilterInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Put UserGroup entity
         * @param {string} id
         * @param {JsonApiUserGroupInDocument} jsonApiUserGroupInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityUserGroups(id, jsonApiUserGroupInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityUserGroups(id, jsonApiUserGroupInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put new user settings for the user
         * @param {string} userId
         * @param {string} id
         * @param {JsonApiUserSettingInDocument} jsonApiUserSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityUserSettings(userId, id, jsonApiUserSettingInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityUserSettings(userId, id, jsonApiUserSettingInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User - represents entity interacting with platform
         * @summary Put User entity
         * @param {string} id
         * @param {JsonApiUserInDocument} jsonApiUserInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityUsers(id, jsonApiUserInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityUsers(id, jsonApiUserInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiVisualizationObjectInDocument} jsonApiVisualizationObjectInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityVisualizationObjects(workspaceId, objectId, jsonApiVisualizationObjectInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityVisualizationObjects(workspaceId, objectId, jsonApiVisualizationObjectInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Settings for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterSettingInDocument} jsonApiWorkspaceDataFilterSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityWorkspaceDataFilterSettings(workspaceId, objectId, jsonApiWorkspaceDataFilterSettingInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityWorkspaceDataFilterSettings(workspaceId, objectId, jsonApiWorkspaceDataFilterSettingInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterInDocument} jsonApiWorkspaceDataFilterInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityWorkspaceDataFilters(workspaceId, objectId, jsonApiWorkspaceDataFilterInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityWorkspaceDataFilters(workspaceId, objectId, jsonApiWorkspaceDataFilterInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Setting for a Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceSettingInDocument} jsonApiWorkspaceSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityWorkspaceSettings(workspaceId, objectId, jsonApiWorkspaceSettingInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityWorkspaceSettings(workspaceId, objectId, jsonApiWorkspaceSettingInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Space of the shared interest
         * @summary Put Workspace entity
         * @param {string} id
         * @param {JsonApiWorkspaceInDocument} jsonApiWorkspaceInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityWorkspaces(id, jsonApiWorkspaceInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityWorkspaces(id, jsonApiWorkspaceInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * EntitiesApi - factory interface
 * @export
 */
export const EntitiesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = EntitiesApiFp(configuration);
    return {
        /**
         *
         * @summary Post Dashboards
         * @param {EntitiesApiCreateEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityAnalyticalDashboards(requestParameters, options) {
            return localVarFp
                .createEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.jsonApiAnalyticalDashboardPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post a new API token for the user
         * @param {EntitiesApiCreateEntityApiTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityApiTokens(requestParameters, options) {
            return localVarFp
                .createEntityApiTokens(requestParameters.userId, requestParameters.jsonApiApiTokenInDocument, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Attribute Hierarchies
         * @param {EntitiesApiCreateEntityAttributeHierarchiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityAttributeHierarchies(requestParameters, options) {
            return localVarFp
                .createEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.jsonApiAttributeHierarchyInDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Color Pallettes
         * @param {EntitiesApiCreateEntityColorPalettesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityColorPalettes(requestParameters, options) {
            return localVarFp
                .createEntityColorPalettes(requestParameters.jsonApiColorPaletteInDocument, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *  Context Security Police Directive
         * @summary Post CSP Directives
         * @param {EntitiesApiCreateEntityCspDirectivesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityCspDirectives(requestParameters, options) {
            return localVarFp
                .createEntityCspDirectives(requestParameters.jsonApiCspDirectiveInDocument, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Custom Application Settings
         * @param {EntitiesApiCreateEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityCustomApplicationSettings(requestParameters, options) {
            return localVarFp
                .createEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.jsonApiCustomApplicationSettingPostOptionalIdDocument, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Plugins
         * @param {EntitiesApiCreateEntityDashboardPluginsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityDashboardPlugins(requestParameters, options) {
            return localVarFp
                .createEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.jsonApiDashboardPluginPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Post Data Sources
         * @param {EntitiesApiCreateEntityDataSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityDataSources(requestParameters, options) {
            return localVarFp
                .createEntityDataSources(requestParameters.jsonApiDataSourceInDocument, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Context Filters
         * @param {EntitiesApiCreateEntityFilterContextsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityFilterContexts(requestParameters, options) {
            return localVarFp
                .createEntityFilterContexts(requestParameters.workspaceId, requestParameters.jsonApiFilterContextPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Creates JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Post Jwks
         * @param {EntitiesApiCreateEntityJwksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityJwks(requestParameters, options) {
            return localVarFp
                .createEntityJwks(requestParameters.jsonApiJwkInDocument, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Metrics
         * @param {EntitiesApiCreateEntityMetricsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityMetrics(requestParameters, options) {
            return localVarFp
                .createEntityMetrics(requestParameters.workspaceId, requestParameters.jsonApiMetricPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Organization Setting entities
         * @param {EntitiesApiCreateEntityOrganizationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityOrganizationSettings(requestParameters, options) {
            return localVarFp
                .createEntityOrganizationSettings(requestParameters.jsonApiOrganizationSettingInDocument, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Theming
         * @param {EntitiesApiCreateEntityThemesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityThemes(requestParameters, options) {
            return localVarFp
                .createEntityThemes(requestParameters.jsonApiThemeInDocument, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post User Data Filters
         * @param {EntitiesApiCreateEntityUserDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUserDataFilters(requestParameters, options) {
            return localVarFp
                .createEntityUserDataFilters(requestParameters.workspaceId, requestParameters.jsonApiUserDataFilterPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Post User Group entities
         * @param {EntitiesApiCreateEntityUserGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUserGroups(requestParameters, options) {
            return localVarFp
                .createEntityUserGroups(requestParameters.jsonApiUserGroupInDocument, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post new user settings for the user
         * @param {EntitiesApiCreateEntityUserSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUserSettings(requestParameters, options) {
            return localVarFp
                .createEntityUserSettings(requestParameters.userId, requestParameters.jsonApiUserSettingInDocument, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User - represents entity interacting with platform
         * @summary Post User entities
         * @param {EntitiesApiCreateEntityUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUsers(requestParameters, options) {
            return localVarFp
                .createEntityUsers(requestParameters.jsonApiUserInDocument, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Visualization Objects
         * @param {EntitiesApiCreateEntityVisualizationObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityVisualizationObjects(requestParameters, options) {
            return localVarFp
                .createEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.jsonApiVisualizationObjectPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Settings for Workspace Data Filters
         * @param {EntitiesApiCreateEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaceDataFilterSettings(requestParameters, options) {
            return localVarFp
                .createEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.jsonApiWorkspaceDataFilterSettingInDocument, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Workspace Data Filters
         * @param {EntitiesApiCreateEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaceDataFilters(requestParameters, options) {
            return localVarFp
                .createEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.jsonApiWorkspaceDataFilterInDocument, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Settings for Workspaces
         * @param {EntitiesApiCreateEntityWorkspaceSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaceSettings(requestParameters, options) {
            return localVarFp
                .createEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.jsonApiWorkspaceSettingPostOptionalIdDocument, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Space of the shared interest
         * @summary Post Workspace entities
         * @param {EntitiesApiCreateEntityWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaces(requestParameters, options) {
            return localVarFp
                .createEntityWorkspaces(requestParameters.jsonApiWorkspaceInDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Dashboard
         * @param {EntitiesApiDeleteEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityAnalyticalDashboards(requestParameters, options) {
            return localVarFp
                .deleteEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete an API Token for a user
         * @param {EntitiesApiDeleteEntityApiTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityApiTokens(requestParameters, options) {
            return localVarFp
                .deleteEntityApiTokens(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete an Attribute Hierarchy
         * @param {EntitiesApiDeleteEntityAttributeHierarchiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityAttributeHierarchies(requestParameters, options) {
            return localVarFp
                .deleteEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Color Pallette
         * @param {EntitiesApiDeleteEntityColorPalettesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityColorPalettes(requestParameters, options) {
            return localVarFp
                .deleteEntityColorPalettes(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *  Context Security Police Directive
         * @summary Delete CSP Directives
         * @param {EntitiesApiDeleteEntityCspDirectivesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityCspDirectives(requestParameters, options) {
            return localVarFp
                .deleteEntityCspDirectives(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Custom Application Setting
         * @param {EntitiesApiDeleteEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityCustomApplicationSettings(requestParameters, options) {
            return localVarFp
                .deleteEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Plugin
         * @param {EntitiesApiDeleteEntityDashboardPluginsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityDashboardPlugins(requestParameters, options) {
            return localVarFp
                .deleteEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Delete Data Source entity
         * @param {EntitiesApiDeleteEntityDataSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityDataSources(requestParameters, options) {
            return localVarFp
                .deleteEntityDataSources(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Context Filter
         * @param {EntitiesApiDeleteEntityFilterContextsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityFilterContexts(requestParameters, options) {
            return localVarFp
                .deleteEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Deletes JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Delete Jwk
         * @param {EntitiesApiDeleteEntityJwksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityJwks(requestParameters, options) {
            return localVarFp
                .deleteEntityJwks(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Metric
         * @param {EntitiesApiDeleteEntityMetricsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityMetrics(requestParameters, options) {
            return localVarFp
                .deleteEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete Organization entity
         * @param {EntitiesApiDeleteEntityOrganizationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityOrganizationSettings(requestParameters, options) {
            return localVarFp
                .deleteEntityOrganizationSettings(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete Theming
         * @param {EntitiesApiDeleteEntityThemesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityThemes(requestParameters, options) {
            return localVarFp
                .deleteEntityThemes(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a User Data Filter
         * @param {EntitiesApiDeleteEntityUserDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUserDataFilters(requestParameters, options) {
            return localVarFp
                .deleteEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Delete UserGroup entity
         * @param {EntitiesApiDeleteEntityUserGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUserGroups(requestParameters, options) {
            return localVarFp
                .deleteEntityUserGroups(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a setting for a user
         * @param {EntitiesApiDeleteEntityUserSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUserSettings(requestParameters, options) {
            return localVarFp
                .deleteEntityUserSettings(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User - represents entity interacting with platform
         * @summary Delete User entity
         * @param {EntitiesApiDeleteEntityUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUsers(requestParameters, options) {
            return localVarFp
                .deleteEntityUsers(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Visualization Object
         * @param {EntitiesApiDeleteEntityVisualizationObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityVisualizationObjects(requestParameters, options) {
            return localVarFp
                .deleteEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Settings for Workspace Data Filter
         * @param {EntitiesApiDeleteEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaceDataFilterSettings(requestParameters, options) {
            return localVarFp
                .deleteEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Workspace Data Filter
         * @param {EntitiesApiDeleteEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaceDataFilters(requestParameters, options) {
            return localVarFp
                .deleteEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Setting for Workspace
         * @param {EntitiesApiDeleteEntityWorkspaceSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaceSettings(requestParameters, options) {
            return localVarFp
                .deleteEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Space of the shared interest
         * @summary Delete Workspace entity
         * @param {EntitiesApiDeleteEntityWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaces(requestParameters, options) {
            return localVarFp
                .deleteEntityWorkspaces(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Dashboards
         * @param {EntitiesApiGetAllEntitiesAnalyticalDashboardsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAnalyticalDashboards(requestParameters, options) {
            return localVarFp
                .getAllEntitiesAnalyticalDashboards(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List all api tokens for a user
         * @param {EntitiesApiGetAllEntitiesApiTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesApiTokens(requestParameters, options) {
            return localVarFp
                .getAllEntitiesApiTokens(requestParameters.userId, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Attribute Hierarchies
         * @param {EntitiesApiGetAllEntitiesAttributeHierarchiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAttributeHierarchies(requestParameters, options) {
            return localVarFp
                .getAllEntitiesAttributeHierarchies(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Attributes
         * @param {EntitiesApiGetAllEntitiesAttributesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAttributes(requestParameters, options) {
            return localVarFp
                .getAllEntitiesAttributes(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Color Pallettes
         * @param {EntitiesApiGetAllEntitiesColorPalettesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesColorPalettes(requestParameters, options) {
            return localVarFp
                .getAllEntitiesColorPalettes(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *  Context Security Police Directive
         * @summary Get CSP Directives
         * @param {EntitiesApiGetAllEntitiesCspDirectivesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesCspDirectives(requestParameters, options) {
            return localVarFp
                .getAllEntitiesCspDirectives(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Custom Application Settings
         * @param {EntitiesApiGetAllEntitiesCustomApplicationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesCustomApplicationSettings(requestParameters, options) {
            return localVarFp
                .getAllEntitiesCustomApplicationSettings(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Plugins
         * @param {EntitiesApiGetAllEntitiesDashboardPluginsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDashboardPlugins(requestParameters, options) {
            return localVarFp
                .getAllEntitiesDashboardPlugins(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Data Source Identifiers
         * @param {EntitiesApiGetAllEntitiesDataSourceIdentifiersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSourceIdentifiers(requestParameters, options) {
            return localVarFp
                .getAllEntitiesDataSourceIdentifiers(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {EntitiesApiGetAllEntitiesDataSourceTablesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSourceTables(requestParameters, options) {
            return localVarFp
                .getAllEntitiesDataSourceTables(requestParameters.dataSourceId, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Get Data Source entities
         * @param {EntitiesApiGetAllEntitiesDataSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSources(requestParameters, options) {
            return localVarFp
                .getAllEntitiesDataSources(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Datasets
         * @param {EntitiesApiGetAllEntitiesDatasetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDatasets(requestParameters, options) {
            return localVarFp
                .getAllEntitiesDatasets(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Space of the shared interest
         * @summary Get Entitlements
         * @param {EntitiesApiGetAllEntitiesEntitlementsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesEntitlements(requestParameters, options) {
            return localVarFp
                .getAllEntitiesEntitlements(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Facts
         * @param {EntitiesApiGetAllEntitiesFactsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesFacts(requestParameters, options) {
            return localVarFp
                .getAllEntitiesFacts(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Context Filters
         * @param {EntitiesApiGetAllEntitiesFilterContextsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesFilterContexts(requestParameters, options) {
            return localVarFp
                .getAllEntitiesFilterContexts(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns all JSON web keys - used to verify JSON web tokens (Jwts)
         * @summary Get all Jwks
         * @param {EntitiesApiGetAllEntitiesJwksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesJwks(requestParameters, options) {
            return localVarFp
                .getAllEntitiesJwks(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Labels
         * @param {EntitiesApiGetAllEntitiesLabelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesLabels(requestParameters, options) {
            return localVarFp
                .getAllEntitiesLabels(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Metrics
         * @param {EntitiesApiGetAllEntitiesMetricsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesMetrics(requestParameters, options) {
            return localVarFp
                .getAllEntitiesMetrics(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Organization entities
         * @param {EntitiesApiGetAllEntitiesOrganizationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesOrganizationSettings(requestParameters, options) {
            return localVarFp
                .getAllEntitiesOrganizationSettings(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Theming entities
         * @param {EntitiesApiGetAllEntitiesThemesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesThemes(requestParameters, options) {
            return localVarFp
                .getAllEntitiesThemes(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all User Data Filters
         * @param {EntitiesApiGetAllEntitiesUserDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserDataFilters(requestParameters, options) {
            return localVarFp
                .getAllEntitiesUserDataFilters(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Get UserGroup entities
         * @param {EntitiesApiGetAllEntitiesUserGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserGroups(requestParameters, options) {
            return localVarFp
                .getAllEntitiesUserGroups(requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * UserIdentifier - represents entity interacting with platform
         * @summary Get UserIdentifier entities
         * @param {EntitiesApiGetAllEntitiesUserIdentifiersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserIdentifiers(requestParameters, options) {
            return localVarFp
                .getAllEntitiesUserIdentifiers(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List all settings for a user
         * @param {EntitiesApiGetAllEntitiesUserSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserSettings(requestParameters, options) {
            return localVarFp
                .getAllEntitiesUserSettings(requestParameters.userId, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User - represents entity interacting with platform
         * @summary Get User entities
         * @param {EntitiesApiGetAllEntitiesUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUsers(requestParameters, options) {
            return localVarFp
                .getAllEntitiesUsers(requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Visualization Objects
         * @param {EntitiesApiGetAllEntitiesVisualizationObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesVisualizationObjects(requestParameters, options) {
            return localVarFp
                .getAllEntitiesVisualizationObjects(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Settings for Workspace Data Filters
         * @param {EntitiesApiGetAllEntitiesWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceDataFilterSettings(requestParameters, options) {
            return localVarFp
                .getAllEntitiesWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Workspace Data Filters
         * @param {EntitiesApiGetAllEntitiesWorkspaceDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceDataFilters(requestParameters, options) {
            return localVarFp
                .getAllEntitiesWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Setting for Workspaces
         * @param {EntitiesApiGetAllEntitiesWorkspaceSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceSettings(requestParameters, options) {
            return localVarFp
                .getAllEntitiesWorkspaceSettings(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Space of the shared interest
         * @summary Get Workspace entities
         * @param {EntitiesApiGetAllEntitiesWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaces(requestParameters, options) {
            return localVarFp
                .getAllEntitiesWorkspaces(requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Retrieves links for all options for different configurations.
         * @summary Links for all configuration options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOptions(options) {
            return localVarFp.getAllOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all supported data sources along with information about the used drivers.
         * @summary Get all available data source drivers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceDrivers(options) {
            return localVarFp.getDataSourceDrivers(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Dashboard
         * @param {EntitiesApiGetEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAnalyticalDashboards(requestParameters, options) {
            return localVarFp
                .getEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get an API Token for a user
         * @param {EntitiesApiGetEntityApiTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityApiTokens(requestParameters, options) {
            return localVarFp
                .getEntityApiTokens(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get an Attribute Hierarchy
         * @param {EntitiesApiGetEntityAttributeHierarchiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAttributeHierarchies(requestParameters, options) {
            return localVarFp
                .getEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get an Attribute
         * @param {EntitiesApiGetEntityAttributesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAttributes(requestParameters, options) {
            return localVarFp
                .getEntityAttributes(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Color Pallette
         * @param {EntitiesApiGetEntityColorPalettesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityColorPalettes(requestParameters, options) {
            return localVarFp
                .getEntityColorPalettes(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get CookieSecurityConfiguration
         * @param {EntitiesApiGetEntityCookieSecurityConfigurationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityCookieSecurityConfigurations(requestParameters, options) {
            return localVarFp
                .getEntityCookieSecurityConfigurations(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *  Context Security Police Directive
         * @summary Get CSP Directives
         * @param {EntitiesApiGetEntityCspDirectivesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityCspDirectives(requestParameters, options) {
            return localVarFp
                .getEntityCspDirectives(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Custom Application Setting
         * @param {EntitiesApiGetEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityCustomApplicationSettings(requestParameters, options) {
            return localVarFp
                .getEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Plugin
         * @param {EntitiesApiGetEntityDashboardPluginsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDashboardPlugins(requestParameters, options) {
            return localVarFp
                .getEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Data Source Identifier
         * @param {EntitiesApiGetEntityDataSourceIdentifiersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSourceIdentifiers(requestParameters, options) {
            return localVarFp
                .getEntityDataSourceIdentifiers(requestParameters.id, requestParameters.filter, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {EntitiesApiGetEntityDataSourceTablesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSourceTables(requestParameters, options) {
            return localVarFp
                .getEntityDataSourceTables(requestParameters.dataSourceId, requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Get Data Source entity
         * @param {EntitiesApiGetEntityDataSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSources(requestParameters, options) {
            return localVarFp
                .getEntityDataSources(requestParameters.id, requestParameters.filter, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Dataset
         * @param {EntitiesApiGetEntityDatasetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDatasets(requestParameters, options) {
            return localVarFp
                .getEntityDatasets(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Space of the shared interest
         * @summary Get Entitlement
         * @param {EntitiesApiGetEntityEntitlementsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityEntitlements(requestParameters, options) {
            return localVarFp
                .getEntityEntitlements(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Fact
         * @param {EntitiesApiGetEntityFactsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityFacts(requestParameters, options) {
            return localVarFp
                .getEntityFacts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Context Filter
         * @param {EntitiesApiGetEntityFilterContextsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityFilterContexts(requestParameters, options) {
            return localVarFp
                .getEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Get Jwk
         * @param {EntitiesApiGetEntityJwksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityJwks(requestParameters, options) {
            return localVarFp
                .getEntityJwks(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Label
         * @param {EntitiesApiGetEntityLabelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityLabels(requestParameters, options) {
            return localVarFp
                .getEntityLabels(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Metric
         * @param {EntitiesApiGetEntityMetricsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityMetrics(requestParameters, options) {
            return localVarFp
                .getEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Organization entity
         * @param {EntitiesApiGetEntityOrganizationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityOrganizationSettings(requestParameters, options) {
            return localVarFp
                .getEntityOrganizationSettings(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Organizations
         * @param {EntitiesApiGetEntityOrganizationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityOrganizations(requestParameters, options) {
            return localVarFp
                .getEntityOrganizations(requestParameters.id, requestParameters.filter, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Theming
         * @param {EntitiesApiGetEntityThemesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityThemes(requestParameters, options) {
            return localVarFp
                .getEntityThemes(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a User Data Filter
         * @param {EntitiesApiGetEntityUserDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserDataFilters(requestParameters, options) {
            return localVarFp
                .getEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Get UserGroup entity
         * @param {EntitiesApiGetEntityUserGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserGroups(requestParameters, options) {
            return localVarFp
                .getEntityUserGroups(requestParameters.id, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * UserIdentifier - represents basic informationZ about entity interacting with platform
         * @summary Get UserIdentifier entity
         * @param {EntitiesApiGetEntityUserIdentifiersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserIdentifiers(requestParameters, options) {
            return localVarFp
                .getEntityUserIdentifiers(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a setting for a user
         * @param {EntitiesApiGetEntityUserSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserSettings(requestParameters, options) {
            return localVarFp
                .getEntityUserSettings(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User - represents entity interacting with platform
         * @summary Get User entity
         * @param {EntitiesApiGetEntityUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUsers(requestParameters, options) {
            return localVarFp
                .getEntityUsers(requestParameters.id, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Visualization Object
         * @param {EntitiesApiGetEntityVisualizationObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityVisualizationObjects(requestParameters, options) {
            return localVarFp
                .getEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Setting for Workspace Data Filter
         * @param {EntitiesApiGetEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceDataFilterSettings(requestParameters, options) {
            return localVarFp
                .getEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Workspace Data Filter
         * @param {EntitiesApiGetEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceDataFilters(requestParameters, options) {
            return localVarFp
                .getEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Setting for Workspace
         * @param {EntitiesApiGetEntityWorkspaceSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceSettings(requestParameters, options) {
            return localVarFp
                .getEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Space of the shared interest
         * @summary Get Workspace entity
         * @param {EntitiesApiGetEntityWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaces(requestParameters, options) {
            return localVarFp
                .getEntityWorkspaces(requestParameters.id, requestParameters.filter, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Gets a basic information about organization.
         * @summary Get current organization info
         * @param {EntitiesApiGetOrganizationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(requestParameters, options) {
            return localVarFp
                .getOrganization(requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Dashboard
         * @param {EntitiesApiPatchEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityAnalyticalDashboards(requestParameters, options) {
            return localVarFp
                .patchEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAnalyticalDashboardPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch an Attribute Hierarchy
         * @param {EntitiesApiPatchEntityAttributeHierarchiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityAttributeHierarchies(requestParameters, options) {
            return localVarFp
                .patchEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAttributeHierarchyPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch Color Pallette
         * @param {EntitiesApiPatchEntityColorPalettesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityColorPalettes(requestParameters, options) {
            return localVarFp
                .patchEntityColorPalettes(requestParameters.id, requestParameters.jsonApiColorPalettePatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch CookieSecurityConfiguration
         * @param {EntitiesApiPatchEntityCookieSecurityConfigurationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityCookieSecurityConfigurations(requestParameters, options) {
            return localVarFp
                .patchEntityCookieSecurityConfigurations(requestParameters.id, requestParameters.jsonApiCookieSecurityConfigurationPatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *  Context Security Police Directive
         * @summary Patch CSP Directives
         * @param {EntitiesApiPatchEntityCspDirectivesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityCspDirectives(requestParameters, options) {
            return localVarFp
                .patchEntityCspDirectives(requestParameters.id, requestParameters.jsonApiCspDirectivePatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Custom Application Setting
         * @param {EntitiesApiPatchEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityCustomApplicationSettings(requestParameters, options) {
            return localVarFp
                .patchEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiCustomApplicationSettingPatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Plugin
         * @param {EntitiesApiPatchEntityDashboardPluginsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityDashboardPlugins(requestParameters, options) {
            return localVarFp
                .patchEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiDashboardPluginPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Patch Data Source entity
         * @param {EntitiesApiPatchEntityDataSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityDataSources(requestParameters, options) {
            return localVarFp
                .patchEntityDataSources(requestParameters.id, requestParameters.jsonApiDataSourcePatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Context Filter
         * @param {EntitiesApiPatchEntityFilterContextsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityFilterContexts(requestParameters, options) {
            return localVarFp
                .patchEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiFilterContextPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Patches JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Patch Jwk
         * @param {EntitiesApiPatchEntityJwksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityJwks(requestParameters, options) {
            return localVarFp
                .patchEntityJwks(requestParameters.id, requestParameters.jsonApiJwkPatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Metric
         * @param {EntitiesApiPatchEntityMetricsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityMetrics(requestParameters, options) {
            return localVarFp
                .patchEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiMetricPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch Organization entity
         * @param {EntitiesApiPatchEntityOrganizationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityOrganizationSettings(requestParameters, options) {
            return localVarFp
                .patchEntityOrganizationSettings(requestParameters.id, requestParameters.jsonApiOrganizationSettingPatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch Organization
         * @param {EntitiesApiPatchEntityOrganizationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityOrganizations(requestParameters, options) {
            return localVarFp
                .patchEntityOrganizations(requestParameters.id, requestParameters.jsonApiOrganizationPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch Theming
         * @param {EntitiesApiPatchEntityThemesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityThemes(requestParameters, options) {
            return localVarFp
                .patchEntityThemes(requestParameters.id, requestParameters.jsonApiThemePatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a User Data Filter
         * @param {EntitiesApiPatchEntityUserDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUserDataFilters(requestParameters, options) {
            return localVarFp
                .patchEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiUserDataFilterPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Patch UserGroup entity
         * @param {EntitiesApiPatchEntityUserGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUserGroups(requestParameters, options) {
            return localVarFp
                .patchEntityUserGroups(requestParameters.id, requestParameters.jsonApiUserGroupPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User - represents entity interacting with platform
         * @summary Patch User entity
         * @param {EntitiesApiPatchEntityUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUsers(requestParameters, options) {
            return localVarFp
                .patchEntityUsers(requestParameters.id, requestParameters.jsonApiUserPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Visualization Object
         * @param {EntitiesApiPatchEntityVisualizationObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityVisualizationObjects(requestParameters, options) {
            return localVarFp
                .patchEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiVisualizationObjectPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Settings for Workspace Data Filter
         * @param {EntitiesApiPatchEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaceDataFilterSettings(requestParameters, options) {
            return localVarFp
                .patchEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterSettingPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Workspace Data Filter
         * @param {EntitiesApiPatchEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaceDataFilters(requestParameters, options) {
            return localVarFp
                .patchEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Setting for Workspace
         * @param {EntitiesApiPatchEntityWorkspaceSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaceSettings(requestParameters, options) {
            return localVarFp
                .patchEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceSettingPatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Space of the shared interest
         * @summary Patch Workspace entity
         * @param {EntitiesApiPatchEntityWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaces(requestParameters, options) {
            return localVarFp
                .patchEntityWorkspaces(requestParameters.id, requestParameters.jsonApiWorkspacePatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put Dashboards
         * @param {EntitiesApiUpdateEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityAnalyticalDashboards(requestParameters, options) {
            return localVarFp
                .updateEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAnalyticalDashboardInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put new API token for the user
         * @param {EntitiesApiUpdateEntityApiTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityApiTokens(requestParameters, options) {
            return localVarFp
                .updateEntityApiTokens(requestParameters.userId, requestParameters.id, requestParameters.jsonApiApiTokenInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put an Attribute Hierarchy
         * @param {EntitiesApiUpdateEntityAttributeHierarchiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityAttributeHierarchies(requestParameters, options) {
            return localVarFp
                .updateEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAttributeHierarchyInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put Color Pallette
         * @param {EntitiesApiUpdateEntityColorPalettesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityColorPalettes(requestParameters, options) {
            return localVarFp
                .updateEntityColorPalettes(requestParameters.id, requestParameters.jsonApiColorPaletteInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put CookieSecurityConfiguration
         * @param {EntitiesApiUpdateEntityCookieSecurityConfigurationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityCookieSecurityConfigurations(requestParameters, options) {
            return localVarFp
                .updateEntityCookieSecurityConfigurations(requestParameters.id, requestParameters.jsonApiCookieSecurityConfigurationInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *  Context Security Police Directive
         * @summary Put CSP Directives
         * @param {EntitiesApiUpdateEntityCspDirectivesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityCspDirectives(requestParameters, options) {
            return localVarFp
                .updateEntityCspDirectives(requestParameters.id, requestParameters.jsonApiCspDirectiveInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Custom Application Setting
         * @param {EntitiesApiUpdateEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityCustomApplicationSettings(requestParameters, options) {
            return localVarFp
                .updateEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiCustomApplicationSettingInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Plugin
         * @param {EntitiesApiUpdateEntityDashboardPluginsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityDashboardPlugins(requestParameters, options) {
            return localVarFp
                .updateEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiDashboardPluginInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Put Data Source entity
         * @param {EntitiesApiUpdateEntityDataSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityDataSources(requestParameters, options) {
            return localVarFp
                .updateEntityDataSources(requestParameters.id, requestParameters.jsonApiDataSourceInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Context Filter
         * @param {EntitiesApiUpdateEntityFilterContextsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityFilterContexts(requestParameters, options) {
            return localVarFp
                .updateEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiFilterContextInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Updates JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Put Jwk
         * @param {EntitiesApiUpdateEntityJwksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityJwks(requestParameters, options) {
            return localVarFp
                .updateEntityJwks(requestParameters.id, requestParameters.jsonApiJwkInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Metric
         * @param {EntitiesApiUpdateEntityMetricsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityMetrics(requestParameters, options) {
            return localVarFp
                .updateEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiMetricInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put Organization entity
         * @param {EntitiesApiUpdateEntityOrganizationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityOrganizationSettings(requestParameters, options) {
            return localVarFp
                .updateEntityOrganizationSettings(requestParameters.id, requestParameters.jsonApiOrganizationSettingInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put Organization
         * @param {EntitiesApiUpdateEntityOrganizationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityOrganizations(requestParameters, options) {
            return localVarFp
                .updateEntityOrganizations(requestParameters.id, requestParameters.jsonApiOrganizationInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put Theming
         * @param {EntitiesApiUpdateEntityThemesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityThemes(requestParameters, options) {
            return localVarFp
                .updateEntityThemes(requestParameters.id, requestParameters.jsonApiThemeInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a User Data Filter
         * @param {EntitiesApiUpdateEntityUserDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUserDataFilters(requestParameters, options) {
            return localVarFp
                .updateEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiUserDataFilterInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Put UserGroup entity
         * @param {EntitiesApiUpdateEntityUserGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUserGroups(requestParameters, options) {
            return localVarFp
                .updateEntityUserGroups(requestParameters.id, requestParameters.jsonApiUserGroupInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put new user settings for the user
         * @param {EntitiesApiUpdateEntityUserSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUserSettings(requestParameters, options) {
            return localVarFp
                .updateEntityUserSettings(requestParameters.userId, requestParameters.id, requestParameters.jsonApiUserSettingInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User - represents entity interacting with platform
         * @summary Put User entity
         * @param {EntitiesApiUpdateEntityUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUsers(requestParameters, options) {
            return localVarFp
                .updateEntityUsers(requestParameters.id, requestParameters.jsonApiUserInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Visualization Object
         * @param {EntitiesApiUpdateEntityVisualizationObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityVisualizationObjects(requestParameters, options) {
            return localVarFp
                .updateEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiVisualizationObjectInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Settings for Workspace Data Filter
         * @param {EntitiesApiUpdateEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaceDataFilterSettings(requestParameters, options) {
            return localVarFp
                .updateEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterSettingInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Workspace Data Filter
         * @param {EntitiesApiUpdateEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaceDataFilters(requestParameters, options) {
            return localVarFp
                .updateEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Setting for a Workspace
         * @param {EntitiesApiUpdateEntityWorkspaceSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaceSettings(requestParameters, options) {
            return localVarFp
                .updateEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceSettingInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Space of the shared interest
         * @summary Put Workspace entity
         * @param {EntitiesApiUpdateEntityWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaces(requestParameters, options) {
            return localVarFp
                .updateEntityWorkspaces(requestParameters.id, requestParameters.jsonApiWorkspaceInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * EntitiesApi - object-oriented interface
 * @export
 * @class EntitiesApi
 * @extends {BaseAPI}
 */
export class EntitiesApi extends BaseAPI {
    /**
     *
     * @summary Post Dashboards
     * @param {EntitiesApiCreateEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    createEntityAnalyticalDashboards(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .createEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.jsonApiAnalyticalDashboardPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post a new API token for the user
     * @param {EntitiesApiCreateEntityApiTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    createEntityApiTokens(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .createEntityApiTokens(requestParameters.userId, requestParameters.jsonApiApiTokenInDocument, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Attribute Hierarchies
     * @param {EntitiesApiCreateEntityAttributeHierarchiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    createEntityAttributeHierarchies(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .createEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.jsonApiAttributeHierarchyInDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Color Pallettes
     * @param {EntitiesApiCreateEntityColorPalettesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    createEntityColorPalettes(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .createEntityColorPalettes(requestParameters.jsonApiColorPaletteInDocument, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Context Security Police Directive
     * @summary Post CSP Directives
     * @param {EntitiesApiCreateEntityCspDirectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    createEntityCspDirectives(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .createEntityCspDirectives(requestParameters.jsonApiCspDirectiveInDocument, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Custom Application Settings
     * @param {EntitiesApiCreateEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    createEntityCustomApplicationSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .createEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.jsonApiCustomApplicationSettingPostOptionalIdDocument, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Plugins
     * @param {EntitiesApiCreateEntityDashboardPluginsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    createEntityDashboardPlugins(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .createEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.jsonApiDashboardPluginPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Data Source - represents data source for the workspace
     * @summary Post Data Sources
     * @param {EntitiesApiCreateEntityDataSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    createEntityDataSources(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .createEntityDataSources(requestParameters.jsonApiDataSourceInDocument, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Context Filters
     * @param {EntitiesApiCreateEntityFilterContextsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    createEntityFilterContexts(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .createEntityFilterContexts(requestParameters.workspaceId, requestParameters.jsonApiFilterContextPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates JSON web key - used to verify JSON web tokens (Jwts)
     * @summary Post Jwks
     * @param {EntitiesApiCreateEntityJwksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    createEntityJwks(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .createEntityJwks(requestParameters.jsonApiJwkInDocument, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Metrics
     * @param {EntitiesApiCreateEntityMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    createEntityMetrics(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .createEntityMetrics(requestParameters.workspaceId, requestParameters.jsonApiMetricPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Organization Setting entities
     * @param {EntitiesApiCreateEntityOrganizationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    createEntityOrganizationSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .createEntityOrganizationSettings(requestParameters.jsonApiOrganizationSettingInDocument, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Theming
     * @param {EntitiesApiCreateEntityThemesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    createEntityThemes(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .createEntityThemes(requestParameters.jsonApiThemeInDocument, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post User Data Filters
     * @param {EntitiesApiCreateEntityUserDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    createEntityUserDataFilters(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .createEntityUserDataFilters(requestParameters.workspaceId, requestParameters.jsonApiUserDataFilterPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User Group - creates tree-like structure for categorizing users
     * @summary Post User Group entities
     * @param {EntitiesApiCreateEntityUserGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    createEntityUserGroups(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .createEntityUserGroups(requestParameters.jsonApiUserGroupInDocument, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post new user settings for the user
     * @param {EntitiesApiCreateEntityUserSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    createEntityUserSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .createEntityUserSettings(requestParameters.userId, requestParameters.jsonApiUserSettingInDocument, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User - represents entity interacting with platform
     * @summary Post User entities
     * @param {EntitiesApiCreateEntityUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    createEntityUsers(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .createEntityUsers(requestParameters.jsonApiUserInDocument, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Visualization Objects
     * @param {EntitiesApiCreateEntityVisualizationObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    createEntityVisualizationObjects(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .createEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.jsonApiVisualizationObjectPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Settings for Workspace Data Filters
     * @param {EntitiesApiCreateEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    createEntityWorkspaceDataFilterSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .createEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.jsonApiWorkspaceDataFilterSettingInDocument, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Workspace Data Filters
     * @param {EntitiesApiCreateEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    createEntityWorkspaceDataFilters(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .createEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.jsonApiWorkspaceDataFilterInDocument, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Settings for Workspaces
     * @param {EntitiesApiCreateEntityWorkspaceSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    createEntityWorkspaceSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .createEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.jsonApiWorkspaceSettingPostOptionalIdDocument, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Space of the shared interest
     * @summary Post Workspace entities
     * @param {EntitiesApiCreateEntityWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    createEntityWorkspaces(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .createEntityWorkspaces(requestParameters.jsonApiWorkspaceInDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Dashboard
     * @param {EntitiesApiDeleteEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    deleteEntityAnalyticalDashboards(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .deleteEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete an API Token for a user
     * @param {EntitiesApiDeleteEntityApiTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    deleteEntityApiTokens(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .deleteEntityApiTokens(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete an Attribute Hierarchy
     * @param {EntitiesApiDeleteEntityAttributeHierarchiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    deleteEntityAttributeHierarchies(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .deleteEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Color Pallette
     * @param {EntitiesApiDeleteEntityColorPalettesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    deleteEntityColorPalettes(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .deleteEntityColorPalettes(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Context Security Police Directive
     * @summary Delete CSP Directives
     * @param {EntitiesApiDeleteEntityCspDirectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    deleteEntityCspDirectives(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .deleteEntityCspDirectives(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Custom Application Setting
     * @param {EntitiesApiDeleteEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    deleteEntityCustomApplicationSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .deleteEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Plugin
     * @param {EntitiesApiDeleteEntityDashboardPluginsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    deleteEntityDashboardPlugins(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .deleteEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Data Source - represents data source for the workspace
     * @summary Delete Data Source entity
     * @param {EntitiesApiDeleteEntityDataSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    deleteEntityDataSources(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .deleteEntityDataSources(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Context Filter
     * @param {EntitiesApiDeleteEntityFilterContextsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    deleteEntityFilterContexts(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .deleteEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes JSON web key - used to verify JSON web tokens (Jwts)
     * @summary Delete Jwk
     * @param {EntitiesApiDeleteEntityJwksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    deleteEntityJwks(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .deleteEntityJwks(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Metric
     * @param {EntitiesApiDeleteEntityMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    deleteEntityMetrics(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .deleteEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete Organization entity
     * @param {EntitiesApiDeleteEntityOrganizationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    deleteEntityOrganizationSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .deleteEntityOrganizationSettings(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete Theming
     * @param {EntitiesApiDeleteEntityThemesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    deleteEntityThemes(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .deleteEntityThemes(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a User Data Filter
     * @param {EntitiesApiDeleteEntityUserDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    deleteEntityUserDataFilters(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .deleteEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User Group - creates tree-like structure for categorizing users
     * @summary Delete UserGroup entity
     * @param {EntitiesApiDeleteEntityUserGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    deleteEntityUserGroups(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .deleteEntityUserGroups(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a setting for a user
     * @param {EntitiesApiDeleteEntityUserSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    deleteEntityUserSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .deleteEntityUserSettings(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User - represents entity interacting with platform
     * @summary Delete User entity
     * @param {EntitiesApiDeleteEntityUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    deleteEntityUsers(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .deleteEntityUsers(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Visualization Object
     * @param {EntitiesApiDeleteEntityVisualizationObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    deleteEntityVisualizationObjects(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .deleteEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Settings for Workspace Data Filter
     * @param {EntitiesApiDeleteEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    deleteEntityWorkspaceDataFilterSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .deleteEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Workspace Data Filter
     * @param {EntitiesApiDeleteEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    deleteEntityWorkspaceDataFilters(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .deleteEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Setting for Workspace
     * @param {EntitiesApiDeleteEntityWorkspaceSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    deleteEntityWorkspaceSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .deleteEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Space of the shared interest
     * @summary Delete Workspace entity
     * @param {EntitiesApiDeleteEntityWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    deleteEntityWorkspaces(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .deleteEntityWorkspaces(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Dashboards
     * @param {EntitiesApiGetAllEntitiesAnalyticalDashboardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesAnalyticalDashboards(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesAnalyticalDashboards(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List all api tokens for a user
     * @param {EntitiesApiGetAllEntitiesApiTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesApiTokens(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesApiTokens(requestParameters.userId, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Attribute Hierarchies
     * @param {EntitiesApiGetAllEntitiesAttributeHierarchiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesAttributeHierarchies(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesAttributeHierarchies(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Attributes
     * @param {EntitiesApiGetAllEntitiesAttributesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesAttributes(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesAttributes(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Color Pallettes
     * @param {EntitiesApiGetAllEntitiesColorPalettesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesColorPalettes(requestParameters = {}, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesColorPalettes(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Context Security Police Directive
     * @summary Get CSP Directives
     * @param {EntitiesApiGetAllEntitiesCspDirectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesCspDirectives(requestParameters = {}, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesCspDirectives(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Custom Application Settings
     * @param {EntitiesApiGetAllEntitiesCustomApplicationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesCustomApplicationSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesCustomApplicationSettings(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Plugins
     * @param {EntitiesApiGetAllEntitiesDashboardPluginsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesDashboardPlugins(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesDashboardPlugins(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Data Source Identifiers
     * @param {EntitiesApiGetAllEntitiesDataSourceIdentifiersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesDataSourceIdentifiers(requestParameters = {}, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesDataSourceIdentifiers(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {EntitiesApiGetAllEntitiesDataSourceTablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesDataSourceTables(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesDataSourceTables(requestParameters.dataSourceId, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Data Source - represents data source for the workspace
     * @summary Get Data Source entities
     * @param {EntitiesApiGetAllEntitiesDataSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesDataSources(requestParameters = {}, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesDataSources(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Datasets
     * @param {EntitiesApiGetAllEntitiesDatasetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesDatasets(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesDatasets(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Space of the shared interest
     * @summary Get Entitlements
     * @param {EntitiesApiGetAllEntitiesEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesEntitlements(requestParameters = {}, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesEntitlements(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Facts
     * @param {EntitiesApiGetAllEntitiesFactsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesFacts(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesFacts(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Context Filters
     * @param {EntitiesApiGetAllEntitiesFilterContextsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesFilterContexts(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesFilterContexts(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all JSON web keys - used to verify JSON web tokens (Jwts)
     * @summary Get all Jwks
     * @param {EntitiesApiGetAllEntitiesJwksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesJwks(requestParameters = {}, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesJwks(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Labels
     * @param {EntitiesApiGetAllEntitiesLabelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesLabels(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesLabels(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Metrics
     * @param {EntitiesApiGetAllEntitiesMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesMetrics(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesMetrics(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Organization entities
     * @param {EntitiesApiGetAllEntitiesOrganizationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesOrganizationSettings(requestParameters = {}, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesOrganizationSettings(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Theming entities
     * @param {EntitiesApiGetAllEntitiesThemesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesThemes(requestParameters = {}, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesThemes(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all User Data Filters
     * @param {EntitiesApiGetAllEntitiesUserDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesUserDataFilters(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesUserDataFilters(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User Group - creates tree-like structure for categorizing users
     * @summary Get UserGroup entities
     * @param {EntitiesApiGetAllEntitiesUserGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesUserGroups(requestParameters = {}, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesUserGroups(requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * UserIdentifier - represents entity interacting with platform
     * @summary Get UserIdentifier entities
     * @param {EntitiesApiGetAllEntitiesUserIdentifiersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesUserIdentifiers(requestParameters = {}, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesUserIdentifiers(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List all settings for a user
     * @param {EntitiesApiGetAllEntitiesUserSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesUserSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesUserSettings(requestParameters.userId, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User - represents entity interacting with platform
     * @summary Get User entities
     * @param {EntitiesApiGetAllEntitiesUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesUsers(requestParameters = {}, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesUsers(requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Visualization Objects
     * @param {EntitiesApiGetAllEntitiesVisualizationObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesVisualizationObjects(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesVisualizationObjects(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Settings for Workspace Data Filters
     * @param {EntitiesApiGetAllEntitiesWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesWorkspaceDataFilterSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Workspace Data Filters
     * @param {EntitiesApiGetAllEntitiesWorkspaceDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesWorkspaceDataFilters(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Setting for Workspaces
     * @param {EntitiesApiGetAllEntitiesWorkspaceSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesWorkspaceSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesWorkspaceSettings(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Space of the shared interest
     * @summary Get Workspace entities
     * @param {EntitiesApiGetAllEntitiesWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllEntitiesWorkspaces(requestParameters = {}, options) {
        return EntitiesApiFp(this.configuration)
            .getAllEntitiesWorkspaces(requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves links for all options for different configurations.
     * @summary Links for all configuration options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getAllOptions(options) {
        return EntitiesApiFp(this.configuration)
            .getAllOptions(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a list of all supported data sources along with information about the used drivers.
     * @summary Get all available data source drivers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getDataSourceDrivers(options) {
        return EntitiesApiFp(this.configuration)
            .getDataSourceDrivers(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Dashboard
     * @param {EntitiesApiGetEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityAnalyticalDashboards(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get an API Token for a user
     * @param {EntitiesApiGetEntityApiTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityApiTokens(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityApiTokens(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get an Attribute Hierarchy
     * @param {EntitiesApiGetEntityAttributeHierarchiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityAttributeHierarchies(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get an Attribute
     * @param {EntitiesApiGetEntityAttributesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityAttributes(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityAttributes(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Color Pallette
     * @param {EntitiesApiGetEntityColorPalettesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityColorPalettes(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityColorPalettes(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get CookieSecurityConfiguration
     * @param {EntitiesApiGetEntityCookieSecurityConfigurationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityCookieSecurityConfigurations(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityCookieSecurityConfigurations(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Context Security Police Directive
     * @summary Get CSP Directives
     * @param {EntitiesApiGetEntityCspDirectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityCspDirectives(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityCspDirectives(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Custom Application Setting
     * @param {EntitiesApiGetEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityCustomApplicationSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Plugin
     * @param {EntitiesApiGetEntityDashboardPluginsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityDashboardPlugins(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Data Source Identifier
     * @param {EntitiesApiGetEntityDataSourceIdentifiersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityDataSourceIdentifiers(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityDataSourceIdentifiers(requestParameters.id, requestParameters.filter, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {EntitiesApiGetEntityDataSourceTablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityDataSourceTables(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityDataSourceTables(requestParameters.dataSourceId, requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Data Source - represents data source for the workspace
     * @summary Get Data Source entity
     * @param {EntitiesApiGetEntityDataSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityDataSources(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityDataSources(requestParameters.id, requestParameters.filter, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Dataset
     * @param {EntitiesApiGetEntityDatasetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityDatasets(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityDatasets(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Space of the shared interest
     * @summary Get Entitlement
     * @param {EntitiesApiGetEntityEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityEntitlements(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityEntitlements(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Fact
     * @param {EntitiesApiGetEntityFactsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityFacts(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityFacts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Context Filter
     * @param {EntitiesApiGetEntityFilterContextsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityFilterContexts(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns JSON web key - used to verify JSON web tokens (Jwts)
     * @summary Get Jwk
     * @param {EntitiesApiGetEntityJwksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityJwks(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityJwks(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Label
     * @param {EntitiesApiGetEntityLabelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityLabels(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityLabels(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Metric
     * @param {EntitiesApiGetEntityMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityMetrics(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Organization entity
     * @param {EntitiesApiGetEntityOrganizationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityOrganizationSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityOrganizationSettings(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Organizations
     * @param {EntitiesApiGetEntityOrganizationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityOrganizations(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityOrganizations(requestParameters.id, requestParameters.filter, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Theming
     * @param {EntitiesApiGetEntityThemesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityThemes(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityThemes(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a User Data Filter
     * @param {EntitiesApiGetEntityUserDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityUserDataFilters(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User Group - creates tree-like structure for categorizing users
     * @summary Get UserGroup entity
     * @param {EntitiesApiGetEntityUserGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityUserGroups(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityUserGroups(requestParameters.id, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * UserIdentifier - represents basic informationZ about entity interacting with platform
     * @summary Get UserIdentifier entity
     * @param {EntitiesApiGetEntityUserIdentifiersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityUserIdentifiers(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityUserIdentifiers(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a setting for a user
     * @param {EntitiesApiGetEntityUserSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityUserSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityUserSettings(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User - represents entity interacting with platform
     * @summary Get User entity
     * @param {EntitiesApiGetEntityUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityUsers(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityUsers(requestParameters.id, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Visualization Object
     * @param {EntitiesApiGetEntityVisualizationObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityVisualizationObjects(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Setting for Workspace Data Filter
     * @param {EntitiesApiGetEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityWorkspaceDataFilterSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Workspace Data Filter
     * @param {EntitiesApiGetEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityWorkspaceDataFilters(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Setting for Workspace
     * @param {EntitiesApiGetEntityWorkspaceSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityWorkspaceSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Space of the shared interest
     * @summary Get Workspace entity
     * @param {EntitiesApiGetEntityWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getEntityWorkspaces(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .getEntityWorkspaces(requestParameters.id, requestParameters.filter, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets a basic information about organization.
     * @summary Get current organization info
     * @param {EntitiesApiGetOrganizationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    getOrganization(requestParameters = {}, options) {
        return EntitiesApiFp(this.configuration)
            .getOrganization(requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Dashboard
     * @param {EntitiesApiPatchEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    patchEntityAnalyticalDashboards(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .patchEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAnalyticalDashboardPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch an Attribute Hierarchy
     * @param {EntitiesApiPatchEntityAttributeHierarchiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    patchEntityAttributeHierarchies(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .patchEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAttributeHierarchyPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch Color Pallette
     * @param {EntitiesApiPatchEntityColorPalettesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    patchEntityColorPalettes(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .patchEntityColorPalettes(requestParameters.id, requestParameters.jsonApiColorPalettePatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch CookieSecurityConfiguration
     * @param {EntitiesApiPatchEntityCookieSecurityConfigurationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    patchEntityCookieSecurityConfigurations(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .patchEntityCookieSecurityConfigurations(requestParameters.id, requestParameters.jsonApiCookieSecurityConfigurationPatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Context Security Police Directive
     * @summary Patch CSP Directives
     * @param {EntitiesApiPatchEntityCspDirectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    patchEntityCspDirectives(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .patchEntityCspDirectives(requestParameters.id, requestParameters.jsonApiCspDirectivePatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Custom Application Setting
     * @param {EntitiesApiPatchEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    patchEntityCustomApplicationSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .patchEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiCustomApplicationSettingPatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Plugin
     * @param {EntitiesApiPatchEntityDashboardPluginsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    patchEntityDashboardPlugins(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .patchEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiDashboardPluginPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Data Source - represents data source for the workspace
     * @summary Patch Data Source entity
     * @param {EntitiesApiPatchEntityDataSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    patchEntityDataSources(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .patchEntityDataSources(requestParameters.id, requestParameters.jsonApiDataSourcePatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Context Filter
     * @param {EntitiesApiPatchEntityFilterContextsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    patchEntityFilterContexts(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .patchEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiFilterContextPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Patches JSON web key - used to verify JSON web tokens (Jwts)
     * @summary Patch Jwk
     * @param {EntitiesApiPatchEntityJwksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    patchEntityJwks(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .patchEntityJwks(requestParameters.id, requestParameters.jsonApiJwkPatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Metric
     * @param {EntitiesApiPatchEntityMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    patchEntityMetrics(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .patchEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiMetricPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch Organization entity
     * @param {EntitiesApiPatchEntityOrganizationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    patchEntityOrganizationSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .patchEntityOrganizationSettings(requestParameters.id, requestParameters.jsonApiOrganizationSettingPatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch Organization
     * @param {EntitiesApiPatchEntityOrganizationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    patchEntityOrganizations(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .patchEntityOrganizations(requestParameters.id, requestParameters.jsonApiOrganizationPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch Theming
     * @param {EntitiesApiPatchEntityThemesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    patchEntityThemes(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .patchEntityThemes(requestParameters.id, requestParameters.jsonApiThemePatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a User Data Filter
     * @param {EntitiesApiPatchEntityUserDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    patchEntityUserDataFilters(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .patchEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiUserDataFilterPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User Group - creates tree-like structure for categorizing users
     * @summary Patch UserGroup entity
     * @param {EntitiesApiPatchEntityUserGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    patchEntityUserGroups(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .patchEntityUserGroups(requestParameters.id, requestParameters.jsonApiUserGroupPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User - represents entity interacting with platform
     * @summary Patch User entity
     * @param {EntitiesApiPatchEntityUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    patchEntityUsers(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .patchEntityUsers(requestParameters.id, requestParameters.jsonApiUserPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Visualization Object
     * @param {EntitiesApiPatchEntityVisualizationObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    patchEntityVisualizationObjects(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .patchEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiVisualizationObjectPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Settings for Workspace Data Filter
     * @param {EntitiesApiPatchEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    patchEntityWorkspaceDataFilterSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .patchEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterSettingPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Workspace Data Filter
     * @param {EntitiesApiPatchEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    patchEntityWorkspaceDataFilters(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .patchEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Setting for Workspace
     * @param {EntitiesApiPatchEntityWorkspaceSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    patchEntityWorkspaceSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .patchEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceSettingPatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Space of the shared interest
     * @summary Patch Workspace entity
     * @param {EntitiesApiPatchEntityWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    patchEntityWorkspaces(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .patchEntityWorkspaces(requestParameters.id, requestParameters.jsonApiWorkspacePatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put Dashboards
     * @param {EntitiesApiUpdateEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityAnalyticalDashboards(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAnalyticalDashboardInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put new API token for the user
     * @param {EntitiesApiUpdateEntityApiTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityApiTokens(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityApiTokens(requestParameters.userId, requestParameters.id, requestParameters.jsonApiApiTokenInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put an Attribute Hierarchy
     * @param {EntitiesApiUpdateEntityAttributeHierarchiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityAttributeHierarchies(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAttributeHierarchyInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put Color Pallette
     * @param {EntitiesApiUpdateEntityColorPalettesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityColorPalettes(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityColorPalettes(requestParameters.id, requestParameters.jsonApiColorPaletteInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put CookieSecurityConfiguration
     * @param {EntitiesApiUpdateEntityCookieSecurityConfigurationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityCookieSecurityConfigurations(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityCookieSecurityConfigurations(requestParameters.id, requestParameters.jsonApiCookieSecurityConfigurationInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Context Security Police Directive
     * @summary Put CSP Directives
     * @param {EntitiesApiUpdateEntityCspDirectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityCspDirectives(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityCspDirectives(requestParameters.id, requestParameters.jsonApiCspDirectiveInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Custom Application Setting
     * @param {EntitiesApiUpdateEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityCustomApplicationSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiCustomApplicationSettingInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Plugin
     * @param {EntitiesApiUpdateEntityDashboardPluginsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityDashboardPlugins(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiDashboardPluginInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Data Source - represents data source for the workspace
     * @summary Put Data Source entity
     * @param {EntitiesApiUpdateEntityDataSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityDataSources(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityDataSources(requestParameters.id, requestParameters.jsonApiDataSourceInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Context Filter
     * @param {EntitiesApiUpdateEntityFilterContextsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityFilterContexts(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiFilterContextInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates JSON web key - used to verify JSON web tokens (Jwts)
     * @summary Put Jwk
     * @param {EntitiesApiUpdateEntityJwksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityJwks(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityJwks(requestParameters.id, requestParameters.jsonApiJwkInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Metric
     * @param {EntitiesApiUpdateEntityMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityMetrics(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiMetricInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put Organization entity
     * @param {EntitiesApiUpdateEntityOrganizationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityOrganizationSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityOrganizationSettings(requestParameters.id, requestParameters.jsonApiOrganizationSettingInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put Organization
     * @param {EntitiesApiUpdateEntityOrganizationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityOrganizations(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityOrganizations(requestParameters.id, requestParameters.jsonApiOrganizationInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put Theming
     * @param {EntitiesApiUpdateEntityThemesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityThemes(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityThemes(requestParameters.id, requestParameters.jsonApiThemeInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a User Data Filter
     * @param {EntitiesApiUpdateEntityUserDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityUserDataFilters(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiUserDataFilterInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User Group - creates tree-like structure for categorizing users
     * @summary Put UserGroup entity
     * @param {EntitiesApiUpdateEntityUserGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityUserGroups(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityUserGroups(requestParameters.id, requestParameters.jsonApiUserGroupInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put new user settings for the user
     * @param {EntitiesApiUpdateEntityUserSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityUserSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityUserSettings(requestParameters.userId, requestParameters.id, requestParameters.jsonApiUserSettingInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User - represents entity interacting with platform
     * @summary Put User entity
     * @param {EntitiesApiUpdateEntityUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityUsers(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityUsers(requestParameters.id, requestParameters.jsonApiUserInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Visualization Object
     * @param {EntitiesApiUpdateEntityVisualizationObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityVisualizationObjects(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiVisualizationObjectInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Settings for Workspace Data Filter
     * @param {EntitiesApiUpdateEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityWorkspaceDataFilterSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterSettingInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Workspace Data Filter
     * @param {EntitiesApiUpdateEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityWorkspaceDataFilters(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Setting for a Workspace
     * @param {EntitiesApiUpdateEntityWorkspaceSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityWorkspaceSettings(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceSettingInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Space of the shared interest
     * @summary Put Workspace entity
     * @param {EntitiesApiUpdateEntityWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    updateEntityWorkspaces(requestParameters, options) {
        return EntitiesApiFp(this.configuration)
            .updateEntityWorkspaces(requestParameters.id, requestParameters.jsonApiWorkspaceInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * EntitlementApi - axios parameter creator
 * @export
 */
export const EntitlementApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Space of the shared interest
         * @summary Get Entitlements
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesEntitlements: async (filter, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/entitlements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Space of the shared interest
         * @summary Get Entitlement
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityEntitlements: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityEntitlements", "id", id);
            const localVarPath = `/api/v1/entities/entitlements/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolves values of available entitlements for the organization.
         * @summary Values for all public entitlements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveAllEntitlements: async (options = {}) => {
            const localVarPath = `/api/v1/actions/resolveEntitlements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolves values for requested entitlements in the organization.
         * @summary Values for requested public entitlements.
         * @param {EntitlementsRequest} entitlementsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveRequestedEntitlements: async (entitlementsRequest, options = {}) => {
            // verify required parameter 'entitlementsRequest' is not null or undefined
            assertParamExists("resolveRequestedEntitlements", "entitlementsRequest", entitlementsRequest);
            const localVarPath = `/api/v1/actions/resolveEntitlements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof entitlementsRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(entitlementsRequest !== undefined ? entitlementsRequest : {})
                : entitlementsRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * EntitlementApi - functional programming interface
 * @export
 */
export const EntitlementApiFp = function (configuration) {
    const localVarAxiosParamCreator = EntitlementApiAxiosParamCreator(configuration);
    return {
        /**
         * Space of the shared interest
         * @summary Get Entitlements
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesEntitlements(filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesEntitlements(filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Space of the shared interest
         * @summary Get Entitlement
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityEntitlements(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityEntitlements(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resolves values of available entitlements for the organization.
         * @summary Values for all public entitlements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveAllEntitlements(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveAllEntitlements(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resolves values for requested entitlements in the organization.
         * @summary Values for requested public entitlements.
         * @param {EntitlementsRequest} entitlementsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveRequestedEntitlements(entitlementsRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveRequestedEntitlements(entitlementsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * EntitlementApi - factory interface
 * @export
 */
export const EntitlementApiFactory = function (configuration, basePath, axios) {
    const localVarFp = EntitlementApiFp(configuration);
    return {
        /**
         * Space of the shared interest
         * @summary Get Entitlements
         * @param {EntitlementApiGetAllEntitiesEntitlementsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesEntitlements(requestParameters, options) {
            return localVarFp
                .getAllEntitiesEntitlements(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Space of the shared interest
         * @summary Get Entitlement
         * @param {EntitlementApiGetEntityEntitlementsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityEntitlements(requestParameters, options) {
            return localVarFp
                .getEntityEntitlements(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Resolves values of available entitlements for the organization.
         * @summary Values for all public entitlements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveAllEntitlements(options) {
            return localVarFp.resolveAllEntitlements(options).then((request) => request(axios, basePath));
        },
        /**
         * Resolves values for requested entitlements in the organization.
         * @summary Values for requested public entitlements.
         * @param {EntitlementApiResolveRequestedEntitlementsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveRequestedEntitlements(requestParameters, options) {
            return localVarFp
                .resolveRequestedEntitlements(requestParameters.entitlementsRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * EntitlementApi - object-oriented interface
 * @export
 * @class EntitlementApi
 * @extends {BaseAPI}
 */
export class EntitlementApi extends BaseAPI {
    /**
     * Space of the shared interest
     * @summary Get Entitlements
     * @param {EntitlementApiGetAllEntitiesEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementApi
     */
    getAllEntitiesEntitlements(requestParameters = {}, options) {
        return EntitlementApiFp(this.configuration)
            .getAllEntitiesEntitlements(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Space of the shared interest
     * @summary Get Entitlement
     * @param {EntitlementApiGetEntityEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementApi
     */
    getEntityEntitlements(requestParameters, options) {
        return EntitlementApiFp(this.configuration)
            .getEntityEntitlements(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Resolves values of available entitlements for the organization.
     * @summary Values for all public entitlements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementApi
     */
    resolveAllEntitlements(options) {
        return EntitlementApiFp(this.configuration)
            .resolveAllEntitlements(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Resolves values for requested entitlements in the organization.
     * @summary Values for requested public entitlements.
     * @param {EntitlementApiResolveRequestedEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementApi
     */
    resolveRequestedEntitlements(requestParameters, options) {
        return EntitlementApiFp(this.configuration)
            .resolveRequestedEntitlements(requestParameters.entitlementsRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * FactsApi - axios parameter creator
 * @export
 */
export const FactsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get all Facts
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'dataset' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesFacts: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesFacts", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/facts`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Fact
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'dataset' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityFacts: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityFacts", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityFacts", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/facts/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * FactsApi - functional programming interface
 * @export
 */
export const FactsApiFp = function (configuration) {
    const localVarAxiosParamCreator = FactsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get all Facts
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'dataset' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesFacts(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesFacts(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Fact
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'dataset' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityFacts(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityFacts(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * FactsApi - factory interface
 * @export
 */
export const FactsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = FactsApiFp(configuration);
    return {
        /**
         *
         * @summary Get all Facts
         * @param {FactsApiGetAllEntitiesFactsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesFacts(requestParameters, options) {
            return localVarFp
                .getAllEntitiesFacts(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Fact
         * @param {FactsApiGetEntityFactsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityFacts(requestParameters, options) {
            return localVarFp
                .getEntityFacts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * FactsApi - object-oriented interface
 * @export
 * @class FactsApi
 * @extends {BaseAPI}
 */
export class FactsApi extends BaseAPI {
    /**
     *
     * @summary Get all Facts
     * @param {FactsApiGetAllEntitiesFactsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactsApi
     */
    getAllEntitiesFacts(requestParameters, options) {
        return FactsApiFp(this.configuration)
            .getAllEntitiesFacts(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Fact
     * @param {FactsApiGetEntityFactsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactsApi
     */
    getEntityFacts(requestParameters, options) {
        return FactsApiFp(this.configuration)
            .getEntityFacts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * GenerateLogicalDataModelApi - axios parameter creator
 * @export
 */
export const GenerateLogicalDataModelApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Generate logical data model (LDM) from physical data model (PDM) stored in data source.
         * @summary Generate logical data model (LDM) from physical data model (PDM)
         * @param {string} dataSourceId
         * @param {GenerateLdmRequest} generateLdmRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateLogicalModel: async (dataSourceId, generateLdmRequest, options = {}) => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("generateLogicalModel", "dataSourceId", dataSourceId);
            // verify required parameter 'generateLdmRequest' is not null or undefined
            assertParamExists("generateLogicalModel", "generateLdmRequest", generateLdmRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/generateLogicalModel`.replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof generateLdmRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(generateLdmRequest !== undefined ? generateLdmRequest : {})
                : generateLdmRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * GenerateLogicalDataModelApi - functional programming interface
 * @export
 */
export const GenerateLogicalDataModelApiFp = function (configuration) {
    const localVarAxiosParamCreator = GenerateLogicalDataModelApiAxiosParamCreator(configuration);
    return {
        /**
         * Generate logical data model (LDM) from physical data model (PDM) stored in data source.
         * @summary Generate logical data model (LDM) from physical data model (PDM)
         * @param {string} dataSourceId
         * @param {GenerateLdmRequest} generateLdmRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateLogicalModel(dataSourceId, generateLdmRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateLogicalModel(dataSourceId, generateLdmRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * GenerateLogicalDataModelApi - factory interface
 * @export
 */
export const GenerateLogicalDataModelApiFactory = function (configuration, basePath, axios) {
    const localVarFp = GenerateLogicalDataModelApiFp(configuration);
    return {
        /**
         * Generate logical data model (LDM) from physical data model (PDM) stored in data source.
         * @summary Generate logical data model (LDM) from physical data model (PDM)
         * @param {GenerateLogicalDataModelApiGenerateLogicalModelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateLogicalModel(requestParameters, options) {
            return localVarFp
                .generateLogicalModel(requestParameters.dataSourceId, requestParameters.generateLdmRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * GenerateLogicalDataModelApi - object-oriented interface
 * @export
 * @class GenerateLogicalDataModelApi
 * @extends {BaseAPI}
 */
export class GenerateLogicalDataModelApi extends BaseAPI {
    /**
     * Generate logical data model (LDM) from physical data model (PDM) stored in data source.
     * @summary Generate logical data model (LDM) from physical data model (PDM)
     * @param {GenerateLogicalDataModelApiGenerateLogicalModelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenerateLogicalDataModelApi
     */
    generateLogicalModel(requestParameters, options) {
        return GenerateLogicalDataModelApiFp(this.configuration)
            .generateLogicalModel(requestParameters.dataSourceId, requestParameters.generateLdmRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * InvalidateCacheApi - axios parameter creator
 * @export
 */
export const InvalidateCacheApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Notification sets up all reports to be computed again with new data.
         * @summary Register an upload notification
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUploadNotification: async (dataSourceId, options = {}) => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("registerUploadNotification", "dataSourceId", dataSourceId);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/uploadNotification`.replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * InvalidateCacheApi - functional programming interface
 * @export
 */
export const InvalidateCacheApiFp = function (configuration) {
    const localVarAxiosParamCreator = InvalidateCacheApiAxiosParamCreator(configuration);
    return {
        /**
         * Notification sets up all reports to be computed again with new data.
         * @summary Register an upload notification
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUploadNotification(dataSourceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUploadNotification(dataSourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * InvalidateCacheApi - factory interface
 * @export
 */
export const InvalidateCacheApiFactory = function (configuration, basePath, axios) {
    const localVarFp = InvalidateCacheApiFp(configuration);
    return {
        /**
         * Notification sets up all reports to be computed again with new data.
         * @summary Register an upload notification
         * @param {InvalidateCacheApiRegisterUploadNotificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUploadNotification(requestParameters, options) {
            return localVarFp
                .registerUploadNotification(requestParameters.dataSourceId, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * InvalidateCacheApi - object-oriented interface
 * @export
 * @class InvalidateCacheApi
 * @extends {BaseAPI}
 */
export class InvalidateCacheApi extends BaseAPI {
    /**
     * Notification sets up all reports to be computed again with new data.
     * @summary Register an upload notification
     * @param {InvalidateCacheApiRegisterUploadNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvalidateCacheApi
     */
    registerUploadNotification(requestParameters, options) {
        return InvalidateCacheApiFp(this.configuration)
            .registerUploadNotification(requestParameters.dataSourceId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * LDMDeclarativeAPIsApi - axios parameter creator
 * @export
 */
export const LDMDeclarativeAPIsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve current logical model of the workspace in declarative form.
         * @summary Get logical model
         * @param {string} workspaceId
         * @param {boolean} [includeParents]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogicalModel: async (workspaceId, includeParents, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getLogicalModel", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/layout/workspaces/{workspaceId}/logicalModel`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (includeParents !== undefined) {
                localVarQueryParameter["includeParents"] = includeParents;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set effective logical model of the workspace.
         * @summary Set logical model
         * @param {string} workspaceId
         * @param {DeclarativeModel} declarativeModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setLogicalModel: async (workspaceId, declarativeModel, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("setLogicalModel", "workspaceId", workspaceId);
            // verify required parameter 'declarativeModel' is not null or undefined
            assertParamExists("setLogicalModel", "declarativeModel", declarativeModel);
            const localVarPath = `/api/v1/layout/workspaces/{workspaceId}/logicalModel`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeModel !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeModel !== undefined ? declarativeModel : {})
                : declarativeModel || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * LDMDeclarativeAPIsApi - functional programming interface
 * @export
 */
export const LDMDeclarativeAPIsApiFp = function (configuration) {
    const localVarAxiosParamCreator = LDMDeclarativeAPIsApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieve current logical model of the workspace in declarative form.
         * @summary Get logical model
         * @param {string} workspaceId
         * @param {boolean} [includeParents]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogicalModel(workspaceId, includeParents, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLogicalModel(workspaceId, includeParents, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set effective logical model of the workspace.
         * @summary Set logical model
         * @param {string} workspaceId
         * @param {DeclarativeModel} declarativeModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setLogicalModel(workspaceId, declarativeModel, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setLogicalModel(workspaceId, declarativeModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * LDMDeclarativeAPIsApi - factory interface
 * @export
 */
export const LDMDeclarativeAPIsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = LDMDeclarativeAPIsApiFp(configuration);
    return {
        /**
         * Retrieve current logical model of the workspace in declarative form.
         * @summary Get logical model
         * @param {LDMDeclarativeAPIsApiGetLogicalModelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogicalModel(requestParameters, options) {
            return localVarFp
                .getLogicalModel(requestParameters.workspaceId, requestParameters.includeParents, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Set effective logical model of the workspace.
         * @summary Set logical model
         * @param {LDMDeclarativeAPIsApiSetLogicalModelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setLogicalModel(requestParameters, options) {
            return localVarFp
                .setLogicalModel(requestParameters.workspaceId, requestParameters.declarativeModel, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * LDMDeclarativeAPIsApi - object-oriented interface
 * @export
 * @class LDMDeclarativeAPIsApi
 * @extends {BaseAPI}
 */
export class LDMDeclarativeAPIsApi extends BaseAPI {
    /**
     * Retrieve current logical model of the workspace in declarative form.
     * @summary Get logical model
     * @param {LDMDeclarativeAPIsApiGetLogicalModelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LDMDeclarativeAPIsApi
     */
    getLogicalModel(requestParameters, options) {
        return LDMDeclarativeAPIsApiFp(this.configuration)
            .getLogicalModel(requestParameters.workspaceId, requestParameters.includeParents, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Set effective logical model of the workspace.
     * @summary Set logical model
     * @param {LDMDeclarativeAPIsApiSetLogicalModelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LDMDeclarativeAPIsApi
     */
    setLogicalModel(requestParameters, options) {
        return LDMDeclarativeAPIsApiFp(this.configuration)
            .setLogicalModel(requestParameters.workspaceId, requestParameters.declarativeModel, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * LabelsApi - axios parameter creator
 * @export
 */
export const LabelsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get all Labels
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'attribute' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesLabels: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesLabels", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/labels`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Label
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'attribute' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityLabels: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityLabels", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityLabels", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/labels/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * LabelsApi - functional programming interface
 * @export
 */
export const LabelsApiFp = function (configuration) {
    const localVarAxiosParamCreator = LabelsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get all Labels
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'attribute' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesLabels(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesLabels(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Label
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'attribute' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityLabels(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityLabels(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * LabelsApi - factory interface
 * @export
 */
export const LabelsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = LabelsApiFp(configuration);
    return {
        /**
         *
         * @summary Get all Labels
         * @param {LabelsApiGetAllEntitiesLabelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesLabels(requestParameters, options) {
            return localVarFp
                .getAllEntitiesLabels(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Label
         * @param {LabelsApiGetEntityLabelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityLabels(requestParameters, options) {
            return localVarFp
                .getEntityLabels(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * LabelsApi - object-oriented interface
 * @export
 * @class LabelsApi
 * @extends {BaseAPI}
 */
export class LabelsApi extends BaseAPI {
    /**
     *
     * @summary Get all Labels
     * @param {LabelsApiGetAllEntitiesLabelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    getAllEntitiesLabels(requestParameters, options) {
        return LabelsApiFp(this.configuration)
            .getAllEntitiesLabels(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Label
     * @param {LabelsApiGetEntityLabelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelsApi
     */
    getEntityLabels(requestParameters, options) {
        return LabelsApiFp(this.configuration)
            .getEntityLabels(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * LayoutApi - axios parameter creator
 * @export
 */
export const LayoutApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve current analytics model of the workspace.
         * @summary Get analytics model
         * @param {string} workspaceId
         * @param {Array<'ACTIVITY_INFO'>} [exclude]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalyticsModel: async (workspaceId, exclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAnalyticsModel", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/layout/workspaces/{workspaceId}/analyticsModel`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (exclude) {
                localVarQueryParameter["exclude"] = exclude;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all data sources including related physical model.
         * @summary Get all data sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourcesLayout: async (options = {}) => {
            const localVarPath = `/api/v1/layout/dataSources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve current logical model of the workspace in declarative form.
         * @summary Get logical model
         * @param {string} workspaceId
         * @param {boolean} [includeParents]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogicalModel: async (workspaceId, includeParents, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getLogicalModel", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/layout/workspaces/{workspaceId}/logicalModel`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (includeParents !== undefined) {
                localVarQueryParameter["includeParents"] = includeParents;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve complete layout of organization, workspaces, user-groups, etc.
         * @summary Get organization layout
         * @param {Array<'ACTIVITY_INFO'>} [exclude]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationLayout: async (exclude, options = {}) => {
            const localVarPath = `/api/v1/layout/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (exclude) {
                localVarQueryParameter["exclude"] = exclude;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve complete layout of tables with their columns
         * @summary Get data source physical model layout
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getPdmLayout: async (dataSourceId, options = {}) => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("getPdmLayout", "dataSourceId", dataSourceId);
            const localVarPath = `/api/v1/layout/dataSources/{dataSourceId}/physicalModel`.replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve current user data filters assigned to the workspace.
         * @summary Get user data filters
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDataFilters: async (workspaceId, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getUserDataFilters", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/layout/workspaces/{workspaceId}/userDataFilters`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve current set of permissions of the user-group in a declarative form.
         * @summary Get permissions for the user-group
         * @param {string} userGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupPermissions: async (userGroupId, options = {}) => {
            // verify required parameter 'userGroupId' is not null or undefined
            assertParamExists("getUserGroupPermissions", "userGroupId", userGroupId);
            const localVarPath = `/api/v1/layout/userGroups/{userGroupId}/permissions`.replace(`{${"userGroupId"}}`, encodeURIComponent(String(userGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all user-groups eventually with parent group.
         * @summary Get all user groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupsLayout: async (options = {}) => {
            const localVarPath = `/api/v1/layout/userGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve current set of permissions of the user in a declarative form.
         * @summary Get permissions for the user
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPermissions: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("getUserPermissions", "userId", userId);
            const localVarPath = `/api/v1/layout/users/{userId}/permissions`.replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all users including authentication properties.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersLayout: async (options = {}) => {
            const localVarPath = `/api/v1/layout/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all users and user groups with theirs properties.
         * @summary Get all users and user groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUserGroupsLayout: async (options = {}) => {
            const localVarPath = `/api/v1/layout/usersAndUserGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all workspaces and related workspace data filters (and their settings / values).
         * @summary Get workspace data filters for all workspaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceDataFiltersLayout: async (options = {}) => {
            const localVarPath = `/api/v1/layout/workspaceDataFilters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve current model of the workspace in declarative form.
         * @summary Get workspace layout
         * @param {string} workspaceId
         * @param {Array<'ACTIVITY_INFO'>} [exclude]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceLayout: async (workspaceId, exclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getWorkspaceLayout", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/layout/workspaces/{workspaceId}`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (exclude) {
                localVarQueryParameter["exclude"] = exclude;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve current set of permissions of the workspace in a declarative form.
         * @summary Get permissions for the workspace
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspacePermissions: async (workspaceId, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getWorkspacePermissions", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/layout/workspaces/{workspaceId}/permissions`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets complete layout of workspaces, their hierarchy, models.
         * @summary Get all workspaces layout
         * @param {Array<'ACTIVITY_INFO'>} [exclude]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspacesLayout: async (exclude, options = {}) => {
            const localVarPath = `/api/v1/layout/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (exclude) {
                localVarQueryParameter["exclude"] = exclude;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set all data sources including related physical model.
         * @summary Put all data sources
         * @param {DeclarativeDataSources} declarativeDataSources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDataSourcesLayout: async (declarativeDataSources, options = {}) => {
            // verify required parameter 'declarativeDataSources' is not null or undefined
            assertParamExists("putDataSourcesLayout", "declarativeDataSources", declarativeDataSources);
            const localVarPath = `/api/v1/layout/dataSources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeDataSources !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeDataSources !== undefined ? declarativeDataSources : {})
                : declarativeDataSources || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define all user groups with their parents eventually.
         * @summary Put all user groups
         * @param {DeclarativeUserGroups} declarativeUserGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserGroupsLayout: async (declarativeUserGroups, options = {}) => {
            // verify required parameter 'declarativeUserGroups' is not null or undefined
            assertParamExists("putUserGroupsLayout", "declarativeUserGroups", declarativeUserGroups);
            const localVarPath = `/api/v1/layout/userGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeUserGroups !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeUserGroups !== undefined ? declarativeUserGroups : {})
                : declarativeUserGroups || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set all users and their authentication properties.
         * @summary Put all users
         * @param {DeclarativeUsers} declarativeUsers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersLayout: async (declarativeUsers, options = {}) => {
            // verify required parameter 'declarativeUsers' is not null or undefined
            assertParamExists("putUsersLayout", "declarativeUsers", declarativeUsers);
            const localVarPath = `/api/v1/layout/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeUsers !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeUsers !== undefined ? declarativeUsers : {})
                : declarativeUsers || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define all users and user groups with theirs properties.
         * @summary Put all users and user groups
         * @param {DeclarativeUsersUserGroups} declarativeUsersUserGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersUserGroupsLayout: async (declarativeUsersUserGroups, options = {}) => {
            // verify required parameter 'declarativeUsersUserGroups' is not null or undefined
            assertParamExists("putUsersUserGroupsLayout", "declarativeUsersUserGroups", declarativeUsersUserGroups);
            const localVarPath = `/api/v1/layout/usersAndUserGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeUsersUserGroups !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeUsersUserGroups !== undefined ? declarativeUsersUserGroups : {})
                : declarativeUsersUserGroups || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set complete layout of workspace, like model, authorization, etc.
         * @summary Set workspace layout
         * @param {string} workspaceId
         * @param {DeclarativeWorkspaceModel} declarativeWorkspaceModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWorkspaceLayout: async (workspaceId, declarativeWorkspaceModel, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("putWorkspaceLayout", "workspaceId", workspaceId);
            // verify required parameter 'declarativeWorkspaceModel' is not null or undefined
            assertParamExists("putWorkspaceLayout", "declarativeWorkspaceModel", declarativeWorkspaceModel);
            const localVarPath = `/api/v1/layout/workspaces/{workspaceId}`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeWorkspaceModel !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeWorkspaceModel !== undefined ? declarativeWorkspaceModel : {})
                : declarativeWorkspaceModel || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set effective analytics model of the workspace.
         * @summary Set analytics model
         * @param {string} workspaceId
         * @param {DeclarativeAnalytics} declarativeAnalytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAnalyticsModel: async (workspaceId, declarativeAnalytics, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("setAnalyticsModel", "workspaceId", workspaceId);
            // verify required parameter 'declarativeAnalytics' is not null or undefined
            assertParamExists("setAnalyticsModel", "declarativeAnalytics", declarativeAnalytics);
            const localVarPath = `/api/v1/layout/workspaces/{workspaceId}/analyticsModel`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeAnalytics !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeAnalytics !== undefined ? declarativeAnalytics : {})
                : declarativeAnalytics || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set effective logical model of the workspace.
         * @summary Set logical model
         * @param {string} workspaceId
         * @param {DeclarativeModel} declarativeModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setLogicalModel: async (workspaceId, declarativeModel, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("setLogicalModel", "workspaceId", workspaceId);
            // verify required parameter 'declarativeModel' is not null or undefined
            assertParamExists("setLogicalModel", "declarativeModel", declarativeModel);
            const localVarPath = `/api/v1/layout/workspaces/{workspaceId}/logicalModel`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeModel !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeModel !== undefined ? declarativeModel : {})
                : declarativeModel || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets complete layout of organization, like workspaces, user-groups, etc.
         * @summary Set organization layout
         * @param {DeclarativeOrganization} declarativeOrganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrganizationLayout: async (declarativeOrganization, options = {}) => {
            // verify required parameter 'declarativeOrganization' is not null or undefined
            assertParamExists("setOrganizationLayout", "declarativeOrganization", declarativeOrganization);
            const localVarPath = `/api/v1/layout/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeOrganization !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeOrganization !== undefined ? declarativeOrganization : {})
                : declarativeOrganization || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets complete layout of tables with their columns under corresponding Data Source.
         * @summary Set data source physical model layout
         * @param {string} dataSourceId
         * @param {DeclarativePdm} declarativePdm
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        setPdmLayout: async (dataSourceId, declarativePdm, options = {}) => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("setPdmLayout", "dataSourceId", dataSourceId);
            // verify required parameter 'declarativePdm' is not null or undefined
            assertParamExists("setPdmLayout", "declarativePdm", declarativePdm);
            const localVarPath = `/api/v1/layout/dataSources/{dataSourceId}/physicalModel`.replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativePdm !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativePdm !== undefined ? declarativePdm : {})
                : declarativePdm || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set user data filters assigned to the workspace.
         * @summary Set user data filters
         * @param {string} workspaceId
         * @param {DeclarativeUserDataFilters} declarativeUserDataFilters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserDataFilters: async (workspaceId, declarativeUserDataFilters, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("setUserDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'declarativeUserDataFilters' is not null or undefined
            assertParamExists("setUserDataFilters", "declarativeUserDataFilters", declarativeUserDataFilters);
            const localVarPath = `/api/v1/layout/workspaces/{workspaceId}/userDataFilters`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeUserDataFilters !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeUserDataFilters !== undefined ? declarativeUserDataFilters : {})
                : declarativeUserDataFilters || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set effective permissions for the user-group
         * @summary Set permissions for the user-group
         * @param {string} userGroupId
         * @param {DeclarativeUserGroupPermissions} declarativeUserGroupPermissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserGroupPermissions: async (userGroupId, declarativeUserGroupPermissions, options = {}) => {
            // verify required parameter 'userGroupId' is not null or undefined
            assertParamExists("setUserGroupPermissions", "userGroupId", userGroupId);
            // verify required parameter 'declarativeUserGroupPermissions' is not null or undefined
            assertParamExists("setUserGroupPermissions", "declarativeUserGroupPermissions", declarativeUserGroupPermissions);
            const localVarPath = `/api/v1/layout/userGroups/{userGroupId}/permissions`.replace(`{${"userGroupId"}}`, encodeURIComponent(String(userGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeUserGroupPermissions !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeUserGroupPermissions !== undefined ? declarativeUserGroupPermissions : {})
                : declarativeUserGroupPermissions || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set effective permissions for the user
         * @summary Set permissions for the user
         * @param {string} userId
         * @param {DeclarativeUserPermissions} declarativeUserPermissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserPermissions: async (userId, declarativeUserPermissions, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("setUserPermissions", "userId", userId);
            // verify required parameter 'declarativeUserPermissions' is not null or undefined
            assertParamExists("setUserPermissions", "declarativeUserPermissions", declarativeUserPermissions);
            const localVarPath = `/api/v1/layout/users/{userId}/permissions`.replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeUserPermissions !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeUserPermissions !== undefined ? declarativeUserPermissions : {})
                : declarativeUserPermissions || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets workspace data filters in all workspaces in entire organization.
         * @summary Set all workspace data filters
         * @param {DeclarativeWorkspaceDataFilters} declarativeWorkspaceDataFilters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspaceDataFiltersLayout: async (declarativeWorkspaceDataFilters, options = {}) => {
            // verify required parameter 'declarativeWorkspaceDataFilters' is not null or undefined
            assertParamExists("setWorkspaceDataFiltersLayout", "declarativeWorkspaceDataFilters", declarativeWorkspaceDataFilters);
            const localVarPath = `/api/v1/layout/workspaceDataFilters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeWorkspaceDataFilters !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeWorkspaceDataFilters !== undefined ? declarativeWorkspaceDataFilters : {})
                : declarativeWorkspaceDataFilters || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set effective permissions for the workspace
         * @summary Set permissions for the workspace
         * @param {string} workspaceId
         * @param {DeclarativeWorkspacePermissions} declarativeWorkspacePermissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspacePermissions: async (workspaceId, declarativeWorkspacePermissions, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("setWorkspacePermissions", "workspaceId", workspaceId);
            // verify required parameter 'declarativeWorkspacePermissions' is not null or undefined
            assertParamExists("setWorkspacePermissions", "declarativeWorkspacePermissions", declarativeWorkspacePermissions);
            const localVarPath = `/api/v1/layout/workspaces/{workspaceId}/permissions`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeWorkspacePermissions !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeWorkspacePermissions !== undefined ? declarativeWorkspacePermissions : {})
                : declarativeWorkspacePermissions || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets complete layout of workspaces, their hierarchy, models.
         * @summary Set all workspaces layout
         * @param {DeclarativeWorkspaces} declarativeWorkspaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspacesLayout: async (declarativeWorkspaces, options = {}) => {
            // verify required parameter 'declarativeWorkspaces' is not null or undefined
            assertParamExists("setWorkspacesLayout", "declarativeWorkspaces", declarativeWorkspaces);
            const localVarPath = `/api/v1/layout/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeWorkspaces !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeWorkspaces !== undefined ? declarativeWorkspaces : {})
                : declarativeWorkspaces || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * LayoutApi - functional programming interface
 * @export
 */
export const LayoutApiFp = function (configuration) {
    const localVarAxiosParamCreator = LayoutApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieve current analytics model of the workspace.
         * @summary Get analytics model
         * @param {string} workspaceId
         * @param {Array<'ACTIVITY_INFO'>} [exclude]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnalyticsModel(workspaceId, exclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnalyticsModel(workspaceId, exclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all data sources including related physical model.
         * @summary Get all data sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataSourcesLayout(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataSourcesLayout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve current logical model of the workspace in declarative form.
         * @summary Get logical model
         * @param {string} workspaceId
         * @param {boolean} [includeParents]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogicalModel(workspaceId, includeParents, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLogicalModel(workspaceId, includeParents, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve complete layout of organization, workspaces, user-groups, etc.
         * @summary Get organization layout
         * @param {Array<'ACTIVITY_INFO'>} [exclude]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationLayout(exclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationLayout(exclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve complete layout of tables with their columns
         * @summary Get data source physical model layout
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getPdmLayout(dataSourceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPdmLayout(dataSourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve current user data filters assigned to the workspace.
         * @summary Get user data filters
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserDataFilters(workspaceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserDataFilters(workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve current set of permissions of the user-group in a declarative form.
         * @summary Get permissions for the user-group
         * @param {string} userGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserGroupPermissions(userGroupId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserGroupPermissions(userGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all user-groups eventually with parent group.
         * @summary Get all user groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserGroupsLayout(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserGroupsLayout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve current set of permissions of the user in a declarative form.
         * @summary Get permissions for the user
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPermissions(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPermissions(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all users including authentication properties.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersLayout(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersLayout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all users and user groups with theirs properties.
         * @summary Get all users and user groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersUserGroupsLayout(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersUserGroupsLayout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all workspaces and related workspace data filters (and their settings / values).
         * @summary Get workspace data filters for all workspaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceDataFiltersLayout(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceDataFiltersLayout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve current model of the workspace in declarative form.
         * @summary Get workspace layout
         * @param {string} workspaceId
         * @param {Array<'ACTIVITY_INFO'>} [exclude]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceLayout(workspaceId, exclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceLayout(workspaceId, exclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve current set of permissions of the workspace in a declarative form.
         * @summary Get permissions for the workspace
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspacePermissions(workspaceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspacePermissions(workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets complete layout of workspaces, their hierarchy, models.
         * @summary Get all workspaces layout
         * @param {Array<'ACTIVITY_INFO'>} [exclude]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspacesLayout(exclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspacesLayout(exclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set all data sources including related physical model.
         * @summary Put all data sources
         * @param {DeclarativeDataSources} declarativeDataSources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putDataSourcesLayout(declarativeDataSources, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putDataSourcesLayout(declarativeDataSources, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Define all user groups with their parents eventually.
         * @summary Put all user groups
         * @param {DeclarativeUserGroups} declarativeUserGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUserGroupsLayout(declarativeUserGroups, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUserGroupsLayout(declarativeUserGroups, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set all users and their authentication properties.
         * @summary Put all users
         * @param {DeclarativeUsers} declarativeUsers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUsersLayout(declarativeUsers, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUsersLayout(declarativeUsers, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Define all users and user groups with theirs properties.
         * @summary Put all users and user groups
         * @param {DeclarativeUsersUserGroups} declarativeUsersUserGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUsersUserGroupsLayout(declarativeUsersUserGroups, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUsersUserGroupsLayout(declarativeUsersUserGroups, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set complete layout of workspace, like model, authorization, etc.
         * @summary Set workspace layout
         * @param {string} workspaceId
         * @param {DeclarativeWorkspaceModel} declarativeWorkspaceModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putWorkspaceLayout(workspaceId, declarativeWorkspaceModel, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putWorkspaceLayout(workspaceId, declarativeWorkspaceModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set effective analytics model of the workspace.
         * @summary Set analytics model
         * @param {string} workspaceId
         * @param {DeclarativeAnalytics} declarativeAnalytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAnalyticsModel(workspaceId, declarativeAnalytics, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAnalyticsModel(workspaceId, declarativeAnalytics, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set effective logical model of the workspace.
         * @summary Set logical model
         * @param {string} workspaceId
         * @param {DeclarativeModel} declarativeModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setLogicalModel(workspaceId, declarativeModel, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setLogicalModel(workspaceId, declarativeModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets complete layout of organization, like workspaces, user-groups, etc.
         * @summary Set organization layout
         * @param {DeclarativeOrganization} declarativeOrganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setOrganizationLayout(declarativeOrganization, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setOrganizationLayout(declarativeOrganization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets complete layout of tables with their columns under corresponding Data Source.
         * @summary Set data source physical model layout
         * @param {string} dataSourceId
         * @param {DeclarativePdm} declarativePdm
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async setPdmLayout(dataSourceId, declarativePdm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPdmLayout(dataSourceId, declarativePdm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set user data filters assigned to the workspace.
         * @summary Set user data filters
         * @param {string} workspaceId
         * @param {DeclarativeUserDataFilters} declarativeUserDataFilters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserDataFilters(workspaceId, declarativeUserDataFilters, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserDataFilters(workspaceId, declarativeUserDataFilters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set effective permissions for the user-group
         * @summary Set permissions for the user-group
         * @param {string} userGroupId
         * @param {DeclarativeUserGroupPermissions} declarativeUserGroupPermissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserGroupPermissions(userGroupId, declarativeUserGroupPermissions, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserGroupPermissions(userGroupId, declarativeUserGroupPermissions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set effective permissions for the user
         * @summary Set permissions for the user
         * @param {string} userId
         * @param {DeclarativeUserPermissions} declarativeUserPermissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserPermissions(userId, declarativeUserPermissions, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserPermissions(userId, declarativeUserPermissions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets workspace data filters in all workspaces in entire organization.
         * @summary Set all workspace data filters
         * @param {DeclarativeWorkspaceDataFilters} declarativeWorkspaceDataFilters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setWorkspaceDataFiltersLayout(declarativeWorkspaceDataFilters, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setWorkspaceDataFiltersLayout(declarativeWorkspaceDataFilters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set effective permissions for the workspace
         * @summary Set permissions for the workspace
         * @param {string} workspaceId
         * @param {DeclarativeWorkspacePermissions} declarativeWorkspacePermissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setWorkspacePermissions(workspaceId, declarativeWorkspacePermissions, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setWorkspacePermissions(workspaceId, declarativeWorkspacePermissions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets complete layout of workspaces, their hierarchy, models.
         * @summary Set all workspaces layout
         * @param {DeclarativeWorkspaces} declarativeWorkspaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setWorkspacesLayout(declarativeWorkspaces, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setWorkspacesLayout(declarativeWorkspaces, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * LayoutApi - factory interface
 * @export
 */
export const LayoutApiFactory = function (configuration, basePath, axios) {
    const localVarFp = LayoutApiFp(configuration);
    return {
        /**
         * Retrieve current analytics model of the workspace.
         * @summary Get analytics model
         * @param {LayoutApiGetAnalyticsModelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalyticsModel(requestParameters, options) {
            return localVarFp
                .getAnalyticsModel(requestParameters.workspaceId, requestParameters.exclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all data sources including related physical model.
         * @summary Get all data sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourcesLayout(options) {
            return localVarFp.getDataSourcesLayout(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve current logical model of the workspace in declarative form.
         * @summary Get logical model
         * @param {LayoutApiGetLogicalModelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogicalModel(requestParameters, options) {
            return localVarFp
                .getLogicalModel(requestParameters.workspaceId, requestParameters.includeParents, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Retrieve complete layout of organization, workspaces, user-groups, etc.
         * @summary Get organization layout
         * @param {LayoutApiGetOrganizationLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationLayout(requestParameters, options) {
            return localVarFp
                .getOrganizationLayout(requestParameters.exclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Retrieve complete layout of tables with their columns
         * @summary Get data source physical model layout
         * @param {LayoutApiGetPdmLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getPdmLayout(requestParameters, options) {
            return localVarFp
                .getPdmLayout(requestParameters.dataSourceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Retrieve current user data filters assigned to the workspace.
         * @summary Get user data filters
         * @param {LayoutApiGetUserDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDataFilters(requestParameters, options) {
            return localVarFp
                .getUserDataFilters(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Retrieve current set of permissions of the user-group in a declarative form.
         * @summary Get permissions for the user-group
         * @param {LayoutApiGetUserGroupPermissionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupPermissions(requestParameters, options) {
            return localVarFp
                .getUserGroupPermissions(requestParameters.userGroupId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all user-groups eventually with parent group.
         * @summary Get all user groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupsLayout(options) {
            return localVarFp.getUserGroupsLayout(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve current set of permissions of the user in a declarative form.
         * @summary Get permissions for the user
         * @param {LayoutApiGetUserPermissionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPermissions(requestParameters, options) {
            return localVarFp
                .getUserPermissions(requestParameters.userId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all users including authentication properties.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersLayout(options) {
            return localVarFp.getUsersLayout(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all users and user groups with theirs properties.
         * @summary Get all users and user groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUserGroupsLayout(options) {
            return localVarFp.getUsersUserGroupsLayout(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all workspaces and related workspace data filters (and their settings / values).
         * @summary Get workspace data filters for all workspaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceDataFiltersLayout(options) {
            return localVarFp
                .getWorkspaceDataFiltersLayout(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Retrieve current model of the workspace in declarative form.
         * @summary Get workspace layout
         * @param {LayoutApiGetWorkspaceLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceLayout(requestParameters, options) {
            return localVarFp
                .getWorkspaceLayout(requestParameters.workspaceId, requestParameters.exclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Retrieve current set of permissions of the workspace in a declarative form.
         * @summary Get permissions for the workspace
         * @param {LayoutApiGetWorkspacePermissionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspacePermissions(requestParameters, options) {
            return localVarFp
                .getWorkspacePermissions(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Gets complete layout of workspaces, their hierarchy, models.
         * @summary Get all workspaces layout
         * @param {LayoutApiGetWorkspacesLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspacesLayout(requestParameters, options) {
            return localVarFp
                .getWorkspacesLayout(requestParameters.exclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Set all data sources including related physical model.
         * @summary Put all data sources
         * @param {LayoutApiPutDataSourcesLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDataSourcesLayout(requestParameters, options) {
            return localVarFp
                .putDataSourcesLayout(requestParameters.declarativeDataSources, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Define all user groups with their parents eventually.
         * @summary Put all user groups
         * @param {LayoutApiPutUserGroupsLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserGroupsLayout(requestParameters, options) {
            return localVarFp
                .putUserGroupsLayout(requestParameters.declarativeUserGroups, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Set all users and their authentication properties.
         * @summary Put all users
         * @param {LayoutApiPutUsersLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersLayout(requestParameters, options) {
            return localVarFp
                .putUsersLayout(requestParameters.declarativeUsers, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Define all users and user groups with theirs properties.
         * @summary Put all users and user groups
         * @param {LayoutApiPutUsersUserGroupsLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersUserGroupsLayout(requestParameters, options) {
            return localVarFp
                .putUsersUserGroupsLayout(requestParameters.declarativeUsersUserGroups, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Set complete layout of workspace, like model, authorization, etc.
         * @summary Set workspace layout
         * @param {LayoutApiPutWorkspaceLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWorkspaceLayout(requestParameters, options) {
            return localVarFp
                .putWorkspaceLayout(requestParameters.workspaceId, requestParameters.declarativeWorkspaceModel, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Set effective analytics model of the workspace.
         * @summary Set analytics model
         * @param {LayoutApiSetAnalyticsModelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAnalyticsModel(requestParameters, options) {
            return localVarFp
                .setAnalyticsModel(requestParameters.workspaceId, requestParameters.declarativeAnalytics, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Set effective logical model of the workspace.
         * @summary Set logical model
         * @param {LayoutApiSetLogicalModelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setLogicalModel(requestParameters, options) {
            return localVarFp
                .setLogicalModel(requestParameters.workspaceId, requestParameters.declarativeModel, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Sets complete layout of organization, like workspaces, user-groups, etc.
         * @summary Set organization layout
         * @param {LayoutApiSetOrganizationLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrganizationLayout(requestParameters, options) {
            return localVarFp
                .setOrganizationLayout(requestParameters.declarativeOrganization, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Sets complete layout of tables with their columns under corresponding Data Source.
         * @summary Set data source physical model layout
         * @param {LayoutApiSetPdmLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        setPdmLayout(requestParameters, options) {
            return localVarFp
                .setPdmLayout(requestParameters.dataSourceId, requestParameters.declarativePdm, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Set user data filters assigned to the workspace.
         * @summary Set user data filters
         * @param {LayoutApiSetUserDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserDataFilters(requestParameters, options) {
            return localVarFp
                .setUserDataFilters(requestParameters.workspaceId, requestParameters.declarativeUserDataFilters, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Set effective permissions for the user-group
         * @summary Set permissions for the user-group
         * @param {LayoutApiSetUserGroupPermissionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserGroupPermissions(requestParameters, options) {
            return localVarFp
                .setUserGroupPermissions(requestParameters.userGroupId, requestParameters.declarativeUserGroupPermissions, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Set effective permissions for the user
         * @summary Set permissions for the user
         * @param {LayoutApiSetUserPermissionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserPermissions(requestParameters, options) {
            return localVarFp
                .setUserPermissions(requestParameters.userId, requestParameters.declarativeUserPermissions, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Sets workspace data filters in all workspaces in entire organization.
         * @summary Set all workspace data filters
         * @param {LayoutApiSetWorkspaceDataFiltersLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspaceDataFiltersLayout(requestParameters, options) {
            return localVarFp
                .setWorkspaceDataFiltersLayout(requestParameters.declarativeWorkspaceDataFilters, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Set effective permissions for the workspace
         * @summary Set permissions for the workspace
         * @param {LayoutApiSetWorkspacePermissionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspacePermissions(requestParameters, options) {
            return localVarFp
                .setWorkspacePermissions(requestParameters.workspaceId, requestParameters.declarativeWorkspacePermissions, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Sets complete layout of workspaces, their hierarchy, models.
         * @summary Set all workspaces layout
         * @param {LayoutApiSetWorkspacesLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspacesLayout(requestParameters, options) {
            return localVarFp
                .setWorkspacesLayout(requestParameters.declarativeWorkspaces, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * LayoutApi - object-oriented interface
 * @export
 * @class LayoutApi
 * @extends {BaseAPI}
 */
export class LayoutApi extends BaseAPI {
    /**
     * Retrieve current analytics model of the workspace.
     * @summary Get analytics model
     * @param {LayoutApiGetAnalyticsModelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    getAnalyticsModel(requestParameters, options) {
        return LayoutApiFp(this.configuration)
            .getAnalyticsModel(requestParameters.workspaceId, requestParameters.exclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve all data sources including related physical model.
     * @summary Get all data sources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    getDataSourcesLayout(options) {
        return LayoutApiFp(this.configuration)
            .getDataSourcesLayout(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve current logical model of the workspace in declarative form.
     * @summary Get logical model
     * @param {LayoutApiGetLogicalModelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    getLogicalModel(requestParameters, options) {
        return LayoutApiFp(this.configuration)
            .getLogicalModel(requestParameters.workspaceId, requestParameters.includeParents, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve complete layout of organization, workspaces, user-groups, etc.
     * @summary Get organization layout
     * @param {LayoutApiGetOrganizationLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    getOrganizationLayout(requestParameters = {}, options) {
        return LayoutApiFp(this.configuration)
            .getOrganizationLayout(requestParameters.exclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve complete layout of tables with their columns
     * @summary Get data source physical model layout
     * @param {LayoutApiGetPdmLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    getPdmLayout(requestParameters, options) {
        return LayoutApiFp(this.configuration)
            .getPdmLayout(requestParameters.dataSourceId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve current user data filters assigned to the workspace.
     * @summary Get user data filters
     * @param {LayoutApiGetUserDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    getUserDataFilters(requestParameters, options) {
        return LayoutApiFp(this.configuration)
            .getUserDataFilters(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve current set of permissions of the user-group in a declarative form.
     * @summary Get permissions for the user-group
     * @param {LayoutApiGetUserGroupPermissionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    getUserGroupPermissions(requestParameters, options) {
        return LayoutApiFp(this.configuration)
            .getUserGroupPermissions(requestParameters.userGroupId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve all user-groups eventually with parent group.
     * @summary Get all user groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    getUserGroupsLayout(options) {
        return LayoutApiFp(this.configuration)
            .getUserGroupsLayout(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve current set of permissions of the user in a declarative form.
     * @summary Get permissions for the user
     * @param {LayoutApiGetUserPermissionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    getUserPermissions(requestParameters, options) {
        return LayoutApiFp(this.configuration)
            .getUserPermissions(requestParameters.userId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve all users including authentication properties.
     * @summary Get all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    getUsersLayout(options) {
        return LayoutApiFp(this.configuration)
            .getUsersLayout(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve all users and user groups with theirs properties.
     * @summary Get all users and user groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    getUsersUserGroupsLayout(options) {
        return LayoutApiFp(this.configuration)
            .getUsersUserGroupsLayout(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve all workspaces and related workspace data filters (and their settings / values).
     * @summary Get workspace data filters for all workspaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    getWorkspaceDataFiltersLayout(options) {
        return LayoutApiFp(this.configuration)
            .getWorkspaceDataFiltersLayout(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve current model of the workspace in declarative form.
     * @summary Get workspace layout
     * @param {LayoutApiGetWorkspaceLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    getWorkspaceLayout(requestParameters, options) {
        return LayoutApiFp(this.configuration)
            .getWorkspaceLayout(requestParameters.workspaceId, requestParameters.exclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve current set of permissions of the workspace in a declarative form.
     * @summary Get permissions for the workspace
     * @param {LayoutApiGetWorkspacePermissionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    getWorkspacePermissions(requestParameters, options) {
        return LayoutApiFp(this.configuration)
            .getWorkspacePermissions(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets complete layout of workspaces, their hierarchy, models.
     * @summary Get all workspaces layout
     * @param {LayoutApiGetWorkspacesLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    getWorkspacesLayout(requestParameters = {}, options) {
        return LayoutApiFp(this.configuration)
            .getWorkspacesLayout(requestParameters.exclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Set all data sources including related physical model.
     * @summary Put all data sources
     * @param {LayoutApiPutDataSourcesLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    putDataSourcesLayout(requestParameters, options) {
        return LayoutApiFp(this.configuration)
            .putDataSourcesLayout(requestParameters.declarativeDataSources, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Define all user groups with their parents eventually.
     * @summary Put all user groups
     * @param {LayoutApiPutUserGroupsLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    putUserGroupsLayout(requestParameters, options) {
        return LayoutApiFp(this.configuration)
            .putUserGroupsLayout(requestParameters.declarativeUserGroups, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Set all users and their authentication properties.
     * @summary Put all users
     * @param {LayoutApiPutUsersLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    putUsersLayout(requestParameters, options) {
        return LayoutApiFp(this.configuration)
            .putUsersLayout(requestParameters.declarativeUsers, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Define all users and user groups with theirs properties.
     * @summary Put all users and user groups
     * @param {LayoutApiPutUsersUserGroupsLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    putUsersUserGroupsLayout(requestParameters, options) {
        return LayoutApiFp(this.configuration)
            .putUsersUserGroupsLayout(requestParameters.declarativeUsersUserGroups, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Set complete layout of workspace, like model, authorization, etc.
     * @summary Set workspace layout
     * @param {LayoutApiPutWorkspaceLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    putWorkspaceLayout(requestParameters, options) {
        return LayoutApiFp(this.configuration)
            .putWorkspaceLayout(requestParameters.workspaceId, requestParameters.declarativeWorkspaceModel, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Set effective analytics model of the workspace.
     * @summary Set analytics model
     * @param {LayoutApiSetAnalyticsModelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    setAnalyticsModel(requestParameters, options) {
        return LayoutApiFp(this.configuration)
            .setAnalyticsModel(requestParameters.workspaceId, requestParameters.declarativeAnalytics, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Set effective logical model of the workspace.
     * @summary Set logical model
     * @param {LayoutApiSetLogicalModelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    setLogicalModel(requestParameters, options) {
        return LayoutApiFp(this.configuration)
            .setLogicalModel(requestParameters.workspaceId, requestParameters.declarativeModel, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets complete layout of organization, like workspaces, user-groups, etc.
     * @summary Set organization layout
     * @param {LayoutApiSetOrganizationLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    setOrganizationLayout(requestParameters, options) {
        return LayoutApiFp(this.configuration)
            .setOrganizationLayout(requestParameters.declarativeOrganization, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets complete layout of tables with their columns under corresponding Data Source.
     * @summary Set data source physical model layout
     * @param {LayoutApiSetPdmLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    setPdmLayout(requestParameters, options) {
        return LayoutApiFp(this.configuration)
            .setPdmLayout(requestParameters.dataSourceId, requestParameters.declarativePdm, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Set user data filters assigned to the workspace.
     * @summary Set user data filters
     * @param {LayoutApiSetUserDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    setUserDataFilters(requestParameters, options) {
        return LayoutApiFp(this.configuration)
            .setUserDataFilters(requestParameters.workspaceId, requestParameters.declarativeUserDataFilters, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Set effective permissions for the user-group
     * @summary Set permissions for the user-group
     * @param {LayoutApiSetUserGroupPermissionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    setUserGroupPermissions(requestParameters, options) {
        return LayoutApiFp(this.configuration)
            .setUserGroupPermissions(requestParameters.userGroupId, requestParameters.declarativeUserGroupPermissions, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Set effective permissions for the user
     * @summary Set permissions for the user
     * @param {LayoutApiSetUserPermissionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    setUserPermissions(requestParameters, options) {
        return LayoutApiFp(this.configuration)
            .setUserPermissions(requestParameters.userId, requestParameters.declarativeUserPermissions, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets workspace data filters in all workspaces in entire organization.
     * @summary Set all workspace data filters
     * @param {LayoutApiSetWorkspaceDataFiltersLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    setWorkspaceDataFiltersLayout(requestParameters, options) {
        return LayoutApiFp(this.configuration)
            .setWorkspaceDataFiltersLayout(requestParameters.declarativeWorkspaceDataFilters, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Set effective permissions for the workspace
     * @summary Set permissions for the workspace
     * @param {LayoutApiSetWorkspacePermissionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    setWorkspacePermissions(requestParameters, options) {
        return LayoutApiFp(this.configuration)
            .setWorkspacePermissions(requestParameters.workspaceId, requestParameters.declarativeWorkspacePermissions, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets complete layout of workspaces, their hierarchy, models.
     * @summary Set all workspaces layout
     * @param {LayoutApiSetWorkspacesLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    setWorkspacesLayout(requestParameters, options) {
        return LayoutApiFp(this.configuration)
            .setWorkspacesLayout(requestParameters.declarativeWorkspaces, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Post Metrics
         * @param {string} workspaceId
         * @param {JsonApiMetricPostOptionalIdDocument} jsonApiMetricPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityMetrics: async (workspaceId, jsonApiMetricPostOptionalIdDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityMetrics", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiMetricPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityMetrics", "jsonApiMetricPostOptionalIdDocument", jsonApiMetricPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/metrics`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiMetricPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiMetricPostOptionalIdDocument !== undefined
                    ? jsonApiMetricPostOptionalIdDocument
                    : {})
                : jsonApiMetricPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityMetrics: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityMetrics", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityMetrics", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/metrics/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Metrics
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesMetrics: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesMetrics", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/metrics`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityMetrics: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityMetrics", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityMetrics", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/metrics/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiMetricPatchDocument} jsonApiMetricPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityMetrics: async (workspaceId, objectId, jsonApiMetricPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityMetrics", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityMetrics", "objectId", objectId);
            // verify required parameter 'jsonApiMetricPatchDocument' is not null or undefined
            assertParamExists("patchEntityMetrics", "jsonApiMetricPatchDocument", jsonApiMetricPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/metrics/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiMetricPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiMetricPatchDocument !== undefined ? jsonApiMetricPatchDocument : {})
                : jsonApiMetricPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiMetricInDocument} jsonApiMetricInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityMetrics: async (workspaceId, objectId, jsonApiMetricInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityMetrics", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityMetrics", "objectId", objectId);
            // verify required parameter 'jsonApiMetricInDocument' is not null or undefined
            assertParamExists("updateEntityMetrics", "jsonApiMetricInDocument", jsonApiMetricInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/metrics/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiMetricInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiMetricInDocument !== undefined ? jsonApiMetricInDocument : {})
                : jsonApiMetricInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function (configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Post Metrics
         * @param {string} workspaceId
         * @param {JsonApiMetricPostOptionalIdDocument} jsonApiMetricPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityMetrics(workspaceId, jsonApiMetricPostOptionalIdDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityMetrics(workspaceId, jsonApiMetricPostOptionalIdDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityMetrics(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityMetrics(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Metrics
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesMetrics(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesMetrics(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityMetrics(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityMetrics(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiMetricPatchDocument} jsonApiMetricPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityMetrics(workspaceId, objectId, jsonApiMetricPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityMetrics(workspaceId, objectId, jsonApiMetricPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiMetricInDocument} jsonApiMetricInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityMetrics(workspaceId, objectId, jsonApiMetricInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityMetrics(workspaceId, objectId, jsonApiMetricInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = MetricsApiFp(configuration);
    return {
        /**
         *
         * @summary Post Metrics
         * @param {MetricsApiCreateEntityMetricsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityMetrics(requestParameters, options) {
            return localVarFp
                .createEntityMetrics(requestParameters.workspaceId, requestParameters.jsonApiMetricPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Metric
         * @param {MetricsApiDeleteEntityMetricsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityMetrics(requestParameters, options) {
            return localVarFp
                .deleteEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Metrics
         * @param {MetricsApiGetAllEntitiesMetricsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesMetrics(requestParameters, options) {
            return localVarFp
                .getAllEntitiesMetrics(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Metric
         * @param {MetricsApiGetEntityMetricsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityMetrics(requestParameters, options) {
            return localVarFp
                .getEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Metric
         * @param {MetricsApiPatchEntityMetricsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityMetrics(requestParameters, options) {
            return localVarFp
                .patchEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiMetricPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Metric
         * @param {MetricsApiUpdateEntityMetricsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityMetrics(requestParameters, options) {
            return localVarFp
                .updateEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiMetricInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     *
     * @summary Post Metrics
     * @param {MetricsApiCreateEntityMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    createEntityMetrics(requestParameters, options) {
        return MetricsApiFp(this.configuration)
            .createEntityMetrics(requestParameters.workspaceId, requestParameters.jsonApiMetricPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Metric
     * @param {MetricsApiDeleteEntityMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    deleteEntityMetrics(requestParameters, options) {
        return MetricsApiFp(this.configuration)
            .deleteEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Metrics
     * @param {MetricsApiGetAllEntitiesMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    getAllEntitiesMetrics(requestParameters, options) {
        return MetricsApiFp(this.configuration)
            .getAllEntitiesMetrics(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Metric
     * @param {MetricsApiGetEntityMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    getEntityMetrics(requestParameters, options) {
        return MetricsApiFp(this.configuration)
            .getEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Metric
     * @param {MetricsApiPatchEntityMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    patchEntityMetrics(requestParameters, options) {
        return MetricsApiFp(this.configuration)
            .patchEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiMetricPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Metric
     * @param {MetricsApiUpdateEntityMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    updateEntityMetrics(requestParameters, options) {
        return MetricsApiFp(this.configuration)
            .updateEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiMetricInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * OptionsApi - axios parameter creator
 * @export
 */
export const OptionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves links for all options for different configurations.
         * @summary Links for all configuration options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOptions: async (options = {}) => {
            const localVarPath = `/api/v1/options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * OptionsApi - functional programming interface
 * @export
 */
export const OptionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = OptionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieves links for all options for different configurations.
         * @summary Links for all configuration options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOptions(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * OptionsApi - factory interface
 * @export
 */
export const OptionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = OptionsApiFp(configuration);
    return {
        /**
         * Retrieves links for all options for different configurations.
         * @summary Links for all configuration options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOptions(options) {
            return localVarFp.getAllOptions(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * OptionsApi - object-oriented interface
 * @export
 * @class OptionsApi
 * @extends {BaseAPI}
 */
export class OptionsApi extends BaseAPI {
    /**
     * Retrieves links for all options for different configurations.
     * @summary Links for all configuration options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    getAllOptions(options) {
        return OptionsApiFp(this.configuration)
            .getAllOptions(options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * OrganizationControllerApi - axios parameter creator
 * @export
 */
export const OrganizationControllerApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get CookieSecurityConfiguration
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityCookieSecurityConfigurations: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityCookieSecurityConfigurations", "id", id);
            const localVarPath = `/api/v1/entities/admin/cookieSecurityConfigurations/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Organizations
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityOrganizations: async (id, filter, include, metaInclude, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityOrganizations", "id", id);
            const localVarPath = `/api/v1/entities/admin/organizations/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch CookieSecurityConfiguration
         * @param {string} id
         * @param {JsonApiCookieSecurityConfigurationPatchDocument} jsonApiCookieSecurityConfigurationPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityCookieSecurityConfigurations: async (id, jsonApiCookieSecurityConfigurationPatchDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityCookieSecurityConfigurations", "id", id);
            // verify required parameter 'jsonApiCookieSecurityConfigurationPatchDocument' is not null or undefined
            assertParamExists("patchEntityCookieSecurityConfigurations", "jsonApiCookieSecurityConfigurationPatchDocument", jsonApiCookieSecurityConfigurationPatchDocument);
            const localVarPath = `/api/v1/entities/admin/cookieSecurityConfigurations/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCookieSecurityConfigurationPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCookieSecurityConfigurationPatchDocument !== undefined
                    ? jsonApiCookieSecurityConfigurationPatchDocument
                    : {})
                : jsonApiCookieSecurityConfigurationPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch Organization
         * @param {string} id
         * @param {JsonApiOrganizationPatchDocument} jsonApiOrganizationPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityOrganizations: async (id, jsonApiOrganizationPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityOrganizations", "id", id);
            // verify required parameter 'jsonApiOrganizationPatchDocument' is not null or undefined
            assertParamExists("patchEntityOrganizations", "jsonApiOrganizationPatchDocument", jsonApiOrganizationPatchDocument);
            const localVarPath = `/api/v1/entities/admin/organizations/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiOrganizationPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiOrganizationPatchDocument !== undefined ? jsonApiOrganizationPatchDocument : {})
                : jsonApiOrganizationPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put CookieSecurityConfiguration
         * @param {string} id
         * @param {JsonApiCookieSecurityConfigurationInDocument} jsonApiCookieSecurityConfigurationInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityCookieSecurityConfigurations: async (id, jsonApiCookieSecurityConfigurationInDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityCookieSecurityConfigurations", "id", id);
            // verify required parameter 'jsonApiCookieSecurityConfigurationInDocument' is not null or undefined
            assertParamExists("updateEntityCookieSecurityConfigurations", "jsonApiCookieSecurityConfigurationInDocument", jsonApiCookieSecurityConfigurationInDocument);
            const localVarPath = `/api/v1/entities/admin/cookieSecurityConfigurations/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCookieSecurityConfigurationInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCookieSecurityConfigurationInDocument !== undefined
                    ? jsonApiCookieSecurityConfigurationInDocument
                    : {})
                : jsonApiCookieSecurityConfigurationInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put Organization
         * @param {string} id
         * @param {JsonApiOrganizationInDocument} jsonApiOrganizationInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityOrganizations: async (id, jsonApiOrganizationInDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityOrganizations", "id", id);
            // verify required parameter 'jsonApiOrganizationInDocument' is not null or undefined
            assertParamExists("updateEntityOrganizations", "jsonApiOrganizationInDocument", jsonApiOrganizationInDocument);
            const localVarPath = `/api/v1/entities/admin/organizations/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiOrganizationInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiOrganizationInDocument !== undefined ? jsonApiOrganizationInDocument : {})
                : jsonApiOrganizationInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * OrganizationControllerApi - functional programming interface
 * @export
 */
export const OrganizationControllerApiFp = function (configuration) {
    const localVarAxiosParamCreator = OrganizationControllerApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get CookieSecurityConfiguration
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityCookieSecurityConfigurations(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityCookieSecurityConfigurations(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Organizations
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityOrganizations(id, filter, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityOrganizations(id, filter, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch CookieSecurityConfiguration
         * @param {string} id
         * @param {JsonApiCookieSecurityConfigurationPatchDocument} jsonApiCookieSecurityConfigurationPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityCookieSecurityConfigurations(id, jsonApiCookieSecurityConfigurationPatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityCookieSecurityConfigurations(id, jsonApiCookieSecurityConfigurationPatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch Organization
         * @param {string} id
         * @param {JsonApiOrganizationPatchDocument} jsonApiOrganizationPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityOrganizations(id, jsonApiOrganizationPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityOrganizations(id, jsonApiOrganizationPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put CookieSecurityConfiguration
         * @param {string} id
         * @param {JsonApiCookieSecurityConfigurationInDocument} jsonApiCookieSecurityConfigurationInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityCookieSecurityConfigurations(id, jsonApiCookieSecurityConfigurationInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityCookieSecurityConfigurations(id, jsonApiCookieSecurityConfigurationInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put Organization
         * @param {string} id
         * @param {JsonApiOrganizationInDocument} jsonApiOrganizationInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityOrganizations(id, jsonApiOrganizationInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityOrganizations(id, jsonApiOrganizationInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * OrganizationControllerApi - factory interface
 * @export
 */
export const OrganizationControllerApiFactory = function (configuration, basePath, axios) {
    const localVarFp = OrganizationControllerApiFp(configuration);
    return {
        /**
         *
         * @summary Get CookieSecurityConfiguration
         * @param {OrganizationControllerApiGetEntityCookieSecurityConfigurationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityCookieSecurityConfigurations(requestParameters, options) {
            return localVarFp
                .getEntityCookieSecurityConfigurations(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Organizations
         * @param {OrganizationControllerApiGetEntityOrganizationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityOrganizations(requestParameters, options) {
            return localVarFp
                .getEntityOrganizations(requestParameters.id, requestParameters.filter, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch CookieSecurityConfiguration
         * @param {OrganizationControllerApiPatchEntityCookieSecurityConfigurationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityCookieSecurityConfigurations(requestParameters, options) {
            return localVarFp
                .patchEntityCookieSecurityConfigurations(requestParameters.id, requestParameters.jsonApiCookieSecurityConfigurationPatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch Organization
         * @param {OrganizationControllerApiPatchEntityOrganizationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityOrganizations(requestParameters, options) {
            return localVarFp
                .patchEntityOrganizations(requestParameters.id, requestParameters.jsonApiOrganizationPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put CookieSecurityConfiguration
         * @param {OrganizationControllerApiUpdateEntityCookieSecurityConfigurationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityCookieSecurityConfigurations(requestParameters, options) {
            return localVarFp
                .updateEntityCookieSecurityConfigurations(requestParameters.id, requestParameters.jsonApiCookieSecurityConfigurationInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put Organization
         * @param {OrganizationControllerApiUpdateEntityOrganizationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityOrganizations(requestParameters, options) {
            return localVarFp
                .updateEntityOrganizations(requestParameters.id, requestParameters.jsonApiOrganizationInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * OrganizationControllerApi - object-oriented interface
 * @export
 * @class OrganizationControllerApi
 * @extends {BaseAPI}
 */
export class OrganizationControllerApi extends BaseAPI {
    /**
     *
     * @summary Get CookieSecurityConfiguration
     * @param {OrganizationControllerApiGetEntityCookieSecurityConfigurationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    getEntityCookieSecurityConfigurations(requestParameters, options) {
        return OrganizationControllerApiFp(this.configuration)
            .getEntityCookieSecurityConfigurations(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Organizations
     * @param {OrganizationControllerApiGetEntityOrganizationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    getEntityOrganizations(requestParameters, options) {
        return OrganizationControllerApiFp(this.configuration)
            .getEntityOrganizations(requestParameters.id, requestParameters.filter, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch CookieSecurityConfiguration
     * @param {OrganizationControllerApiPatchEntityCookieSecurityConfigurationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    patchEntityCookieSecurityConfigurations(requestParameters, options) {
        return OrganizationControllerApiFp(this.configuration)
            .patchEntityCookieSecurityConfigurations(requestParameters.id, requestParameters.jsonApiCookieSecurityConfigurationPatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch Organization
     * @param {OrganizationControllerApiPatchEntityOrganizationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    patchEntityOrganizations(requestParameters, options) {
        return OrganizationControllerApiFp(this.configuration)
            .patchEntityOrganizations(requestParameters.id, requestParameters.jsonApiOrganizationPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put CookieSecurityConfiguration
     * @param {OrganizationControllerApiUpdateEntityCookieSecurityConfigurationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    updateEntityCookieSecurityConfigurations(requestParameters, options) {
        return OrganizationControllerApiFp(this.configuration)
            .updateEntityCookieSecurityConfigurations(requestParameters.id, requestParameters.jsonApiCookieSecurityConfigurationInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put Organization
     * @param {OrganizationControllerApiUpdateEntityOrganizationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationControllerApi
     */
    updateEntityOrganizations(requestParameters, options) {
        return OrganizationControllerApiFp(this.configuration)
            .updateEntityOrganizations(requestParameters.id, requestParameters.jsonApiOrganizationInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * OrganizationDeclarativeAPIsApi - axios parameter creator
 * @export
 */
export const OrganizationDeclarativeAPIsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve complete layout of organization, workspaces, user-groups, etc.
         * @summary Get organization layout
         * @param {Array<'ACTIVITY_INFO'>} [exclude]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationLayout: async (exclude, options = {}) => {
            const localVarPath = `/api/v1/layout/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (exclude) {
                localVarQueryParameter["exclude"] = exclude;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets complete layout of organization, like workspaces, user-groups, etc.
         * @summary Set organization layout
         * @param {DeclarativeOrganization} declarativeOrganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrganizationLayout: async (declarativeOrganization, options = {}) => {
            // verify required parameter 'declarativeOrganization' is not null or undefined
            assertParamExists("setOrganizationLayout", "declarativeOrganization", declarativeOrganization);
            const localVarPath = `/api/v1/layout/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeOrganization !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeOrganization !== undefined ? declarativeOrganization : {})
                : declarativeOrganization || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * OrganizationDeclarativeAPIsApi - functional programming interface
 * @export
 */
export const OrganizationDeclarativeAPIsApiFp = function (configuration) {
    const localVarAxiosParamCreator = OrganizationDeclarativeAPIsApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieve complete layout of organization, workspaces, user-groups, etc.
         * @summary Get organization layout
         * @param {Array<'ACTIVITY_INFO'>} [exclude]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationLayout(exclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationLayout(exclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets complete layout of organization, like workspaces, user-groups, etc.
         * @summary Set organization layout
         * @param {DeclarativeOrganization} declarativeOrganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setOrganizationLayout(declarativeOrganization, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setOrganizationLayout(declarativeOrganization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * OrganizationDeclarativeAPIsApi - factory interface
 * @export
 */
export const OrganizationDeclarativeAPIsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = OrganizationDeclarativeAPIsApiFp(configuration);
    return {
        /**
         * Retrieve complete layout of organization, workspaces, user-groups, etc.
         * @summary Get organization layout
         * @param {OrganizationDeclarativeAPIsApiGetOrganizationLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationLayout(requestParameters, options) {
            return localVarFp
                .getOrganizationLayout(requestParameters.exclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Sets complete layout of organization, like workspaces, user-groups, etc.
         * @summary Set organization layout
         * @param {OrganizationDeclarativeAPIsApiSetOrganizationLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrganizationLayout(requestParameters, options) {
            return localVarFp
                .setOrganizationLayout(requestParameters.declarativeOrganization, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * OrganizationDeclarativeAPIsApi - object-oriented interface
 * @export
 * @class OrganizationDeclarativeAPIsApi
 * @extends {BaseAPI}
 */
export class OrganizationDeclarativeAPIsApi extends BaseAPI {
    /**
     * Retrieve complete layout of organization, workspaces, user-groups, etc.
     * @summary Get organization layout
     * @param {OrganizationDeclarativeAPIsApiGetOrganizationLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationDeclarativeAPIsApi
     */
    getOrganizationLayout(requestParameters = {}, options) {
        return OrganizationDeclarativeAPIsApiFp(this.configuration)
            .getOrganizationLayout(requestParameters.exclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets complete layout of organization, like workspaces, user-groups, etc.
     * @summary Set organization layout
     * @param {OrganizationDeclarativeAPIsApiSetOrganizationLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationDeclarativeAPIsApi
     */
    setOrganizationLayout(requestParameters, options) {
        return OrganizationDeclarativeAPIsApiFp(this.configuration)
            .setOrganizationLayout(requestParameters.declarativeOrganization, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * OrganizationEntityAPIsApi - axios parameter creator
 * @export
 */
export const OrganizationEntityAPIsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Post Organization Setting entities
         * @param {JsonApiOrganizationSettingInDocument} jsonApiOrganizationSettingInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityOrganizationSettings: async (jsonApiOrganizationSettingInDocument, options = {}) => {
            // verify required parameter 'jsonApiOrganizationSettingInDocument' is not null or undefined
            assertParamExists("createEntityOrganizationSettings", "jsonApiOrganizationSettingInDocument", jsonApiOrganizationSettingInDocument);
            const localVarPath = `/api/v1/entities/organizationSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiOrganizationSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiOrganizationSettingInDocument !== undefined
                    ? jsonApiOrganizationSettingInDocument
                    : {})
                : jsonApiOrganizationSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete Organization entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityOrganizationSettings: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityOrganizationSettings", "id", id);
            const localVarPath = `/api/v1/entities/organizationSettings/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Organization entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesOrganizationSettings: async (filter, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/organizationSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Organization entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityOrganizationSettings: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityOrganizationSettings", "id", id);
            const localVarPath = `/api/v1/entities/organizationSettings/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Organizations
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityOrganizations: async (id, filter, include, metaInclude, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityOrganizations", "id", id);
            const localVarPath = `/api/v1/entities/admin/organizations/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a basic information about organization.
         * @summary Get current organization info
         * @param {Array<'permissions' | 'all'>} [metaInclude] Return list of permissions available to logged user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: async (metaInclude, options = {}) => {
            const localVarPath = `/api/v1/entities/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch Organization entity
         * @param {string} id
         * @param {JsonApiOrganizationSettingPatchDocument} jsonApiOrganizationSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityOrganizationSettings: async (id, jsonApiOrganizationSettingPatchDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityOrganizationSettings", "id", id);
            // verify required parameter 'jsonApiOrganizationSettingPatchDocument' is not null or undefined
            assertParamExists("patchEntityOrganizationSettings", "jsonApiOrganizationSettingPatchDocument", jsonApiOrganizationSettingPatchDocument);
            const localVarPath = `/api/v1/entities/organizationSettings/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiOrganizationSettingPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiOrganizationSettingPatchDocument !== undefined
                    ? jsonApiOrganizationSettingPatchDocument
                    : {})
                : jsonApiOrganizationSettingPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch Organization
         * @param {string} id
         * @param {JsonApiOrganizationPatchDocument} jsonApiOrganizationPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityOrganizations: async (id, jsonApiOrganizationPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityOrganizations", "id", id);
            // verify required parameter 'jsonApiOrganizationPatchDocument' is not null or undefined
            assertParamExists("patchEntityOrganizations", "jsonApiOrganizationPatchDocument", jsonApiOrganizationPatchDocument);
            const localVarPath = `/api/v1/entities/admin/organizations/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiOrganizationPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiOrganizationPatchDocument !== undefined ? jsonApiOrganizationPatchDocument : {})
                : jsonApiOrganizationPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put Organization entity
         * @param {string} id
         * @param {JsonApiOrganizationSettingInDocument} jsonApiOrganizationSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityOrganizationSettings: async (id, jsonApiOrganizationSettingInDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityOrganizationSettings", "id", id);
            // verify required parameter 'jsonApiOrganizationSettingInDocument' is not null or undefined
            assertParamExists("updateEntityOrganizationSettings", "jsonApiOrganizationSettingInDocument", jsonApiOrganizationSettingInDocument);
            const localVarPath = `/api/v1/entities/organizationSettings/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiOrganizationSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiOrganizationSettingInDocument !== undefined
                    ? jsonApiOrganizationSettingInDocument
                    : {})
                : jsonApiOrganizationSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put Organization
         * @param {string} id
         * @param {JsonApiOrganizationInDocument} jsonApiOrganizationInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityOrganizations: async (id, jsonApiOrganizationInDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityOrganizations", "id", id);
            // verify required parameter 'jsonApiOrganizationInDocument' is not null or undefined
            assertParamExists("updateEntityOrganizations", "jsonApiOrganizationInDocument", jsonApiOrganizationInDocument);
            const localVarPath = `/api/v1/entities/admin/organizations/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiOrganizationInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiOrganizationInDocument !== undefined ? jsonApiOrganizationInDocument : {})
                : jsonApiOrganizationInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * OrganizationEntityAPIsApi - functional programming interface
 * @export
 */
export const OrganizationEntityAPIsApiFp = function (configuration) {
    const localVarAxiosParamCreator = OrganizationEntityAPIsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Post Organization Setting entities
         * @param {JsonApiOrganizationSettingInDocument} jsonApiOrganizationSettingInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityOrganizationSettings(jsonApiOrganizationSettingInDocument, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityOrganizationSettings(jsonApiOrganizationSettingInDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete Organization entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityOrganizationSettings(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityOrganizationSettings(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Organization entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesOrganizationSettings(filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesOrganizationSettings(filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Organization entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityOrganizationSettings(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityOrganizationSettings(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Organizations
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityOrganizations(id, filter, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityOrganizations(id, filter, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a basic information about organization.
         * @summary Get current organization info
         * @param {Array<'permissions' | 'all'>} [metaInclude] Return list of permissions available to logged user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganization(metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganization(metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch Organization entity
         * @param {string} id
         * @param {JsonApiOrganizationSettingPatchDocument} jsonApiOrganizationSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityOrganizationSettings(id, jsonApiOrganizationSettingPatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityOrganizationSettings(id, jsonApiOrganizationSettingPatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch Organization
         * @param {string} id
         * @param {JsonApiOrganizationPatchDocument} jsonApiOrganizationPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityOrganizations(id, jsonApiOrganizationPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityOrganizations(id, jsonApiOrganizationPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put Organization entity
         * @param {string} id
         * @param {JsonApiOrganizationSettingInDocument} jsonApiOrganizationSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityOrganizationSettings(id, jsonApiOrganizationSettingInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityOrganizationSettings(id, jsonApiOrganizationSettingInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put Organization
         * @param {string} id
         * @param {JsonApiOrganizationInDocument} jsonApiOrganizationInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityOrganizations(id, jsonApiOrganizationInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityOrganizations(id, jsonApiOrganizationInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * OrganizationEntityAPIsApi - factory interface
 * @export
 */
export const OrganizationEntityAPIsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = OrganizationEntityAPIsApiFp(configuration);
    return {
        /**
         *
         * @summary Post Organization Setting entities
         * @param {OrganizationEntityAPIsApiCreateEntityOrganizationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityOrganizationSettings(requestParameters, options) {
            return localVarFp
                .createEntityOrganizationSettings(requestParameters.jsonApiOrganizationSettingInDocument, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete Organization entity
         * @param {OrganizationEntityAPIsApiDeleteEntityOrganizationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityOrganizationSettings(requestParameters, options) {
            return localVarFp
                .deleteEntityOrganizationSettings(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Organization entities
         * @param {OrganizationEntityAPIsApiGetAllEntitiesOrganizationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesOrganizationSettings(requestParameters, options) {
            return localVarFp
                .getAllEntitiesOrganizationSettings(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Organization entity
         * @param {OrganizationEntityAPIsApiGetEntityOrganizationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityOrganizationSettings(requestParameters, options) {
            return localVarFp
                .getEntityOrganizationSettings(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Organizations
         * @param {OrganizationEntityAPIsApiGetEntityOrganizationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityOrganizations(requestParameters, options) {
            return localVarFp
                .getEntityOrganizations(requestParameters.id, requestParameters.filter, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Gets a basic information about organization.
         * @summary Get current organization info
         * @param {OrganizationEntityAPIsApiGetOrganizationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(requestParameters, options) {
            return localVarFp
                .getOrganization(requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch Organization entity
         * @param {OrganizationEntityAPIsApiPatchEntityOrganizationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityOrganizationSettings(requestParameters, options) {
            return localVarFp
                .patchEntityOrganizationSettings(requestParameters.id, requestParameters.jsonApiOrganizationSettingPatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch Organization
         * @param {OrganizationEntityAPIsApiPatchEntityOrganizationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityOrganizations(requestParameters, options) {
            return localVarFp
                .patchEntityOrganizations(requestParameters.id, requestParameters.jsonApiOrganizationPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put Organization entity
         * @param {OrganizationEntityAPIsApiUpdateEntityOrganizationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityOrganizationSettings(requestParameters, options) {
            return localVarFp
                .updateEntityOrganizationSettings(requestParameters.id, requestParameters.jsonApiOrganizationSettingInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put Organization
         * @param {OrganizationEntityAPIsApiUpdateEntityOrganizationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityOrganizations(requestParameters, options) {
            return localVarFp
                .updateEntityOrganizations(requestParameters.id, requestParameters.jsonApiOrganizationInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * OrganizationEntityAPIsApi - object-oriented interface
 * @export
 * @class OrganizationEntityAPIsApi
 * @extends {BaseAPI}
 */
export class OrganizationEntityAPIsApi extends BaseAPI {
    /**
     *
     * @summary Post Organization Setting entities
     * @param {OrganizationEntityAPIsApiCreateEntityOrganizationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationEntityAPIsApi
     */
    createEntityOrganizationSettings(requestParameters, options) {
        return OrganizationEntityAPIsApiFp(this.configuration)
            .createEntityOrganizationSettings(requestParameters.jsonApiOrganizationSettingInDocument, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete Organization entity
     * @param {OrganizationEntityAPIsApiDeleteEntityOrganizationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationEntityAPIsApi
     */
    deleteEntityOrganizationSettings(requestParameters, options) {
        return OrganizationEntityAPIsApiFp(this.configuration)
            .deleteEntityOrganizationSettings(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Organization entities
     * @param {OrganizationEntityAPIsApiGetAllEntitiesOrganizationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationEntityAPIsApi
     */
    getAllEntitiesOrganizationSettings(requestParameters = {}, options) {
        return OrganizationEntityAPIsApiFp(this.configuration)
            .getAllEntitiesOrganizationSettings(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Organization entity
     * @param {OrganizationEntityAPIsApiGetEntityOrganizationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationEntityAPIsApi
     */
    getEntityOrganizationSettings(requestParameters, options) {
        return OrganizationEntityAPIsApiFp(this.configuration)
            .getEntityOrganizationSettings(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Organizations
     * @param {OrganizationEntityAPIsApiGetEntityOrganizationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationEntityAPIsApi
     */
    getEntityOrganizations(requestParameters, options) {
        return OrganizationEntityAPIsApiFp(this.configuration)
            .getEntityOrganizations(requestParameters.id, requestParameters.filter, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets a basic information about organization.
     * @summary Get current organization info
     * @param {OrganizationEntityAPIsApiGetOrganizationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationEntityAPIsApi
     */
    getOrganization(requestParameters = {}, options) {
        return OrganizationEntityAPIsApiFp(this.configuration)
            .getOrganization(requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch Organization entity
     * @param {OrganizationEntityAPIsApiPatchEntityOrganizationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationEntityAPIsApi
     */
    patchEntityOrganizationSettings(requestParameters, options) {
        return OrganizationEntityAPIsApiFp(this.configuration)
            .patchEntityOrganizationSettings(requestParameters.id, requestParameters.jsonApiOrganizationSettingPatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch Organization
     * @param {OrganizationEntityAPIsApiPatchEntityOrganizationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationEntityAPIsApi
     */
    patchEntityOrganizations(requestParameters, options) {
        return OrganizationEntityAPIsApiFp(this.configuration)
            .patchEntityOrganizations(requestParameters.id, requestParameters.jsonApiOrganizationPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put Organization entity
     * @param {OrganizationEntityAPIsApiUpdateEntityOrganizationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationEntityAPIsApi
     */
    updateEntityOrganizationSettings(requestParameters, options) {
        return OrganizationEntityAPIsApiFp(this.configuration)
            .updateEntityOrganizationSettings(requestParameters.id, requestParameters.jsonApiOrganizationSettingInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put Organization
     * @param {OrganizationEntityAPIsApiUpdateEntityOrganizationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationEntityAPIsApi
     */
    updateEntityOrganizations(requestParameters, options) {
        return OrganizationEntityAPIsApiFp(this.configuration)
            .updateEntityOrganizations(requestParameters.id, requestParameters.jsonApiOrganizationInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * OrganizationModelControllerApi - axios parameter creator
 * @export
 */
export const OrganizationModelControllerApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Post Color Pallettes
         * @param {JsonApiColorPaletteInDocument} jsonApiColorPaletteInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityColorPalettes: async (jsonApiColorPaletteInDocument, options = {}) => {
            // verify required parameter 'jsonApiColorPaletteInDocument' is not null or undefined
            assertParamExists("createEntityColorPalettes", "jsonApiColorPaletteInDocument", jsonApiColorPaletteInDocument);
            const localVarPath = `/api/v1/entities/colorPalettes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiColorPaletteInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiColorPaletteInDocument !== undefined ? jsonApiColorPaletteInDocument : {})
                : jsonApiColorPaletteInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Context Security Police Directive
         * @summary Post CSP Directives
         * @param {JsonApiCspDirectiveInDocument} jsonApiCspDirectiveInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityCspDirectives: async (jsonApiCspDirectiveInDocument, options = {}) => {
            // verify required parameter 'jsonApiCspDirectiveInDocument' is not null or undefined
            assertParamExists("createEntityCspDirectives", "jsonApiCspDirectiveInDocument", jsonApiCspDirectiveInDocument);
            const localVarPath = `/api/v1/entities/cspDirectives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCspDirectiveInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCspDirectiveInDocument !== undefined ? jsonApiCspDirectiveInDocument : {})
                : jsonApiCspDirectiveInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Post Data Sources
         * @param {JsonApiDataSourceInDocument} jsonApiDataSourceInDocument
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityDataSources: async (jsonApiDataSourceInDocument, metaInclude, options = {}) => {
            // verify required parameter 'jsonApiDataSourceInDocument' is not null or undefined
            assertParamExists("createEntityDataSources", "jsonApiDataSourceInDocument", jsonApiDataSourceInDocument);
            const localVarPath = `/api/v1/entities/dataSources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiDataSourceInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiDataSourceInDocument !== undefined ? jsonApiDataSourceInDocument : {})
                : jsonApiDataSourceInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Post Jwks
         * @param {JsonApiJwkInDocument} jsonApiJwkInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityJwks: async (jsonApiJwkInDocument, options = {}) => {
            // verify required parameter 'jsonApiJwkInDocument' is not null or undefined
            assertParamExists("createEntityJwks", "jsonApiJwkInDocument", jsonApiJwkInDocument);
            const localVarPath = `/api/v1/entities/jwks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiJwkInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiJwkInDocument !== undefined ? jsonApiJwkInDocument : {})
                : jsonApiJwkInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Organization Setting entities
         * @param {JsonApiOrganizationSettingInDocument} jsonApiOrganizationSettingInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityOrganizationSettings: async (jsonApiOrganizationSettingInDocument, options = {}) => {
            // verify required parameter 'jsonApiOrganizationSettingInDocument' is not null or undefined
            assertParamExists("createEntityOrganizationSettings", "jsonApiOrganizationSettingInDocument", jsonApiOrganizationSettingInDocument);
            const localVarPath = `/api/v1/entities/organizationSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiOrganizationSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiOrganizationSettingInDocument !== undefined
                    ? jsonApiOrganizationSettingInDocument
                    : {})
                : jsonApiOrganizationSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Theming
         * @param {JsonApiThemeInDocument} jsonApiThemeInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityThemes: async (jsonApiThemeInDocument, options = {}) => {
            // verify required parameter 'jsonApiThemeInDocument' is not null or undefined
            assertParamExists("createEntityThemes", "jsonApiThemeInDocument", jsonApiThemeInDocument);
            const localVarPath = `/api/v1/entities/themes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiThemeInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiThemeInDocument !== undefined ? jsonApiThemeInDocument : {})
                : jsonApiThemeInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Post User Group entities
         * @param {JsonApiUserGroupInDocument} jsonApiUserGroupInDocument
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUserGroups: async (jsonApiUserGroupInDocument, include, options = {}) => {
            // verify required parameter 'jsonApiUserGroupInDocument' is not null or undefined
            assertParamExists("createEntityUserGroups", "jsonApiUserGroupInDocument", jsonApiUserGroupInDocument);
            const localVarPath = `/api/v1/entities/userGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserGroupInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserGroupInDocument !== undefined ? jsonApiUserGroupInDocument : {})
                : jsonApiUserGroupInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User - represents entity interacting with platform
         * @summary Post User entities
         * @param {JsonApiUserInDocument} jsonApiUserInDocument
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUsers: async (jsonApiUserInDocument, include, options = {}) => {
            // verify required parameter 'jsonApiUserInDocument' is not null or undefined
            assertParamExists("createEntityUsers", "jsonApiUserInDocument", jsonApiUserInDocument);
            const localVarPath = `/api/v1/entities/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserInDocument !== undefined ? jsonApiUserInDocument : {})
                : jsonApiUserInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Space of the shared interest
         * @summary Post Workspace entities
         * @param {JsonApiWorkspaceInDocument} jsonApiWorkspaceInDocument
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaces: async (jsonApiWorkspaceInDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'jsonApiWorkspaceInDocument' is not null or undefined
            assertParamExists("createEntityWorkspaces", "jsonApiWorkspaceInDocument", jsonApiWorkspaceInDocument);
            const localVarPath = `/api/v1/entities/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceInDocument !== undefined ? jsonApiWorkspaceInDocument : {})
                : jsonApiWorkspaceInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Color Pallette
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityColorPalettes: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityColorPalettes", "id", id);
            const localVarPath = `/api/v1/entities/colorPalettes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Context Security Police Directive
         * @summary Delete CSP Directives
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityCspDirectives: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityCspDirectives", "id", id);
            const localVarPath = `/api/v1/entities/cspDirectives/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Delete Data Source entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityDataSources: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityDataSources", "id", id);
            const localVarPath = `/api/v1/entities/dataSources/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Delete Jwk
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityJwks: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityJwks", "id", id);
            const localVarPath = `/api/v1/entities/jwks/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete Organization entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityOrganizationSettings: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityOrganizationSettings", "id", id);
            const localVarPath = `/api/v1/entities/organizationSettings/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete Theming
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityThemes: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityThemes", "id", id);
            const localVarPath = `/api/v1/entities/themes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Delete UserGroup entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUserGroups: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityUserGroups", "id", id);
            const localVarPath = `/api/v1/entities/userGroups/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User - represents entity interacting with platform
         * @summary Delete User entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUsers: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityUsers", "id", id);
            const localVarPath = `/api/v1/entities/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Space of the shared interest
         * @summary Delete Workspace entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaces: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityWorkspaces", "id", id);
            const localVarPath = `/api/v1/entities/workspaces/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Color Pallettes
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesColorPalettes: async (filter, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/colorPalettes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Context Security Police Directive
         * @summary Get CSP Directives
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesCspDirectives: async (filter, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/cspDirectives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Data Source Identifiers
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSourceIdentifiers: async (filter, page, size, sort, metaInclude, options = {}) => {
            const localVarPath = `/api/v1/entities/dataSourceIdentifiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Get Data Source entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSources: async (filter, page, size, sort, metaInclude, options = {}) => {
            const localVarPath = `/api/v1/entities/dataSources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Space of the shared interest
         * @summary Get Entitlements
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesEntitlements: async (filter, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/entitlements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all JSON web keys - used to verify JSON web tokens (Jwts)
         * @summary Get all Jwks
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesJwks: async (filter, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/jwks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Organization entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesOrganizationSettings: async (filter, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/organizationSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Theming entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesThemes: async (filter, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/themes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Get UserGroup entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserGroups: async (filter, include, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/userGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * UserIdentifier - represents entity interacting with platform
         * @summary Get UserIdentifier entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserIdentifiers: async (filter, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/userIdentifiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User - represents entity interacting with platform
         * @summary Get User entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUsers: async (filter, include, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Space of the shared interest
         * @summary Get Workspace entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaces: async (filter, include, page, size, sort, metaInclude, options = {}) => {
            const localVarPath = `/api/v1/entities/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Color Pallette
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityColorPalettes: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityColorPalettes", "id", id);
            const localVarPath = `/api/v1/entities/colorPalettes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Context Security Police Directive
         * @summary Get CSP Directives
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityCspDirectives: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityCspDirectives", "id", id);
            const localVarPath = `/api/v1/entities/cspDirectives/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Data Source Identifier
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSourceIdentifiers: async (id, filter, metaInclude, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityDataSourceIdentifiers", "id", id);
            const localVarPath = `/api/v1/entities/dataSourceIdentifiers/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Get Data Source entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSources: async (id, filter, metaInclude, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityDataSources", "id", id);
            const localVarPath = `/api/v1/entities/dataSources/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Space of the shared interest
         * @summary Get Entitlement
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityEntitlements: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityEntitlements", "id", id);
            const localVarPath = `/api/v1/entities/entitlements/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Get Jwk
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityJwks: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityJwks", "id", id);
            const localVarPath = `/api/v1/entities/jwks/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Organization entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityOrganizationSettings: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityOrganizationSettings", "id", id);
            const localVarPath = `/api/v1/entities/organizationSettings/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Theming
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityThemes: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityThemes", "id", id);
            const localVarPath = `/api/v1/entities/themes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Get UserGroup entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserGroups: async (id, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityUserGroups", "id", id);
            const localVarPath = `/api/v1/entities/userGroups/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * UserIdentifier - represents basic informationZ about entity interacting with platform
         * @summary Get UserIdentifier entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserIdentifiers: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityUserIdentifiers", "id", id);
            const localVarPath = `/api/v1/entities/userIdentifiers/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User - represents entity interacting with platform
         * @summary Get User entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUsers: async (id, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityUsers", "id", id);
            const localVarPath = `/api/v1/entities/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Space of the shared interest
         * @summary Get Workspace entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaces: async (id, filter, include, metaInclude, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityWorkspaces", "id", id);
            const localVarPath = `/api/v1/entities/workspaces/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch Color Pallette
         * @param {string} id
         * @param {JsonApiColorPalettePatchDocument} jsonApiColorPalettePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityColorPalettes: async (id, jsonApiColorPalettePatchDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityColorPalettes", "id", id);
            // verify required parameter 'jsonApiColorPalettePatchDocument' is not null or undefined
            assertParamExists("patchEntityColorPalettes", "jsonApiColorPalettePatchDocument", jsonApiColorPalettePatchDocument);
            const localVarPath = `/api/v1/entities/colorPalettes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiColorPalettePatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiColorPalettePatchDocument !== undefined ? jsonApiColorPalettePatchDocument : {})
                : jsonApiColorPalettePatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Context Security Police Directive
         * @summary Patch CSP Directives
         * @param {string} id
         * @param {JsonApiCspDirectivePatchDocument} jsonApiCspDirectivePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityCspDirectives: async (id, jsonApiCspDirectivePatchDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityCspDirectives", "id", id);
            // verify required parameter 'jsonApiCspDirectivePatchDocument' is not null or undefined
            assertParamExists("patchEntityCspDirectives", "jsonApiCspDirectivePatchDocument", jsonApiCspDirectivePatchDocument);
            const localVarPath = `/api/v1/entities/cspDirectives/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCspDirectivePatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCspDirectivePatchDocument !== undefined ? jsonApiCspDirectivePatchDocument : {})
                : jsonApiCspDirectivePatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Patch Data Source entity
         * @param {string} id
         * @param {JsonApiDataSourcePatchDocument} jsonApiDataSourcePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityDataSources: async (id, jsonApiDataSourcePatchDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityDataSources", "id", id);
            // verify required parameter 'jsonApiDataSourcePatchDocument' is not null or undefined
            assertParamExists("patchEntityDataSources", "jsonApiDataSourcePatchDocument", jsonApiDataSourcePatchDocument);
            const localVarPath = `/api/v1/entities/dataSources/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiDataSourcePatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiDataSourcePatchDocument !== undefined ? jsonApiDataSourcePatchDocument : {})
                : jsonApiDataSourcePatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Patches JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Patch Jwk
         * @param {string} id
         * @param {JsonApiJwkPatchDocument} jsonApiJwkPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityJwks: async (id, jsonApiJwkPatchDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityJwks", "id", id);
            // verify required parameter 'jsonApiJwkPatchDocument' is not null or undefined
            assertParamExists("patchEntityJwks", "jsonApiJwkPatchDocument", jsonApiJwkPatchDocument);
            const localVarPath = `/api/v1/entities/jwks/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiJwkPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiJwkPatchDocument !== undefined ? jsonApiJwkPatchDocument : {})
                : jsonApiJwkPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch Organization entity
         * @param {string} id
         * @param {JsonApiOrganizationSettingPatchDocument} jsonApiOrganizationSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityOrganizationSettings: async (id, jsonApiOrganizationSettingPatchDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityOrganizationSettings", "id", id);
            // verify required parameter 'jsonApiOrganizationSettingPatchDocument' is not null or undefined
            assertParamExists("patchEntityOrganizationSettings", "jsonApiOrganizationSettingPatchDocument", jsonApiOrganizationSettingPatchDocument);
            const localVarPath = `/api/v1/entities/organizationSettings/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiOrganizationSettingPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiOrganizationSettingPatchDocument !== undefined
                    ? jsonApiOrganizationSettingPatchDocument
                    : {})
                : jsonApiOrganizationSettingPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch Theming
         * @param {string} id
         * @param {JsonApiThemePatchDocument} jsonApiThemePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityThemes: async (id, jsonApiThemePatchDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityThemes", "id", id);
            // verify required parameter 'jsonApiThemePatchDocument' is not null or undefined
            assertParamExists("patchEntityThemes", "jsonApiThemePatchDocument", jsonApiThemePatchDocument);
            const localVarPath = `/api/v1/entities/themes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiThemePatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiThemePatchDocument !== undefined ? jsonApiThemePatchDocument : {})
                : jsonApiThemePatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Patch UserGroup entity
         * @param {string} id
         * @param {JsonApiUserGroupPatchDocument} jsonApiUserGroupPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUserGroups: async (id, jsonApiUserGroupPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityUserGroups", "id", id);
            // verify required parameter 'jsonApiUserGroupPatchDocument' is not null or undefined
            assertParamExists("patchEntityUserGroups", "jsonApiUserGroupPatchDocument", jsonApiUserGroupPatchDocument);
            const localVarPath = `/api/v1/entities/userGroups/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserGroupPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserGroupPatchDocument !== undefined ? jsonApiUserGroupPatchDocument : {})
                : jsonApiUserGroupPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User - represents entity interacting with platform
         * @summary Patch User entity
         * @param {string} id
         * @param {JsonApiUserPatchDocument} jsonApiUserPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUsers: async (id, jsonApiUserPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityUsers", "id", id);
            // verify required parameter 'jsonApiUserPatchDocument' is not null or undefined
            assertParamExists("patchEntityUsers", "jsonApiUserPatchDocument", jsonApiUserPatchDocument);
            const localVarPath = `/api/v1/entities/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserPatchDocument !== undefined ? jsonApiUserPatchDocument : {})
                : jsonApiUserPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Space of the shared interest
         * @summary Patch Workspace entity
         * @param {string} id
         * @param {JsonApiWorkspacePatchDocument} jsonApiWorkspacePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaces: async (id, jsonApiWorkspacePatchDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityWorkspaces", "id", id);
            // verify required parameter 'jsonApiWorkspacePatchDocument' is not null or undefined
            assertParamExists("patchEntityWorkspaces", "jsonApiWorkspacePatchDocument", jsonApiWorkspacePatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspacePatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspacePatchDocument !== undefined ? jsonApiWorkspacePatchDocument : {})
                : jsonApiWorkspacePatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put Color Pallette
         * @param {string} id
         * @param {JsonApiColorPaletteInDocument} jsonApiColorPaletteInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityColorPalettes: async (id, jsonApiColorPaletteInDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityColorPalettes", "id", id);
            // verify required parameter 'jsonApiColorPaletteInDocument' is not null or undefined
            assertParamExists("updateEntityColorPalettes", "jsonApiColorPaletteInDocument", jsonApiColorPaletteInDocument);
            const localVarPath = `/api/v1/entities/colorPalettes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiColorPaletteInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiColorPaletteInDocument !== undefined ? jsonApiColorPaletteInDocument : {})
                : jsonApiColorPaletteInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Context Security Police Directive
         * @summary Put CSP Directives
         * @param {string} id
         * @param {JsonApiCspDirectiveInDocument} jsonApiCspDirectiveInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityCspDirectives: async (id, jsonApiCspDirectiveInDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityCspDirectives", "id", id);
            // verify required parameter 'jsonApiCspDirectiveInDocument' is not null or undefined
            assertParamExists("updateEntityCspDirectives", "jsonApiCspDirectiveInDocument", jsonApiCspDirectiveInDocument);
            const localVarPath = `/api/v1/entities/cspDirectives/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCspDirectiveInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCspDirectiveInDocument !== undefined ? jsonApiCspDirectiveInDocument : {})
                : jsonApiCspDirectiveInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Put Data Source entity
         * @param {string} id
         * @param {JsonApiDataSourceInDocument} jsonApiDataSourceInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityDataSources: async (id, jsonApiDataSourceInDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityDataSources", "id", id);
            // verify required parameter 'jsonApiDataSourceInDocument' is not null or undefined
            assertParamExists("updateEntityDataSources", "jsonApiDataSourceInDocument", jsonApiDataSourceInDocument);
            const localVarPath = `/api/v1/entities/dataSources/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiDataSourceInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiDataSourceInDocument !== undefined ? jsonApiDataSourceInDocument : {})
                : jsonApiDataSourceInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Put Jwk
         * @param {string} id
         * @param {JsonApiJwkInDocument} jsonApiJwkInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityJwks: async (id, jsonApiJwkInDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityJwks", "id", id);
            // verify required parameter 'jsonApiJwkInDocument' is not null or undefined
            assertParamExists("updateEntityJwks", "jsonApiJwkInDocument", jsonApiJwkInDocument);
            const localVarPath = `/api/v1/entities/jwks/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiJwkInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiJwkInDocument !== undefined ? jsonApiJwkInDocument : {})
                : jsonApiJwkInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put Organization entity
         * @param {string} id
         * @param {JsonApiOrganizationSettingInDocument} jsonApiOrganizationSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityOrganizationSettings: async (id, jsonApiOrganizationSettingInDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityOrganizationSettings", "id", id);
            // verify required parameter 'jsonApiOrganizationSettingInDocument' is not null or undefined
            assertParamExists("updateEntityOrganizationSettings", "jsonApiOrganizationSettingInDocument", jsonApiOrganizationSettingInDocument);
            const localVarPath = `/api/v1/entities/organizationSettings/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiOrganizationSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiOrganizationSettingInDocument !== undefined
                    ? jsonApiOrganizationSettingInDocument
                    : {})
                : jsonApiOrganizationSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put Theming
         * @param {string} id
         * @param {JsonApiThemeInDocument} jsonApiThemeInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityThemes: async (id, jsonApiThemeInDocument, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityThemes", "id", id);
            // verify required parameter 'jsonApiThemeInDocument' is not null or undefined
            assertParamExists("updateEntityThemes", "jsonApiThemeInDocument", jsonApiThemeInDocument);
            const localVarPath = `/api/v1/entities/themes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiThemeInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiThemeInDocument !== undefined ? jsonApiThemeInDocument : {})
                : jsonApiThemeInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Put UserGroup entity
         * @param {string} id
         * @param {JsonApiUserGroupInDocument} jsonApiUserGroupInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUserGroups: async (id, jsonApiUserGroupInDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityUserGroups", "id", id);
            // verify required parameter 'jsonApiUserGroupInDocument' is not null or undefined
            assertParamExists("updateEntityUserGroups", "jsonApiUserGroupInDocument", jsonApiUserGroupInDocument);
            const localVarPath = `/api/v1/entities/userGroups/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserGroupInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserGroupInDocument !== undefined ? jsonApiUserGroupInDocument : {})
                : jsonApiUserGroupInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User - represents entity interacting with platform
         * @summary Put User entity
         * @param {string} id
         * @param {JsonApiUserInDocument} jsonApiUserInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUsers: async (id, jsonApiUserInDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityUsers", "id", id);
            // verify required parameter 'jsonApiUserInDocument' is not null or undefined
            assertParamExists("updateEntityUsers", "jsonApiUserInDocument", jsonApiUserInDocument);
            const localVarPath = `/api/v1/entities/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserInDocument !== undefined ? jsonApiUserInDocument : {})
                : jsonApiUserInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Space of the shared interest
         * @summary Put Workspace entity
         * @param {string} id
         * @param {JsonApiWorkspaceInDocument} jsonApiWorkspaceInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaces: async (id, jsonApiWorkspaceInDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityWorkspaces", "id", id);
            // verify required parameter 'jsonApiWorkspaceInDocument' is not null or undefined
            assertParamExists("updateEntityWorkspaces", "jsonApiWorkspaceInDocument", jsonApiWorkspaceInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceInDocument !== undefined ? jsonApiWorkspaceInDocument : {})
                : jsonApiWorkspaceInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * OrganizationModelControllerApi - functional programming interface
 * @export
 */
export const OrganizationModelControllerApiFp = function (configuration) {
    const localVarAxiosParamCreator = OrganizationModelControllerApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Post Color Pallettes
         * @param {JsonApiColorPaletteInDocument} jsonApiColorPaletteInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityColorPalettes(jsonApiColorPaletteInDocument, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityColorPalettes(jsonApiColorPaletteInDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Context Security Police Directive
         * @summary Post CSP Directives
         * @param {JsonApiCspDirectiveInDocument} jsonApiCspDirectiveInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityCspDirectives(jsonApiCspDirectiveInDocument, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityCspDirectives(jsonApiCspDirectiveInDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Post Data Sources
         * @param {JsonApiDataSourceInDocument} jsonApiDataSourceInDocument
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityDataSources(jsonApiDataSourceInDocument, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityDataSources(jsonApiDataSourceInDocument, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Post Jwks
         * @param {JsonApiJwkInDocument} jsonApiJwkInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityJwks(jsonApiJwkInDocument, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityJwks(jsonApiJwkInDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Organization Setting entities
         * @param {JsonApiOrganizationSettingInDocument} jsonApiOrganizationSettingInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityOrganizationSettings(jsonApiOrganizationSettingInDocument, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityOrganizationSettings(jsonApiOrganizationSettingInDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Theming
         * @param {JsonApiThemeInDocument} jsonApiThemeInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityThemes(jsonApiThemeInDocument, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityThemes(jsonApiThemeInDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Post User Group entities
         * @param {JsonApiUserGroupInDocument} jsonApiUserGroupInDocument
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityUserGroups(jsonApiUserGroupInDocument, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityUserGroups(jsonApiUserGroupInDocument, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User - represents entity interacting with platform
         * @summary Post User entities
         * @param {JsonApiUserInDocument} jsonApiUserInDocument
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityUsers(jsonApiUserInDocument, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityUsers(jsonApiUserInDocument, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Space of the shared interest
         * @summary Post Workspace entities
         * @param {JsonApiWorkspaceInDocument} jsonApiWorkspaceInDocument
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityWorkspaces(jsonApiWorkspaceInDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityWorkspaces(jsonApiWorkspaceInDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Color Pallette
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityColorPalettes(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityColorPalettes(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Context Security Police Directive
         * @summary Delete CSP Directives
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityCspDirectives(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityCspDirectives(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Delete Data Source entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityDataSources(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityDataSources(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Delete Jwk
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityJwks(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityJwks(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete Organization entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityOrganizationSettings(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityOrganizationSettings(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete Theming
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityThemes(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityThemes(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Delete UserGroup entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityUserGroups(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityUserGroups(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User - represents entity interacting with platform
         * @summary Delete User entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityUsers(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityUsers(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Space of the shared interest
         * @summary Delete Workspace entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityWorkspaces(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityWorkspaces(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Color Pallettes
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesColorPalettes(filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesColorPalettes(filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Context Security Police Directive
         * @summary Get CSP Directives
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesCspDirectives(filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesCspDirectives(filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Data Source Identifiers
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesDataSourceIdentifiers(filter, page, size, sort, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesDataSourceIdentifiers(filter, page, size, sort, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Get Data Source entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesDataSources(filter, page, size, sort, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesDataSources(filter, page, size, sort, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Space of the shared interest
         * @summary Get Entitlements
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesEntitlements(filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesEntitlements(filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all JSON web keys - used to verify JSON web tokens (Jwts)
         * @summary Get all Jwks
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesJwks(filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesJwks(filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Organization entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesOrganizationSettings(filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesOrganizationSettings(filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Theming entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesThemes(filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesThemes(filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Get UserGroup entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesUserGroups(filter, include, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesUserGroups(filter, include, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * UserIdentifier - represents entity interacting with platform
         * @summary Get UserIdentifier entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesUserIdentifiers(filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesUserIdentifiers(filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User - represents entity interacting with platform
         * @summary Get User entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesUsers(filter, include, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesUsers(filter, include, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Space of the shared interest
         * @summary Get Workspace entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesWorkspaces(filter, include, page, size, sort, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesWorkspaces(filter, include, page, size, sort, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Color Pallette
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityColorPalettes(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityColorPalettes(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Context Security Police Directive
         * @summary Get CSP Directives
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityCspDirectives(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityCspDirectives(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Data Source Identifier
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityDataSourceIdentifiers(id, filter, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityDataSourceIdentifiers(id, filter, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Get Data Source entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityDataSources(id, filter, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityDataSources(id, filter, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Space of the shared interest
         * @summary Get Entitlement
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityEntitlements(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityEntitlements(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Get Jwk
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityJwks(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityJwks(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Organization entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityOrganizationSettings(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityOrganizationSettings(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Theming
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityThemes(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityThemes(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Get UserGroup entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityUserGroups(id, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityUserGroups(id, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * UserIdentifier - represents basic informationZ about entity interacting with platform
         * @summary Get UserIdentifier entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityUserIdentifiers(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityUserIdentifiers(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User - represents entity interacting with platform
         * @summary Get User entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityUsers(id, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityUsers(id, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Space of the shared interest
         * @summary Get Workspace entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityWorkspaces(id, filter, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityWorkspaces(id, filter, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch Color Pallette
         * @param {string} id
         * @param {JsonApiColorPalettePatchDocument} jsonApiColorPalettePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityColorPalettes(id, jsonApiColorPalettePatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityColorPalettes(id, jsonApiColorPalettePatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Context Security Police Directive
         * @summary Patch CSP Directives
         * @param {string} id
         * @param {JsonApiCspDirectivePatchDocument} jsonApiCspDirectivePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityCspDirectives(id, jsonApiCspDirectivePatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityCspDirectives(id, jsonApiCspDirectivePatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Patch Data Source entity
         * @param {string} id
         * @param {JsonApiDataSourcePatchDocument} jsonApiDataSourcePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityDataSources(id, jsonApiDataSourcePatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityDataSources(id, jsonApiDataSourcePatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Patches JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Patch Jwk
         * @param {string} id
         * @param {JsonApiJwkPatchDocument} jsonApiJwkPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityJwks(id, jsonApiJwkPatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityJwks(id, jsonApiJwkPatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch Organization entity
         * @param {string} id
         * @param {JsonApiOrganizationSettingPatchDocument} jsonApiOrganizationSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityOrganizationSettings(id, jsonApiOrganizationSettingPatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityOrganizationSettings(id, jsonApiOrganizationSettingPatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch Theming
         * @param {string} id
         * @param {JsonApiThemePatchDocument} jsonApiThemePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityThemes(id, jsonApiThemePatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityThemes(id, jsonApiThemePatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Patch UserGroup entity
         * @param {string} id
         * @param {JsonApiUserGroupPatchDocument} jsonApiUserGroupPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityUserGroups(id, jsonApiUserGroupPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityUserGroups(id, jsonApiUserGroupPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User - represents entity interacting with platform
         * @summary Patch User entity
         * @param {string} id
         * @param {JsonApiUserPatchDocument} jsonApiUserPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityUsers(id, jsonApiUserPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityUsers(id, jsonApiUserPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Space of the shared interest
         * @summary Patch Workspace entity
         * @param {string} id
         * @param {JsonApiWorkspacePatchDocument} jsonApiWorkspacePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityWorkspaces(id, jsonApiWorkspacePatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityWorkspaces(id, jsonApiWorkspacePatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put Color Pallette
         * @param {string} id
         * @param {JsonApiColorPaletteInDocument} jsonApiColorPaletteInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityColorPalettes(id, jsonApiColorPaletteInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityColorPalettes(id, jsonApiColorPaletteInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Context Security Police Directive
         * @summary Put CSP Directives
         * @param {string} id
         * @param {JsonApiCspDirectiveInDocument} jsonApiCspDirectiveInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityCspDirectives(id, jsonApiCspDirectiveInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityCspDirectives(id, jsonApiCspDirectiveInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Put Data Source entity
         * @param {string} id
         * @param {JsonApiDataSourceInDocument} jsonApiDataSourceInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityDataSources(id, jsonApiDataSourceInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityDataSources(id, jsonApiDataSourceInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Put Jwk
         * @param {string} id
         * @param {JsonApiJwkInDocument} jsonApiJwkInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityJwks(id, jsonApiJwkInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityJwks(id, jsonApiJwkInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put Organization entity
         * @param {string} id
         * @param {JsonApiOrganizationSettingInDocument} jsonApiOrganizationSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityOrganizationSettings(id, jsonApiOrganizationSettingInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityOrganizationSettings(id, jsonApiOrganizationSettingInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put Theming
         * @param {string} id
         * @param {JsonApiThemeInDocument} jsonApiThemeInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityThemes(id, jsonApiThemeInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityThemes(id, jsonApiThemeInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Put UserGroup entity
         * @param {string} id
         * @param {JsonApiUserGroupInDocument} jsonApiUserGroupInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityUserGroups(id, jsonApiUserGroupInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityUserGroups(id, jsonApiUserGroupInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User - represents entity interacting with platform
         * @summary Put User entity
         * @param {string} id
         * @param {JsonApiUserInDocument} jsonApiUserInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityUsers(id, jsonApiUserInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityUsers(id, jsonApiUserInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Space of the shared interest
         * @summary Put Workspace entity
         * @param {string} id
         * @param {JsonApiWorkspaceInDocument} jsonApiWorkspaceInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityWorkspaces(id, jsonApiWorkspaceInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityWorkspaces(id, jsonApiWorkspaceInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * OrganizationModelControllerApi - factory interface
 * @export
 */
export const OrganizationModelControllerApiFactory = function (configuration, basePath, axios) {
    const localVarFp = OrganizationModelControllerApiFp(configuration);
    return {
        /**
         *
         * @summary Post Color Pallettes
         * @param {OrganizationModelControllerApiCreateEntityColorPalettesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityColorPalettes(requestParameters, options) {
            return localVarFp
                .createEntityColorPalettes(requestParameters.jsonApiColorPaletteInDocument, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *  Context Security Police Directive
         * @summary Post CSP Directives
         * @param {OrganizationModelControllerApiCreateEntityCspDirectivesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityCspDirectives(requestParameters, options) {
            return localVarFp
                .createEntityCspDirectives(requestParameters.jsonApiCspDirectiveInDocument, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Post Data Sources
         * @param {OrganizationModelControllerApiCreateEntityDataSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityDataSources(requestParameters, options) {
            return localVarFp
                .createEntityDataSources(requestParameters.jsonApiDataSourceInDocument, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Creates JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Post Jwks
         * @param {OrganizationModelControllerApiCreateEntityJwksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityJwks(requestParameters, options) {
            return localVarFp
                .createEntityJwks(requestParameters.jsonApiJwkInDocument, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Organization Setting entities
         * @param {OrganizationModelControllerApiCreateEntityOrganizationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityOrganizationSettings(requestParameters, options) {
            return localVarFp
                .createEntityOrganizationSettings(requestParameters.jsonApiOrganizationSettingInDocument, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Theming
         * @param {OrganizationModelControllerApiCreateEntityThemesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityThemes(requestParameters, options) {
            return localVarFp
                .createEntityThemes(requestParameters.jsonApiThemeInDocument, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Post User Group entities
         * @param {OrganizationModelControllerApiCreateEntityUserGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUserGroups(requestParameters, options) {
            return localVarFp
                .createEntityUserGroups(requestParameters.jsonApiUserGroupInDocument, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User - represents entity interacting with platform
         * @summary Post User entities
         * @param {OrganizationModelControllerApiCreateEntityUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUsers(requestParameters, options) {
            return localVarFp
                .createEntityUsers(requestParameters.jsonApiUserInDocument, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Space of the shared interest
         * @summary Post Workspace entities
         * @param {OrganizationModelControllerApiCreateEntityWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaces(requestParameters, options) {
            return localVarFp
                .createEntityWorkspaces(requestParameters.jsonApiWorkspaceInDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Color Pallette
         * @param {OrganizationModelControllerApiDeleteEntityColorPalettesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityColorPalettes(requestParameters, options) {
            return localVarFp
                .deleteEntityColorPalettes(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *  Context Security Police Directive
         * @summary Delete CSP Directives
         * @param {OrganizationModelControllerApiDeleteEntityCspDirectivesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityCspDirectives(requestParameters, options) {
            return localVarFp
                .deleteEntityCspDirectives(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Delete Data Source entity
         * @param {OrganizationModelControllerApiDeleteEntityDataSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityDataSources(requestParameters, options) {
            return localVarFp
                .deleteEntityDataSources(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Deletes JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Delete Jwk
         * @param {OrganizationModelControllerApiDeleteEntityJwksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityJwks(requestParameters, options) {
            return localVarFp
                .deleteEntityJwks(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete Organization entity
         * @param {OrganizationModelControllerApiDeleteEntityOrganizationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityOrganizationSettings(requestParameters, options) {
            return localVarFp
                .deleteEntityOrganizationSettings(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete Theming
         * @param {OrganizationModelControllerApiDeleteEntityThemesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityThemes(requestParameters, options) {
            return localVarFp
                .deleteEntityThemes(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Delete UserGroup entity
         * @param {OrganizationModelControllerApiDeleteEntityUserGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUserGroups(requestParameters, options) {
            return localVarFp
                .deleteEntityUserGroups(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User - represents entity interacting with platform
         * @summary Delete User entity
         * @param {OrganizationModelControllerApiDeleteEntityUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUsers(requestParameters, options) {
            return localVarFp
                .deleteEntityUsers(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Space of the shared interest
         * @summary Delete Workspace entity
         * @param {OrganizationModelControllerApiDeleteEntityWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaces(requestParameters, options) {
            return localVarFp
                .deleteEntityWorkspaces(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Color Pallettes
         * @param {OrganizationModelControllerApiGetAllEntitiesColorPalettesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesColorPalettes(requestParameters, options) {
            return localVarFp
                .getAllEntitiesColorPalettes(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *  Context Security Police Directive
         * @summary Get CSP Directives
         * @param {OrganizationModelControllerApiGetAllEntitiesCspDirectivesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesCspDirectives(requestParameters, options) {
            return localVarFp
                .getAllEntitiesCspDirectives(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Data Source Identifiers
         * @param {OrganizationModelControllerApiGetAllEntitiesDataSourceIdentifiersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSourceIdentifiers(requestParameters, options) {
            return localVarFp
                .getAllEntitiesDataSourceIdentifiers(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Get Data Source entities
         * @param {OrganizationModelControllerApiGetAllEntitiesDataSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSources(requestParameters, options) {
            return localVarFp
                .getAllEntitiesDataSources(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Space of the shared interest
         * @summary Get Entitlements
         * @param {OrganizationModelControllerApiGetAllEntitiesEntitlementsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesEntitlements(requestParameters, options) {
            return localVarFp
                .getAllEntitiesEntitlements(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns all JSON web keys - used to verify JSON web tokens (Jwts)
         * @summary Get all Jwks
         * @param {OrganizationModelControllerApiGetAllEntitiesJwksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesJwks(requestParameters, options) {
            return localVarFp
                .getAllEntitiesJwks(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Organization entities
         * @param {OrganizationModelControllerApiGetAllEntitiesOrganizationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesOrganizationSettings(requestParameters, options) {
            return localVarFp
                .getAllEntitiesOrganizationSettings(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Theming entities
         * @param {OrganizationModelControllerApiGetAllEntitiesThemesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesThemes(requestParameters, options) {
            return localVarFp
                .getAllEntitiesThemes(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Get UserGroup entities
         * @param {OrganizationModelControllerApiGetAllEntitiesUserGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserGroups(requestParameters, options) {
            return localVarFp
                .getAllEntitiesUserGroups(requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * UserIdentifier - represents entity interacting with platform
         * @summary Get UserIdentifier entities
         * @param {OrganizationModelControllerApiGetAllEntitiesUserIdentifiersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserIdentifiers(requestParameters, options) {
            return localVarFp
                .getAllEntitiesUserIdentifiers(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User - represents entity interacting with platform
         * @summary Get User entities
         * @param {OrganizationModelControllerApiGetAllEntitiesUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUsers(requestParameters, options) {
            return localVarFp
                .getAllEntitiesUsers(requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Space of the shared interest
         * @summary Get Workspace entities
         * @param {OrganizationModelControllerApiGetAllEntitiesWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaces(requestParameters, options) {
            return localVarFp
                .getAllEntitiesWorkspaces(requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Color Pallette
         * @param {OrganizationModelControllerApiGetEntityColorPalettesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityColorPalettes(requestParameters, options) {
            return localVarFp
                .getEntityColorPalettes(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *  Context Security Police Directive
         * @summary Get CSP Directives
         * @param {OrganizationModelControllerApiGetEntityCspDirectivesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityCspDirectives(requestParameters, options) {
            return localVarFp
                .getEntityCspDirectives(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Data Source Identifier
         * @param {OrganizationModelControllerApiGetEntityDataSourceIdentifiersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSourceIdentifiers(requestParameters, options) {
            return localVarFp
                .getEntityDataSourceIdentifiers(requestParameters.id, requestParameters.filter, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Get Data Source entity
         * @param {OrganizationModelControllerApiGetEntityDataSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSources(requestParameters, options) {
            return localVarFp
                .getEntityDataSources(requestParameters.id, requestParameters.filter, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Space of the shared interest
         * @summary Get Entitlement
         * @param {OrganizationModelControllerApiGetEntityEntitlementsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityEntitlements(requestParameters, options) {
            return localVarFp
                .getEntityEntitlements(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Get Jwk
         * @param {OrganizationModelControllerApiGetEntityJwksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityJwks(requestParameters, options) {
            return localVarFp
                .getEntityJwks(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Organization entity
         * @param {OrganizationModelControllerApiGetEntityOrganizationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityOrganizationSettings(requestParameters, options) {
            return localVarFp
                .getEntityOrganizationSettings(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Theming
         * @param {OrganizationModelControllerApiGetEntityThemesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityThemes(requestParameters, options) {
            return localVarFp
                .getEntityThemes(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Get UserGroup entity
         * @param {OrganizationModelControllerApiGetEntityUserGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserGroups(requestParameters, options) {
            return localVarFp
                .getEntityUserGroups(requestParameters.id, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * UserIdentifier - represents basic informationZ about entity interacting with platform
         * @summary Get UserIdentifier entity
         * @param {OrganizationModelControllerApiGetEntityUserIdentifiersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserIdentifiers(requestParameters, options) {
            return localVarFp
                .getEntityUserIdentifiers(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User - represents entity interacting with platform
         * @summary Get User entity
         * @param {OrganizationModelControllerApiGetEntityUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUsers(requestParameters, options) {
            return localVarFp
                .getEntityUsers(requestParameters.id, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Space of the shared interest
         * @summary Get Workspace entity
         * @param {OrganizationModelControllerApiGetEntityWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaces(requestParameters, options) {
            return localVarFp
                .getEntityWorkspaces(requestParameters.id, requestParameters.filter, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch Color Pallette
         * @param {OrganizationModelControllerApiPatchEntityColorPalettesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityColorPalettes(requestParameters, options) {
            return localVarFp
                .patchEntityColorPalettes(requestParameters.id, requestParameters.jsonApiColorPalettePatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *  Context Security Police Directive
         * @summary Patch CSP Directives
         * @param {OrganizationModelControllerApiPatchEntityCspDirectivesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityCspDirectives(requestParameters, options) {
            return localVarFp
                .patchEntityCspDirectives(requestParameters.id, requestParameters.jsonApiCspDirectivePatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Patch Data Source entity
         * @param {OrganizationModelControllerApiPatchEntityDataSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityDataSources(requestParameters, options) {
            return localVarFp
                .patchEntityDataSources(requestParameters.id, requestParameters.jsonApiDataSourcePatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Patches JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Patch Jwk
         * @param {OrganizationModelControllerApiPatchEntityJwksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityJwks(requestParameters, options) {
            return localVarFp
                .patchEntityJwks(requestParameters.id, requestParameters.jsonApiJwkPatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch Organization entity
         * @param {OrganizationModelControllerApiPatchEntityOrganizationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityOrganizationSettings(requestParameters, options) {
            return localVarFp
                .patchEntityOrganizationSettings(requestParameters.id, requestParameters.jsonApiOrganizationSettingPatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch Theming
         * @param {OrganizationModelControllerApiPatchEntityThemesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityThemes(requestParameters, options) {
            return localVarFp
                .patchEntityThemes(requestParameters.id, requestParameters.jsonApiThemePatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Patch UserGroup entity
         * @param {OrganizationModelControllerApiPatchEntityUserGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUserGroups(requestParameters, options) {
            return localVarFp
                .patchEntityUserGroups(requestParameters.id, requestParameters.jsonApiUserGroupPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User - represents entity interacting with platform
         * @summary Patch User entity
         * @param {OrganizationModelControllerApiPatchEntityUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUsers(requestParameters, options) {
            return localVarFp
                .patchEntityUsers(requestParameters.id, requestParameters.jsonApiUserPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Space of the shared interest
         * @summary Patch Workspace entity
         * @param {OrganizationModelControllerApiPatchEntityWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaces(requestParameters, options) {
            return localVarFp
                .patchEntityWorkspaces(requestParameters.id, requestParameters.jsonApiWorkspacePatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put Color Pallette
         * @param {OrganizationModelControllerApiUpdateEntityColorPalettesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityColorPalettes(requestParameters, options) {
            return localVarFp
                .updateEntityColorPalettes(requestParameters.id, requestParameters.jsonApiColorPaletteInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *  Context Security Police Directive
         * @summary Put CSP Directives
         * @param {OrganizationModelControllerApiUpdateEntityCspDirectivesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityCspDirectives(requestParameters, options) {
            return localVarFp
                .updateEntityCspDirectives(requestParameters.id, requestParameters.jsonApiCspDirectiveInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Data Source - represents data source for the workspace
         * @summary Put Data Source entity
         * @param {OrganizationModelControllerApiUpdateEntityDataSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityDataSources(requestParameters, options) {
            return localVarFp
                .updateEntityDataSources(requestParameters.id, requestParameters.jsonApiDataSourceInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Updates JSON web key - used to verify JSON web tokens (Jwts)
         * @summary Put Jwk
         * @param {OrganizationModelControllerApiUpdateEntityJwksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityJwks(requestParameters, options) {
            return localVarFp
                .updateEntityJwks(requestParameters.id, requestParameters.jsonApiJwkInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put Organization entity
         * @param {OrganizationModelControllerApiUpdateEntityOrganizationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityOrganizationSettings(requestParameters, options) {
            return localVarFp
                .updateEntityOrganizationSettings(requestParameters.id, requestParameters.jsonApiOrganizationSettingInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put Theming
         * @param {OrganizationModelControllerApiUpdateEntityThemesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityThemes(requestParameters, options) {
            return localVarFp
                .updateEntityThemes(requestParameters.id, requestParameters.jsonApiThemeInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Put UserGroup entity
         * @param {OrganizationModelControllerApiUpdateEntityUserGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUserGroups(requestParameters, options) {
            return localVarFp
                .updateEntityUserGroups(requestParameters.id, requestParameters.jsonApiUserGroupInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User - represents entity interacting with platform
         * @summary Put User entity
         * @param {OrganizationModelControllerApiUpdateEntityUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUsers(requestParameters, options) {
            return localVarFp
                .updateEntityUsers(requestParameters.id, requestParameters.jsonApiUserInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Space of the shared interest
         * @summary Put Workspace entity
         * @param {OrganizationModelControllerApiUpdateEntityWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaces(requestParameters, options) {
            return localVarFp
                .updateEntityWorkspaces(requestParameters.id, requestParameters.jsonApiWorkspaceInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * OrganizationModelControllerApi - object-oriented interface
 * @export
 * @class OrganizationModelControllerApi
 * @extends {BaseAPI}
 */
export class OrganizationModelControllerApi extends BaseAPI {
    /**
     *
     * @summary Post Color Pallettes
     * @param {OrganizationModelControllerApiCreateEntityColorPalettesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    createEntityColorPalettes(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .createEntityColorPalettes(requestParameters.jsonApiColorPaletteInDocument, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Context Security Police Directive
     * @summary Post CSP Directives
     * @param {OrganizationModelControllerApiCreateEntityCspDirectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    createEntityCspDirectives(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .createEntityCspDirectives(requestParameters.jsonApiCspDirectiveInDocument, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Data Source - represents data source for the workspace
     * @summary Post Data Sources
     * @param {OrganizationModelControllerApiCreateEntityDataSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    createEntityDataSources(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .createEntityDataSources(requestParameters.jsonApiDataSourceInDocument, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates JSON web key - used to verify JSON web tokens (Jwts)
     * @summary Post Jwks
     * @param {OrganizationModelControllerApiCreateEntityJwksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    createEntityJwks(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .createEntityJwks(requestParameters.jsonApiJwkInDocument, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Organization Setting entities
     * @param {OrganizationModelControllerApiCreateEntityOrganizationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    createEntityOrganizationSettings(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .createEntityOrganizationSettings(requestParameters.jsonApiOrganizationSettingInDocument, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Theming
     * @param {OrganizationModelControllerApiCreateEntityThemesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    createEntityThemes(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .createEntityThemes(requestParameters.jsonApiThemeInDocument, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User Group - creates tree-like structure for categorizing users
     * @summary Post User Group entities
     * @param {OrganizationModelControllerApiCreateEntityUserGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    createEntityUserGroups(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .createEntityUserGroups(requestParameters.jsonApiUserGroupInDocument, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User - represents entity interacting with platform
     * @summary Post User entities
     * @param {OrganizationModelControllerApiCreateEntityUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    createEntityUsers(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .createEntityUsers(requestParameters.jsonApiUserInDocument, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Space of the shared interest
     * @summary Post Workspace entities
     * @param {OrganizationModelControllerApiCreateEntityWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    createEntityWorkspaces(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .createEntityWorkspaces(requestParameters.jsonApiWorkspaceInDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Color Pallette
     * @param {OrganizationModelControllerApiDeleteEntityColorPalettesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    deleteEntityColorPalettes(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .deleteEntityColorPalettes(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Context Security Police Directive
     * @summary Delete CSP Directives
     * @param {OrganizationModelControllerApiDeleteEntityCspDirectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    deleteEntityCspDirectives(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .deleteEntityCspDirectives(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Data Source - represents data source for the workspace
     * @summary Delete Data Source entity
     * @param {OrganizationModelControllerApiDeleteEntityDataSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    deleteEntityDataSources(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .deleteEntityDataSources(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes JSON web key - used to verify JSON web tokens (Jwts)
     * @summary Delete Jwk
     * @param {OrganizationModelControllerApiDeleteEntityJwksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    deleteEntityJwks(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .deleteEntityJwks(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete Organization entity
     * @param {OrganizationModelControllerApiDeleteEntityOrganizationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    deleteEntityOrganizationSettings(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .deleteEntityOrganizationSettings(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete Theming
     * @param {OrganizationModelControllerApiDeleteEntityThemesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    deleteEntityThemes(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .deleteEntityThemes(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User Group - creates tree-like structure for categorizing users
     * @summary Delete UserGroup entity
     * @param {OrganizationModelControllerApiDeleteEntityUserGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    deleteEntityUserGroups(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .deleteEntityUserGroups(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User - represents entity interacting with platform
     * @summary Delete User entity
     * @param {OrganizationModelControllerApiDeleteEntityUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    deleteEntityUsers(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .deleteEntityUsers(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Space of the shared interest
     * @summary Delete Workspace entity
     * @param {OrganizationModelControllerApiDeleteEntityWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    deleteEntityWorkspaces(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .deleteEntityWorkspaces(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Color Pallettes
     * @param {OrganizationModelControllerApiGetAllEntitiesColorPalettesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getAllEntitiesColorPalettes(requestParameters = {}, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getAllEntitiesColorPalettes(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Context Security Police Directive
     * @summary Get CSP Directives
     * @param {OrganizationModelControllerApiGetAllEntitiesCspDirectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getAllEntitiesCspDirectives(requestParameters = {}, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getAllEntitiesCspDirectives(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Data Source Identifiers
     * @param {OrganizationModelControllerApiGetAllEntitiesDataSourceIdentifiersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getAllEntitiesDataSourceIdentifiers(requestParameters = {}, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getAllEntitiesDataSourceIdentifiers(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Data Source - represents data source for the workspace
     * @summary Get Data Source entities
     * @param {OrganizationModelControllerApiGetAllEntitiesDataSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getAllEntitiesDataSources(requestParameters = {}, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getAllEntitiesDataSources(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Space of the shared interest
     * @summary Get Entitlements
     * @param {OrganizationModelControllerApiGetAllEntitiesEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getAllEntitiesEntitlements(requestParameters = {}, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getAllEntitiesEntitlements(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all JSON web keys - used to verify JSON web tokens (Jwts)
     * @summary Get all Jwks
     * @param {OrganizationModelControllerApiGetAllEntitiesJwksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getAllEntitiesJwks(requestParameters = {}, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getAllEntitiesJwks(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Organization entities
     * @param {OrganizationModelControllerApiGetAllEntitiesOrganizationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getAllEntitiesOrganizationSettings(requestParameters = {}, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getAllEntitiesOrganizationSettings(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Theming entities
     * @param {OrganizationModelControllerApiGetAllEntitiesThemesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getAllEntitiesThemes(requestParameters = {}, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getAllEntitiesThemes(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User Group - creates tree-like structure for categorizing users
     * @summary Get UserGroup entities
     * @param {OrganizationModelControllerApiGetAllEntitiesUserGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getAllEntitiesUserGroups(requestParameters = {}, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getAllEntitiesUserGroups(requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * UserIdentifier - represents entity interacting with platform
     * @summary Get UserIdentifier entities
     * @param {OrganizationModelControllerApiGetAllEntitiesUserIdentifiersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getAllEntitiesUserIdentifiers(requestParameters = {}, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getAllEntitiesUserIdentifiers(requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User - represents entity interacting with platform
     * @summary Get User entities
     * @param {OrganizationModelControllerApiGetAllEntitiesUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getAllEntitiesUsers(requestParameters = {}, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getAllEntitiesUsers(requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Space of the shared interest
     * @summary Get Workspace entities
     * @param {OrganizationModelControllerApiGetAllEntitiesWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getAllEntitiesWorkspaces(requestParameters = {}, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getAllEntitiesWorkspaces(requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Color Pallette
     * @param {OrganizationModelControllerApiGetEntityColorPalettesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getEntityColorPalettes(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getEntityColorPalettes(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Context Security Police Directive
     * @summary Get CSP Directives
     * @param {OrganizationModelControllerApiGetEntityCspDirectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getEntityCspDirectives(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getEntityCspDirectives(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Data Source Identifier
     * @param {OrganizationModelControllerApiGetEntityDataSourceIdentifiersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getEntityDataSourceIdentifiers(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getEntityDataSourceIdentifiers(requestParameters.id, requestParameters.filter, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Data Source - represents data source for the workspace
     * @summary Get Data Source entity
     * @param {OrganizationModelControllerApiGetEntityDataSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getEntityDataSources(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getEntityDataSources(requestParameters.id, requestParameters.filter, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Space of the shared interest
     * @summary Get Entitlement
     * @param {OrganizationModelControllerApiGetEntityEntitlementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getEntityEntitlements(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getEntityEntitlements(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns JSON web key - used to verify JSON web tokens (Jwts)
     * @summary Get Jwk
     * @param {OrganizationModelControllerApiGetEntityJwksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getEntityJwks(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getEntityJwks(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Organization entity
     * @param {OrganizationModelControllerApiGetEntityOrganizationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getEntityOrganizationSettings(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getEntityOrganizationSettings(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Theming
     * @param {OrganizationModelControllerApiGetEntityThemesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getEntityThemes(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getEntityThemes(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User Group - creates tree-like structure for categorizing users
     * @summary Get UserGroup entity
     * @param {OrganizationModelControllerApiGetEntityUserGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getEntityUserGroups(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getEntityUserGroups(requestParameters.id, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * UserIdentifier - represents basic informationZ about entity interacting with platform
     * @summary Get UserIdentifier entity
     * @param {OrganizationModelControllerApiGetEntityUserIdentifiersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getEntityUserIdentifiers(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getEntityUserIdentifiers(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User - represents entity interacting with platform
     * @summary Get User entity
     * @param {OrganizationModelControllerApiGetEntityUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getEntityUsers(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getEntityUsers(requestParameters.id, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Space of the shared interest
     * @summary Get Workspace entity
     * @param {OrganizationModelControllerApiGetEntityWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    getEntityWorkspaces(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .getEntityWorkspaces(requestParameters.id, requestParameters.filter, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch Color Pallette
     * @param {OrganizationModelControllerApiPatchEntityColorPalettesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    patchEntityColorPalettes(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .patchEntityColorPalettes(requestParameters.id, requestParameters.jsonApiColorPalettePatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Context Security Police Directive
     * @summary Patch CSP Directives
     * @param {OrganizationModelControllerApiPatchEntityCspDirectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    patchEntityCspDirectives(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .patchEntityCspDirectives(requestParameters.id, requestParameters.jsonApiCspDirectivePatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Data Source - represents data source for the workspace
     * @summary Patch Data Source entity
     * @param {OrganizationModelControllerApiPatchEntityDataSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    patchEntityDataSources(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .patchEntityDataSources(requestParameters.id, requestParameters.jsonApiDataSourcePatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Patches JSON web key - used to verify JSON web tokens (Jwts)
     * @summary Patch Jwk
     * @param {OrganizationModelControllerApiPatchEntityJwksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    patchEntityJwks(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .patchEntityJwks(requestParameters.id, requestParameters.jsonApiJwkPatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch Organization entity
     * @param {OrganizationModelControllerApiPatchEntityOrganizationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    patchEntityOrganizationSettings(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .patchEntityOrganizationSettings(requestParameters.id, requestParameters.jsonApiOrganizationSettingPatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch Theming
     * @param {OrganizationModelControllerApiPatchEntityThemesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    patchEntityThemes(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .patchEntityThemes(requestParameters.id, requestParameters.jsonApiThemePatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User Group - creates tree-like structure for categorizing users
     * @summary Patch UserGroup entity
     * @param {OrganizationModelControllerApiPatchEntityUserGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    patchEntityUserGroups(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .patchEntityUserGroups(requestParameters.id, requestParameters.jsonApiUserGroupPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User - represents entity interacting with platform
     * @summary Patch User entity
     * @param {OrganizationModelControllerApiPatchEntityUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    patchEntityUsers(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .patchEntityUsers(requestParameters.id, requestParameters.jsonApiUserPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Space of the shared interest
     * @summary Patch Workspace entity
     * @param {OrganizationModelControllerApiPatchEntityWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    patchEntityWorkspaces(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .patchEntityWorkspaces(requestParameters.id, requestParameters.jsonApiWorkspacePatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put Color Pallette
     * @param {OrganizationModelControllerApiUpdateEntityColorPalettesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    updateEntityColorPalettes(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .updateEntityColorPalettes(requestParameters.id, requestParameters.jsonApiColorPaletteInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Context Security Police Directive
     * @summary Put CSP Directives
     * @param {OrganizationModelControllerApiUpdateEntityCspDirectivesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    updateEntityCspDirectives(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .updateEntityCspDirectives(requestParameters.id, requestParameters.jsonApiCspDirectiveInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Data Source - represents data source for the workspace
     * @summary Put Data Source entity
     * @param {OrganizationModelControllerApiUpdateEntityDataSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    updateEntityDataSources(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .updateEntityDataSources(requestParameters.id, requestParameters.jsonApiDataSourceInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates JSON web key - used to verify JSON web tokens (Jwts)
     * @summary Put Jwk
     * @param {OrganizationModelControllerApiUpdateEntityJwksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    updateEntityJwks(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .updateEntityJwks(requestParameters.id, requestParameters.jsonApiJwkInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put Organization entity
     * @param {OrganizationModelControllerApiUpdateEntityOrganizationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    updateEntityOrganizationSettings(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .updateEntityOrganizationSettings(requestParameters.id, requestParameters.jsonApiOrganizationSettingInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put Theming
     * @param {OrganizationModelControllerApiUpdateEntityThemesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    updateEntityThemes(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .updateEntityThemes(requestParameters.id, requestParameters.jsonApiThemeInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User Group - creates tree-like structure for categorizing users
     * @summary Put UserGroup entity
     * @param {OrganizationModelControllerApiUpdateEntityUserGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    updateEntityUserGroups(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .updateEntityUserGroups(requestParameters.id, requestParameters.jsonApiUserGroupInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User - represents entity interacting with platform
     * @summary Put User entity
     * @param {OrganizationModelControllerApiUpdateEntityUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    updateEntityUsers(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .updateEntityUsers(requestParameters.id, requestParameters.jsonApiUserInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Space of the shared interest
     * @summary Put Workspace entity
     * @param {OrganizationModelControllerApiUpdateEntityWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationModelControllerApi
     */
    updateEntityWorkspaces(requestParameters, options) {
        return OrganizationModelControllerApiFp(this.configuration)
            .updateEntityWorkspaces(requestParameters.id, requestParameters.jsonApiWorkspaceInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * PDMDeclarativeAPIsApi - axios parameter creator
 * @export
 */
export const PDMDeclarativeAPIsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve complete layout of tables with their columns
         * @summary Get data source physical model layout
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getPdmLayout: async (dataSourceId, options = {}) => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("getPdmLayout", "dataSourceId", dataSourceId);
            const localVarPath = `/api/v1/layout/dataSources/{dataSourceId}/physicalModel`.replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets complete layout of tables with their columns under corresponding Data Source.
         * @summary Set data source physical model layout
         * @param {string} dataSourceId
         * @param {DeclarativePdm} declarativePdm
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        setPdmLayout: async (dataSourceId, declarativePdm, options = {}) => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("setPdmLayout", "dataSourceId", dataSourceId);
            // verify required parameter 'declarativePdm' is not null or undefined
            assertParamExists("setPdmLayout", "declarativePdm", declarativePdm);
            const localVarPath = `/api/v1/layout/dataSources/{dataSourceId}/physicalModel`.replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativePdm !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativePdm !== undefined ? declarativePdm : {})
                : declarativePdm || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PDMDeclarativeAPIsApi - functional programming interface
 * @export
 */
export const PDMDeclarativeAPIsApiFp = function (configuration) {
    const localVarAxiosParamCreator = PDMDeclarativeAPIsApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieve complete layout of tables with their columns
         * @summary Get data source physical model layout
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getPdmLayout(dataSourceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPdmLayout(dataSourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets complete layout of tables with their columns under corresponding Data Source.
         * @summary Set data source physical model layout
         * @param {string} dataSourceId
         * @param {DeclarativePdm} declarativePdm
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async setPdmLayout(dataSourceId, declarativePdm, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPdmLayout(dataSourceId, declarativePdm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * PDMDeclarativeAPIsApi - factory interface
 * @export
 */
export const PDMDeclarativeAPIsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = PDMDeclarativeAPIsApiFp(configuration);
    return {
        /**
         * Retrieve complete layout of tables with their columns
         * @summary Get data source physical model layout
         * @param {PDMDeclarativeAPIsApiGetPdmLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getPdmLayout(requestParameters, options) {
            return localVarFp
                .getPdmLayout(requestParameters.dataSourceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Sets complete layout of tables with their columns under corresponding Data Source.
         * @summary Set data source physical model layout
         * @param {PDMDeclarativeAPIsApiSetPdmLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        setPdmLayout(requestParameters, options) {
            return localVarFp
                .setPdmLayout(requestParameters.dataSourceId, requestParameters.declarativePdm, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * PDMDeclarativeAPIsApi - object-oriented interface
 * @export
 * @class PDMDeclarativeAPIsApi
 * @extends {BaseAPI}
 */
export class PDMDeclarativeAPIsApi extends BaseAPI {
    /**
     * Retrieve complete layout of tables with their columns
     * @summary Get data source physical model layout
     * @param {PDMDeclarativeAPIsApiGetPdmLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PDMDeclarativeAPIsApi
     */
    getPdmLayout(requestParameters, options) {
        return PDMDeclarativeAPIsApiFp(this.configuration)
            .getPdmLayout(requestParameters.dataSourceId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets complete layout of tables with their columns under corresponding Data Source.
     * @summary Set data source physical model layout
     * @param {PDMDeclarativeAPIsApiSetPdmLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PDMDeclarativeAPIsApi
     */
    setPdmLayout(requestParameters, options) {
        return PDMDeclarativeAPIsApiFp(this.configuration)
            .setPdmLayout(requestParameters.dataSourceId, requestParameters.declarativePdm, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * PermissionsApi - axios parameter creator
 * @export
 */
export const PermissionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get Available Assignees
         * @param {string} workspaceId
         * @param {string} dashboardId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableAssignees: async (workspaceId, dashboardId, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("availableAssignees", "workspaceId", workspaceId);
            // verify required parameter 'dashboardId' is not null or undefined
            assertParamExists("availableAssignees", "dashboardId", dashboardId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/analyticalDashboards/{dashboardId}/availableAssignees`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Dashboard Permissions
         * @param {string} workspaceId
         * @param {string} dashboardId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardPermissions: async (workspaceId, dashboardId, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("dashboardPermissions", "workspaceId", workspaceId);
            // verify required parameter 'dashboardId' is not null or undefined
            assertParamExists("dashboardPermissions", "dashboardId", dashboardId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/analyticalDashboards/{dashboardId}/permissions`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve current set of permissions of the workspace in a declarative form.
         * @summary Get permissions for the workspace
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspacePermissions: async (workspaceId, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getWorkspacePermissions", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/layout/workspaces/{workspaceId}/permissions`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Manage Permissions for a Dashboard
         * @param {string} workspaceId
         * @param {string} dashboardId
         * @param {Array<PermissionsForAssignee>} permissionsForAssignee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageDashboardPermissions: async (workspaceId, dashboardId, permissionsForAssignee, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("manageDashboardPermissions", "workspaceId", workspaceId);
            // verify required parameter 'dashboardId' is not null or undefined
            assertParamExists("manageDashboardPermissions", "dashboardId", dashboardId);
            // verify required parameter 'permissionsForAssignee' is not null or undefined
            assertParamExists("manageDashboardPermissions", "permissionsForAssignee", permissionsForAssignee);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/analyticalDashboards/{dashboardId}/managePermissions`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof permissionsForAssignee !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(permissionsForAssignee !== undefined ? permissionsForAssignee : {})
                : permissionsForAssignee || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set effective permissions for the workspace
         * @summary Set permissions for the workspace
         * @param {string} workspaceId
         * @param {DeclarativeWorkspacePermissions} declarativeWorkspacePermissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspacePermissions: async (workspaceId, declarativeWorkspacePermissions, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("setWorkspacePermissions", "workspaceId", workspaceId);
            // verify required parameter 'declarativeWorkspacePermissions' is not null or undefined
            assertParamExists("setWorkspacePermissions", "declarativeWorkspacePermissions", declarativeWorkspacePermissions);
            const localVarPath = `/api/v1/layout/workspaces/{workspaceId}/permissions`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeWorkspacePermissions !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeWorkspacePermissions !== undefined ? declarativeWorkspacePermissions : {})
                : declarativeWorkspacePermissions || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PermissionsApi - functional programming interface
 * @export
 */
export const PermissionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = PermissionsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get Available Assignees
         * @param {string} workspaceId
         * @param {string} dashboardId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableAssignees(workspaceId, dashboardId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableAssignees(workspaceId, dashboardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get Dashboard Permissions
         * @param {string} workspaceId
         * @param {string} dashboardId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardPermissions(workspaceId, dashboardId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardPermissions(workspaceId, dashboardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve current set of permissions of the workspace in a declarative form.
         * @summary Get permissions for the workspace
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspacePermissions(workspaceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspacePermissions(workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Manage Permissions for a Dashboard
         * @param {string} workspaceId
         * @param {string} dashboardId
         * @param {Array<PermissionsForAssignee>} permissionsForAssignee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async manageDashboardPermissions(workspaceId, dashboardId, permissionsForAssignee, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.manageDashboardPermissions(workspaceId, dashboardId, permissionsForAssignee, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set effective permissions for the workspace
         * @summary Set permissions for the workspace
         * @param {string} workspaceId
         * @param {DeclarativeWorkspacePermissions} declarativeWorkspacePermissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setWorkspacePermissions(workspaceId, declarativeWorkspacePermissions, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setWorkspacePermissions(workspaceId, declarativeWorkspacePermissions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * PermissionsApi - factory interface
 * @export
 */
export const PermissionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = PermissionsApiFp(configuration);
    return {
        /**
         *
         * @summary Get Available Assignees
         * @param {PermissionsApiAvailableAssigneesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableAssignees(requestParameters, options) {
            return localVarFp
                .availableAssignees(requestParameters.workspaceId, requestParameters.dashboardId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Dashboard Permissions
         * @param {PermissionsApiDashboardPermissionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardPermissions(requestParameters, options) {
            return localVarFp
                .dashboardPermissions(requestParameters.workspaceId, requestParameters.dashboardId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Retrieve current set of permissions of the workspace in a declarative form.
         * @summary Get permissions for the workspace
         * @param {PermissionsApiGetWorkspacePermissionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspacePermissions(requestParameters, options) {
            return localVarFp
                .getWorkspacePermissions(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Manage Permissions for a Dashboard
         * @param {PermissionsApiManageDashboardPermissionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageDashboardPermissions(requestParameters, options) {
            return localVarFp
                .manageDashboardPermissions(requestParameters.workspaceId, requestParameters.dashboardId, requestParameters.permissionsForAssignee, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Set effective permissions for the workspace
         * @summary Set permissions for the workspace
         * @param {PermissionsApiSetWorkspacePermissionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspacePermissions(requestParameters, options) {
            return localVarFp
                .setWorkspacePermissions(requestParameters.workspaceId, requestParameters.declarativeWorkspacePermissions, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * PermissionsApi - object-oriented interface
 * @export
 * @class PermissionsApi
 * @extends {BaseAPI}
 */
export class PermissionsApi extends BaseAPI {
    /**
     *
     * @summary Get Available Assignees
     * @param {PermissionsApiAvailableAssigneesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    availableAssignees(requestParameters, options) {
        return PermissionsApiFp(this.configuration)
            .availableAssignees(requestParameters.workspaceId, requestParameters.dashboardId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Dashboard Permissions
     * @param {PermissionsApiDashboardPermissionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    dashboardPermissions(requestParameters, options) {
        return PermissionsApiFp(this.configuration)
            .dashboardPermissions(requestParameters.workspaceId, requestParameters.dashboardId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve current set of permissions of the workspace in a declarative form.
     * @summary Get permissions for the workspace
     * @param {PermissionsApiGetWorkspacePermissionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    getWorkspacePermissions(requestParameters, options) {
        return PermissionsApiFp(this.configuration)
            .getWorkspacePermissions(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Manage Permissions for a Dashboard
     * @param {PermissionsApiManageDashboardPermissionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    manageDashboardPermissions(requestParameters, options) {
        return PermissionsApiFp(this.configuration)
            .manageDashboardPermissions(requestParameters.workspaceId, requestParameters.dashboardId, requestParameters.permissionsForAssignee, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Set effective permissions for the workspace
     * @summary Set permissions for the workspace
     * @param {PermissionsApiSetWorkspacePermissionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    setWorkspacePermissions(requestParameters, options) {
        return PermissionsApiFp(this.configuration)
            .setWorkspacePermissions(requestParameters.workspaceId, requestParameters.declarativeWorkspacePermissions, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * PluginsApi - axios parameter creator
 * @export
 */
export const PluginsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Post Plugins
         * @param {string} workspaceId
         * @param {JsonApiDashboardPluginPostOptionalIdDocument} jsonApiDashboardPluginPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityDashboardPlugins: async (workspaceId, jsonApiDashboardPluginPostOptionalIdDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityDashboardPlugins", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiDashboardPluginPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityDashboardPlugins", "jsonApiDashboardPluginPostOptionalIdDocument", jsonApiDashboardPluginPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/dashboardPlugins`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiDashboardPluginPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiDashboardPluginPostOptionalIdDocument !== undefined
                    ? jsonApiDashboardPluginPostOptionalIdDocument
                    : {})
                : jsonApiDashboardPluginPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityDashboardPlugins: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityDashboardPlugins", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityDashboardPlugins", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/dashboardPlugins/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Plugins
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDashboardPlugins: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesDashboardPlugins", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/dashboardPlugins`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDashboardPlugins: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityDashboardPlugins", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityDashboardPlugins", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/dashboardPlugins/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiDashboardPluginPatchDocument} jsonApiDashboardPluginPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityDashboardPlugins: async (workspaceId, objectId, jsonApiDashboardPluginPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityDashboardPlugins", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityDashboardPlugins", "objectId", objectId);
            // verify required parameter 'jsonApiDashboardPluginPatchDocument' is not null or undefined
            assertParamExists("patchEntityDashboardPlugins", "jsonApiDashboardPluginPatchDocument", jsonApiDashboardPluginPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/dashboardPlugins/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiDashboardPluginPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiDashboardPluginPatchDocument !== undefined
                    ? jsonApiDashboardPluginPatchDocument
                    : {})
                : jsonApiDashboardPluginPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiDashboardPluginInDocument} jsonApiDashboardPluginInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityDashboardPlugins: async (workspaceId, objectId, jsonApiDashboardPluginInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityDashboardPlugins", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityDashboardPlugins", "objectId", objectId);
            // verify required parameter 'jsonApiDashboardPluginInDocument' is not null or undefined
            assertParamExists("updateEntityDashboardPlugins", "jsonApiDashboardPluginInDocument", jsonApiDashboardPluginInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/dashboardPlugins/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiDashboardPluginInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiDashboardPluginInDocument !== undefined ? jsonApiDashboardPluginInDocument : {})
                : jsonApiDashboardPluginInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PluginsApi - functional programming interface
 * @export
 */
export const PluginsApiFp = function (configuration) {
    const localVarAxiosParamCreator = PluginsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Post Plugins
         * @param {string} workspaceId
         * @param {JsonApiDashboardPluginPostOptionalIdDocument} jsonApiDashboardPluginPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityDashboardPlugins(workspaceId, jsonApiDashboardPluginPostOptionalIdDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityDashboardPlugins(workspaceId, jsonApiDashboardPluginPostOptionalIdDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityDashboardPlugins(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityDashboardPlugins(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Plugins
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesDashboardPlugins(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesDashboardPlugins(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityDashboardPlugins(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityDashboardPlugins(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiDashboardPluginPatchDocument} jsonApiDashboardPluginPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityDashboardPlugins(workspaceId, objectId, jsonApiDashboardPluginPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityDashboardPlugins(workspaceId, objectId, jsonApiDashboardPluginPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiDashboardPluginInDocument} jsonApiDashboardPluginInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityDashboardPlugins(workspaceId, objectId, jsonApiDashboardPluginInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityDashboardPlugins(workspaceId, objectId, jsonApiDashboardPluginInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * PluginsApi - factory interface
 * @export
 */
export const PluginsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = PluginsApiFp(configuration);
    return {
        /**
         *
         * @summary Post Plugins
         * @param {PluginsApiCreateEntityDashboardPluginsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityDashboardPlugins(requestParameters, options) {
            return localVarFp
                .createEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.jsonApiDashboardPluginPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Plugin
         * @param {PluginsApiDeleteEntityDashboardPluginsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityDashboardPlugins(requestParameters, options) {
            return localVarFp
                .deleteEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Plugins
         * @param {PluginsApiGetAllEntitiesDashboardPluginsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDashboardPlugins(requestParameters, options) {
            return localVarFp
                .getAllEntitiesDashboardPlugins(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Plugin
         * @param {PluginsApiGetEntityDashboardPluginsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDashboardPlugins(requestParameters, options) {
            return localVarFp
                .getEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Plugin
         * @param {PluginsApiPatchEntityDashboardPluginsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityDashboardPlugins(requestParameters, options) {
            return localVarFp
                .patchEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiDashboardPluginPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Plugin
         * @param {PluginsApiUpdateEntityDashboardPluginsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityDashboardPlugins(requestParameters, options) {
            return localVarFp
                .updateEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiDashboardPluginInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * PluginsApi - object-oriented interface
 * @export
 * @class PluginsApi
 * @extends {BaseAPI}
 */
export class PluginsApi extends BaseAPI {
    /**
     *
     * @summary Post Plugins
     * @param {PluginsApiCreateEntityDashboardPluginsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    createEntityDashboardPlugins(requestParameters, options) {
        return PluginsApiFp(this.configuration)
            .createEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.jsonApiDashboardPluginPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Plugin
     * @param {PluginsApiDeleteEntityDashboardPluginsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    deleteEntityDashboardPlugins(requestParameters, options) {
        return PluginsApiFp(this.configuration)
            .deleteEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Plugins
     * @param {PluginsApiGetAllEntitiesDashboardPluginsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    getAllEntitiesDashboardPlugins(requestParameters, options) {
        return PluginsApiFp(this.configuration)
            .getAllEntitiesDashboardPlugins(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Plugin
     * @param {PluginsApiGetEntityDashboardPluginsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    getEntityDashboardPlugins(requestParameters, options) {
        return PluginsApiFp(this.configuration)
            .getEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Plugin
     * @param {PluginsApiPatchEntityDashboardPluginsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    patchEntityDashboardPlugins(requestParameters, options) {
        return PluginsApiFp(this.configuration)
            .patchEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiDashboardPluginPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Plugin
     * @param {PluginsApiUpdateEntityDashboardPluginsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    updateEntityDashboardPlugins(requestParameters, options) {
        return PluginsApiFp(this.configuration)
            .updateEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiDashboardPluginInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ReportingSettingsApi - axios parameter creator
 * @export
 */
export const ReportingSettingsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Resolves values for all settings without workspace by current user, organization, or default settings.
         * @summary Values for all settings without workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveAllSettingsWithoutWorkspace: async (options = {}) => {
            const localVarPath = `/api/v1/actions/resolveSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolves values for selected settings without workspace by current user, organization, or default settings.
         * @summary Values for selected settings without workspace.
         * @param {ResolveSettingsRequest} resolveSettingsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveSettingsWithoutWorkspace: async (resolveSettingsRequest, options = {}) => {
            // verify required parameter 'resolveSettingsRequest' is not null or undefined
            assertParamExists("resolveSettingsWithoutWorkspace", "resolveSettingsRequest", resolveSettingsRequest);
            const localVarPath = `/api/v1/actions/resolveSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof resolveSettingsRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(resolveSettingsRequest !== undefined ? resolveSettingsRequest : {})
                : resolveSettingsRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ReportingSettingsApi - functional programming interface
 * @export
 */
export const ReportingSettingsApiFp = function (configuration) {
    const localVarAxiosParamCreator = ReportingSettingsApiAxiosParamCreator(configuration);
    return {
        /**
         * Resolves values for all settings without workspace by current user, organization, or default settings.
         * @summary Values for all settings without workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveAllSettingsWithoutWorkspace(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveAllSettingsWithoutWorkspace(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resolves values for selected settings without workspace by current user, organization, or default settings.
         * @summary Values for selected settings without workspace.
         * @param {ResolveSettingsRequest} resolveSettingsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveSettingsWithoutWorkspace(resolveSettingsRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveSettingsWithoutWorkspace(resolveSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ReportingSettingsApi - factory interface
 * @export
 */
export const ReportingSettingsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ReportingSettingsApiFp(configuration);
    return {
        /**
         * Resolves values for all settings without workspace by current user, organization, or default settings.
         * @summary Values for all settings without workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveAllSettingsWithoutWorkspace(options) {
            return localVarFp
                .resolveAllSettingsWithoutWorkspace(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Resolves values for selected settings without workspace by current user, organization, or default settings.
         * @summary Values for selected settings without workspace.
         * @param {ReportingSettingsApiResolveSettingsWithoutWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveSettingsWithoutWorkspace(requestParameters, options) {
            return localVarFp
                .resolveSettingsWithoutWorkspace(requestParameters.resolveSettingsRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * ReportingSettingsApi - object-oriented interface
 * @export
 * @class ReportingSettingsApi
 * @extends {BaseAPI}
 */
export class ReportingSettingsApi extends BaseAPI {
    /**
     * Resolves values for all settings without workspace by current user, organization, or default settings.
     * @summary Values for all settings without workspace.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportingSettingsApi
     */
    resolveAllSettingsWithoutWorkspace(options) {
        return ReportingSettingsApiFp(this.configuration)
            .resolveAllSettingsWithoutWorkspace(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Resolves values for selected settings without workspace by current user, organization, or default settings.
     * @summary Values for selected settings without workspace.
     * @param {ReportingSettingsApiResolveSettingsWithoutWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportingSettingsApi
     */
    resolveSettingsWithoutWorkspace(requestParameters, options) {
        return ReportingSettingsApiFp(this.configuration)
            .resolveSettingsWithoutWorkspace(requestParameters.resolveSettingsRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UsageApi - axios parameter creator
 * @export
 */
export const UsageApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Provides information about platform usage, like amount of users, workspaces, ...
         * @summary Info about the platform usage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allPlatformUsage: async (options = {}) => {
            const localVarPath = `/api/v1/actions/collectUsage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides information about platform usage, like amount of users, workspaces, ...
         * @summary Info about the platform usage for particular items.
         * @param {PlatformUsageRequest} platformUsageRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        particularPlatformUsage: async (platformUsageRequest, options = {}) => {
            // verify required parameter 'platformUsageRequest' is not null or undefined
            assertParamExists("particularPlatformUsage", "platformUsageRequest", platformUsageRequest);
            const localVarPath = `/api/v1/actions/collectUsage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof platformUsageRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(platformUsageRequest !== undefined ? platformUsageRequest : {})
                : platformUsageRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UsageApi - functional programming interface
 * @export
 */
export const UsageApiFp = function (configuration) {
    const localVarAxiosParamCreator = UsageApiAxiosParamCreator(configuration);
    return {
        /**
         * Provides information about platform usage, like amount of users, workspaces, ...
         * @summary Info about the platform usage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allPlatformUsage(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allPlatformUsage(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provides information about platform usage, like amount of users, workspaces, ...
         * @summary Info about the platform usage for particular items.
         * @param {PlatformUsageRequest} platformUsageRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async particularPlatformUsage(platformUsageRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.particularPlatformUsage(platformUsageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * UsageApi - factory interface
 * @export
 */
export const UsageApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UsageApiFp(configuration);
    return {
        /**
         * Provides information about platform usage, like amount of users, workspaces, ...
         * @summary Info about the platform usage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allPlatformUsage(options) {
            return localVarFp.allPlatformUsage(options).then((request) => request(axios, basePath));
        },
        /**
         * Provides information about platform usage, like amount of users, workspaces, ...
         * @summary Info about the platform usage for particular items.
         * @param {UsageApiParticularPlatformUsageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        particularPlatformUsage(requestParameters, options) {
            return localVarFp
                .particularPlatformUsage(requestParameters.platformUsageRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * UsageApi - object-oriented interface
 * @export
 * @class UsageApi
 * @extends {BaseAPI}
 */
export class UsageApi extends BaseAPI {
    /**
     * Provides information about platform usage, like amount of users, workspaces, ...
     * @summary Info about the platform usage.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    allPlatformUsage(options) {
        return UsageApiFp(this.configuration)
            .allPlatformUsage(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Provides information about platform usage, like amount of users, workspaces, ...
     * @summary Info about the platform usage for particular items.
     * @param {UsageApiParticularPlatformUsageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    particularPlatformUsage(requestParameters, options) {
        return UsageApiFp(this.configuration)
            .particularPlatformUsage(requestParameters.platformUsageRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UserDataFiltersApi - axios parameter creator
 * @export
 */
export const UserDataFiltersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve current user data filters assigned to the workspace.
         * @summary Get user data filters
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDataFilters: async (workspaceId, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getUserDataFilters", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/layout/workspaces/{workspaceId}/userDataFilters`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set user data filters assigned to the workspace.
         * @summary Set user data filters
         * @param {string} workspaceId
         * @param {DeclarativeUserDataFilters} declarativeUserDataFilters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserDataFilters: async (workspaceId, declarativeUserDataFilters, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("setUserDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'declarativeUserDataFilters' is not null or undefined
            assertParamExists("setUserDataFilters", "declarativeUserDataFilters", declarativeUserDataFilters);
            const localVarPath = `/api/v1/layout/workspaces/{workspaceId}/userDataFilters`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeUserDataFilters !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeUserDataFilters !== undefined ? declarativeUserDataFilters : {})
                : declarativeUserDataFilters || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserDataFiltersApi - functional programming interface
 * @export
 */
export const UserDataFiltersApiFp = function (configuration) {
    const localVarAxiosParamCreator = UserDataFiltersApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieve current user data filters assigned to the workspace.
         * @summary Get user data filters
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserDataFilters(workspaceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserDataFilters(workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set user data filters assigned to the workspace.
         * @summary Set user data filters
         * @param {string} workspaceId
         * @param {DeclarativeUserDataFilters} declarativeUserDataFilters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserDataFilters(workspaceId, declarativeUserDataFilters, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserDataFilters(workspaceId, declarativeUserDataFilters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * UserDataFiltersApi - factory interface
 * @export
 */
export const UserDataFiltersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UserDataFiltersApiFp(configuration);
    return {
        /**
         * Retrieve current user data filters assigned to the workspace.
         * @summary Get user data filters
         * @param {UserDataFiltersApiGetUserDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDataFilters(requestParameters, options) {
            return localVarFp
                .getUserDataFilters(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Set user data filters assigned to the workspace.
         * @summary Set user data filters
         * @param {UserDataFiltersApiSetUserDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserDataFilters(requestParameters, options) {
            return localVarFp
                .setUserDataFilters(requestParameters.workspaceId, requestParameters.declarativeUserDataFilters, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * UserDataFiltersApi - object-oriented interface
 * @export
 * @class UserDataFiltersApi
 * @extends {BaseAPI}
 */
export class UserDataFiltersApi extends BaseAPI {
    /**
     * Retrieve current user data filters assigned to the workspace.
     * @summary Get user data filters
     * @param {UserDataFiltersApiGetUserDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataFiltersApi
     */
    getUserDataFilters(requestParameters, options) {
        return UserDataFiltersApiFp(this.configuration)
            .getUserDataFilters(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Set user data filters assigned to the workspace.
     * @summary Set user data filters
     * @param {UserDataFiltersApiSetUserDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDataFiltersApi
     */
    setUserDataFilters(requestParameters, options) {
        return UserDataFiltersApiFp(this.configuration)
            .setUserDataFilters(requestParameters.workspaceId, requestParameters.declarativeUserDataFilters, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UserGroupsDeclarativeAPIsApi - axios parameter creator
 * @export
 */
export const UserGroupsDeclarativeAPIsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve all user-groups eventually with parent group.
         * @summary Get all user groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupsLayout: async (options = {}) => {
            const localVarPath = `/api/v1/layout/userGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all users and user groups with theirs properties.
         * @summary Get all users and user groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUserGroupsLayout: async (options = {}) => {
            const localVarPath = `/api/v1/layout/usersAndUserGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define all user groups with their parents eventually.
         * @summary Put all user groups
         * @param {DeclarativeUserGroups} declarativeUserGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserGroupsLayout: async (declarativeUserGroups, options = {}) => {
            // verify required parameter 'declarativeUserGroups' is not null or undefined
            assertParamExists("putUserGroupsLayout", "declarativeUserGroups", declarativeUserGroups);
            const localVarPath = `/api/v1/layout/userGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeUserGroups !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeUserGroups !== undefined ? declarativeUserGroups : {})
                : declarativeUserGroups || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define all users and user groups with theirs properties.
         * @summary Put all users and user groups
         * @param {DeclarativeUsersUserGroups} declarativeUsersUserGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersUserGroupsLayout: async (declarativeUsersUserGroups, options = {}) => {
            // verify required parameter 'declarativeUsersUserGroups' is not null or undefined
            assertParamExists("putUsersUserGroupsLayout", "declarativeUsersUserGroups", declarativeUsersUserGroups);
            const localVarPath = `/api/v1/layout/usersAndUserGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeUsersUserGroups !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeUsersUserGroups !== undefined ? declarativeUsersUserGroups : {})
                : declarativeUsersUserGroups || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserGroupsDeclarativeAPIsApi - functional programming interface
 * @export
 */
export const UserGroupsDeclarativeAPIsApiFp = function (configuration) {
    const localVarAxiosParamCreator = UserGroupsDeclarativeAPIsApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieve all user-groups eventually with parent group.
         * @summary Get all user groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserGroupsLayout(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserGroupsLayout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all users and user groups with theirs properties.
         * @summary Get all users and user groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersUserGroupsLayout(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersUserGroupsLayout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Define all user groups with their parents eventually.
         * @summary Put all user groups
         * @param {DeclarativeUserGroups} declarativeUserGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUserGroupsLayout(declarativeUserGroups, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUserGroupsLayout(declarativeUserGroups, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Define all users and user groups with theirs properties.
         * @summary Put all users and user groups
         * @param {DeclarativeUsersUserGroups} declarativeUsersUserGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUsersUserGroupsLayout(declarativeUsersUserGroups, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUsersUserGroupsLayout(declarativeUsersUserGroups, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * UserGroupsDeclarativeAPIsApi - factory interface
 * @export
 */
export const UserGroupsDeclarativeAPIsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UserGroupsDeclarativeAPIsApiFp(configuration);
    return {
        /**
         * Retrieve all user-groups eventually with parent group.
         * @summary Get all user groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupsLayout(options) {
            return localVarFp.getUserGroupsLayout(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all users and user groups with theirs properties.
         * @summary Get all users and user groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUserGroupsLayout(options) {
            return localVarFp.getUsersUserGroupsLayout(options).then((request) => request(axios, basePath));
        },
        /**
         * Define all user groups with their parents eventually.
         * @summary Put all user groups
         * @param {UserGroupsDeclarativeAPIsApiPutUserGroupsLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserGroupsLayout(requestParameters, options) {
            return localVarFp
                .putUserGroupsLayout(requestParameters.declarativeUserGroups, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Define all users and user groups with theirs properties.
         * @summary Put all users and user groups
         * @param {UserGroupsDeclarativeAPIsApiPutUsersUserGroupsLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersUserGroupsLayout(requestParameters, options) {
            return localVarFp
                .putUsersUserGroupsLayout(requestParameters.declarativeUsersUserGroups, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * UserGroupsDeclarativeAPIsApi - object-oriented interface
 * @export
 * @class UserGroupsDeclarativeAPIsApi
 * @extends {BaseAPI}
 */
export class UserGroupsDeclarativeAPIsApi extends BaseAPI {
    /**
     * Retrieve all user-groups eventually with parent group.
     * @summary Get all user groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupsDeclarativeAPIsApi
     */
    getUserGroupsLayout(options) {
        return UserGroupsDeclarativeAPIsApiFp(this.configuration)
            .getUserGroupsLayout(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve all users and user groups with theirs properties.
     * @summary Get all users and user groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupsDeclarativeAPIsApi
     */
    getUsersUserGroupsLayout(options) {
        return UserGroupsDeclarativeAPIsApiFp(this.configuration)
            .getUsersUserGroupsLayout(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Define all user groups with their parents eventually.
     * @summary Put all user groups
     * @param {UserGroupsDeclarativeAPIsApiPutUserGroupsLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupsDeclarativeAPIsApi
     */
    putUserGroupsLayout(requestParameters, options) {
        return UserGroupsDeclarativeAPIsApiFp(this.configuration)
            .putUserGroupsLayout(requestParameters.declarativeUserGroups, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Define all users and user groups with theirs properties.
     * @summary Put all users and user groups
     * @param {UserGroupsDeclarativeAPIsApiPutUsersUserGroupsLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupsDeclarativeAPIsApi
     */
    putUsersUserGroupsLayout(requestParameters, options) {
        return UserGroupsDeclarativeAPIsApiFp(this.configuration)
            .putUsersUserGroupsLayout(requestParameters.declarativeUsersUserGroups, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UserGroupsEntityAPIsApi - axios parameter creator
 * @export
 */
export const UserGroupsEntityAPIsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Post User Group entities
         * @param {JsonApiUserGroupInDocument} jsonApiUserGroupInDocument
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUserGroups: async (jsonApiUserGroupInDocument, include, options = {}) => {
            // verify required parameter 'jsonApiUserGroupInDocument' is not null or undefined
            assertParamExists("createEntityUserGroups", "jsonApiUserGroupInDocument", jsonApiUserGroupInDocument);
            const localVarPath = `/api/v1/entities/userGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserGroupInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserGroupInDocument !== undefined ? jsonApiUserGroupInDocument : {})
                : jsonApiUserGroupInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Delete UserGroup entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUserGroups: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityUserGroups", "id", id);
            const localVarPath = `/api/v1/entities/userGroups/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Get UserGroup entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserGroups: async (filter, include, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/userGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Get UserGroup entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserGroups: async (id, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityUserGroups", "id", id);
            const localVarPath = `/api/v1/entities/userGroups/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Patch UserGroup entity
         * @param {string} id
         * @param {JsonApiUserGroupPatchDocument} jsonApiUserGroupPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUserGroups: async (id, jsonApiUserGroupPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityUserGroups", "id", id);
            // verify required parameter 'jsonApiUserGroupPatchDocument' is not null or undefined
            assertParamExists("patchEntityUserGroups", "jsonApiUserGroupPatchDocument", jsonApiUserGroupPatchDocument);
            const localVarPath = `/api/v1/entities/userGroups/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserGroupPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserGroupPatchDocument !== undefined ? jsonApiUserGroupPatchDocument : {})
                : jsonApiUserGroupPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Put UserGroup entity
         * @param {string} id
         * @param {JsonApiUserGroupInDocument} jsonApiUserGroupInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUserGroups: async (id, jsonApiUserGroupInDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityUserGroups", "id", id);
            // verify required parameter 'jsonApiUserGroupInDocument' is not null or undefined
            assertParamExists("updateEntityUserGroups", "jsonApiUserGroupInDocument", jsonApiUserGroupInDocument);
            const localVarPath = `/api/v1/entities/userGroups/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserGroupInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserGroupInDocument !== undefined ? jsonApiUserGroupInDocument : {})
                : jsonApiUserGroupInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserGroupsEntityAPIsApi - functional programming interface
 * @export
 */
export const UserGroupsEntityAPIsApiFp = function (configuration) {
    const localVarAxiosParamCreator = UserGroupsEntityAPIsApiAxiosParamCreator(configuration);
    return {
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Post User Group entities
         * @param {JsonApiUserGroupInDocument} jsonApiUserGroupInDocument
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityUserGroups(jsonApiUserGroupInDocument, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityUserGroups(jsonApiUserGroupInDocument, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Delete UserGroup entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityUserGroups(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityUserGroups(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Get UserGroup entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesUserGroups(filter, include, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesUserGroups(filter, include, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Get UserGroup entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityUserGroups(id, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityUserGroups(id, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Patch UserGroup entity
         * @param {string} id
         * @param {JsonApiUserGroupPatchDocument} jsonApiUserGroupPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityUserGroups(id, jsonApiUserGroupPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityUserGroups(id, jsonApiUserGroupPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Put UserGroup entity
         * @param {string} id
         * @param {JsonApiUserGroupInDocument} jsonApiUserGroupInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityUserGroups(id, jsonApiUserGroupInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityUserGroups(id, jsonApiUserGroupInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * UserGroupsEntityAPIsApi - factory interface
 * @export
 */
export const UserGroupsEntityAPIsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UserGroupsEntityAPIsApiFp(configuration);
    return {
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Post User Group entities
         * @param {UserGroupsEntityAPIsApiCreateEntityUserGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUserGroups(requestParameters, options) {
            return localVarFp
                .createEntityUserGroups(requestParameters.jsonApiUserGroupInDocument, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Delete UserGroup entity
         * @param {UserGroupsEntityAPIsApiDeleteEntityUserGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUserGroups(requestParameters, options) {
            return localVarFp
                .deleteEntityUserGroups(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Get UserGroup entities
         * @param {UserGroupsEntityAPIsApiGetAllEntitiesUserGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserGroups(requestParameters, options) {
            return localVarFp
                .getAllEntitiesUserGroups(requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Get UserGroup entity
         * @param {UserGroupsEntityAPIsApiGetEntityUserGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserGroups(requestParameters, options) {
            return localVarFp
                .getEntityUserGroups(requestParameters.id, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Patch UserGroup entity
         * @param {UserGroupsEntityAPIsApiPatchEntityUserGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUserGroups(requestParameters, options) {
            return localVarFp
                .patchEntityUserGroups(requestParameters.id, requestParameters.jsonApiUserGroupPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User Group - creates tree-like structure for categorizing users
         * @summary Put UserGroup entity
         * @param {UserGroupsEntityAPIsApiUpdateEntityUserGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUserGroups(requestParameters, options) {
            return localVarFp
                .updateEntityUserGroups(requestParameters.id, requestParameters.jsonApiUserGroupInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * UserGroupsEntityAPIsApi - object-oriented interface
 * @export
 * @class UserGroupsEntityAPIsApi
 * @extends {BaseAPI}
 */
export class UserGroupsEntityAPIsApi extends BaseAPI {
    /**
     * User Group - creates tree-like structure for categorizing users
     * @summary Post User Group entities
     * @param {UserGroupsEntityAPIsApiCreateEntityUserGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupsEntityAPIsApi
     */
    createEntityUserGroups(requestParameters, options) {
        return UserGroupsEntityAPIsApiFp(this.configuration)
            .createEntityUserGroups(requestParameters.jsonApiUserGroupInDocument, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User Group - creates tree-like structure for categorizing users
     * @summary Delete UserGroup entity
     * @param {UserGroupsEntityAPIsApiDeleteEntityUserGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupsEntityAPIsApi
     */
    deleteEntityUserGroups(requestParameters, options) {
        return UserGroupsEntityAPIsApiFp(this.configuration)
            .deleteEntityUserGroups(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User Group - creates tree-like structure for categorizing users
     * @summary Get UserGroup entities
     * @param {UserGroupsEntityAPIsApiGetAllEntitiesUserGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupsEntityAPIsApi
     */
    getAllEntitiesUserGroups(requestParameters = {}, options) {
        return UserGroupsEntityAPIsApiFp(this.configuration)
            .getAllEntitiesUserGroups(requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User Group - creates tree-like structure for categorizing users
     * @summary Get UserGroup entity
     * @param {UserGroupsEntityAPIsApiGetEntityUserGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupsEntityAPIsApi
     */
    getEntityUserGroups(requestParameters, options) {
        return UserGroupsEntityAPIsApiFp(this.configuration)
            .getEntityUserGroups(requestParameters.id, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User Group - creates tree-like structure for categorizing users
     * @summary Patch UserGroup entity
     * @param {UserGroupsEntityAPIsApiPatchEntityUserGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupsEntityAPIsApi
     */
    patchEntityUserGroups(requestParameters, options) {
        return UserGroupsEntityAPIsApiFp(this.configuration)
            .patchEntityUserGroups(requestParameters.id, requestParameters.jsonApiUserGroupPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User Group - creates tree-like structure for categorizing users
     * @summary Put UserGroup entity
     * @param {UserGroupsEntityAPIsApiUpdateEntityUserGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGroupsEntityAPIsApi
     */
    updateEntityUserGroups(requestParameters, options) {
        return UserGroupsEntityAPIsApiFp(this.configuration)
            .updateEntityUserGroups(requestParameters.id, requestParameters.jsonApiUserGroupInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UserModelControllerApi - axios parameter creator
 * @export
 */
export const UserModelControllerApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Post a new API token for the user
         * @param {string} userId
         * @param {JsonApiApiTokenInDocument} jsonApiApiTokenInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityApiTokens: async (userId, jsonApiApiTokenInDocument, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("createEntityApiTokens", "userId", userId);
            // verify required parameter 'jsonApiApiTokenInDocument' is not null or undefined
            assertParamExists("createEntityApiTokens", "jsonApiApiTokenInDocument", jsonApiApiTokenInDocument);
            const localVarPath = `/api/v1/entities/users/{userId}/apiTokens`.replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiApiTokenInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiApiTokenInDocument !== undefined ? jsonApiApiTokenInDocument : {})
                : jsonApiApiTokenInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post new user settings for the user
         * @param {string} userId
         * @param {JsonApiUserSettingInDocument} jsonApiUserSettingInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUserSettings: async (userId, jsonApiUserSettingInDocument, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("createEntityUserSettings", "userId", userId);
            // verify required parameter 'jsonApiUserSettingInDocument' is not null or undefined
            assertParamExists("createEntityUserSettings", "jsonApiUserSettingInDocument", jsonApiUserSettingInDocument);
            const localVarPath = `/api/v1/entities/users/{userId}/userSettings`.replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserSettingInDocument !== undefined ? jsonApiUserSettingInDocument : {})
                : jsonApiUserSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete an API Token for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityApiTokens: async (userId, id, filter, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("deleteEntityApiTokens", "userId", userId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityApiTokens", "id", id);
            const localVarPath = `/api/v1/entities/users/{userId}/apiTokens/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a setting for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUserSettings: async (userId, id, filter, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("deleteEntityUserSettings", "userId", userId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityUserSettings", "id", id);
            const localVarPath = `/api/v1/entities/users/{userId}/userSettings/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List all api tokens for a user
         * @param {string} userId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesApiTokens: async (userId, filter, page, size, sort, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("getAllEntitiesApiTokens", "userId", userId);
            const localVarPath = `/api/v1/entities/users/{userId}/apiTokens`.replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List all settings for a user
         * @param {string} userId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserSettings: async (userId, filter, page, size, sort, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("getAllEntitiesUserSettings", "userId", userId);
            const localVarPath = `/api/v1/entities/users/{userId}/userSettings`.replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get an API Token for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityApiTokens: async (userId, id, filter, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("getEntityApiTokens", "userId", userId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityApiTokens", "id", id);
            const localVarPath = `/api/v1/entities/users/{userId}/apiTokens/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a setting for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserSettings: async (userId, id, filter, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("getEntityUserSettings", "userId", userId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityUserSettings", "id", id);
            const localVarPath = `/api/v1/entities/users/{userId}/userSettings/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put new API token for the user
         * @param {string} userId
         * @param {string} id
         * @param {JsonApiApiTokenInDocument} jsonApiApiTokenInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityApiTokens: async (userId, id, jsonApiApiTokenInDocument, filter, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("updateEntityApiTokens", "userId", userId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityApiTokens", "id", id);
            // verify required parameter 'jsonApiApiTokenInDocument' is not null or undefined
            assertParamExists("updateEntityApiTokens", "jsonApiApiTokenInDocument", jsonApiApiTokenInDocument);
            const localVarPath = `/api/v1/entities/users/{userId}/apiTokens/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiApiTokenInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiApiTokenInDocument !== undefined ? jsonApiApiTokenInDocument : {})
                : jsonApiApiTokenInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put new user settings for the user
         * @param {string} userId
         * @param {string} id
         * @param {JsonApiUserSettingInDocument} jsonApiUserSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUserSettings: async (userId, id, jsonApiUserSettingInDocument, filter, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("updateEntityUserSettings", "userId", userId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityUserSettings", "id", id);
            // verify required parameter 'jsonApiUserSettingInDocument' is not null or undefined
            assertParamExists("updateEntityUserSettings", "jsonApiUserSettingInDocument", jsonApiUserSettingInDocument);
            const localVarPath = `/api/v1/entities/users/{userId}/userSettings/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserSettingInDocument !== undefined ? jsonApiUserSettingInDocument : {})
                : jsonApiUserSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserModelControllerApi - functional programming interface
 * @export
 */
export const UserModelControllerApiFp = function (configuration) {
    const localVarAxiosParamCreator = UserModelControllerApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Post a new API token for the user
         * @param {string} userId
         * @param {JsonApiApiTokenInDocument} jsonApiApiTokenInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityApiTokens(userId, jsonApiApiTokenInDocument, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityApiTokens(userId, jsonApiApiTokenInDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post new user settings for the user
         * @param {string} userId
         * @param {JsonApiUserSettingInDocument} jsonApiUserSettingInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityUserSettings(userId, jsonApiUserSettingInDocument, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityUserSettings(userId, jsonApiUserSettingInDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete an API Token for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityApiTokens(userId, id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityApiTokens(userId, id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a setting for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityUserSettings(userId, id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityUserSettings(userId, id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary List all api tokens for a user
         * @param {string} userId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesApiTokens(userId, filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesApiTokens(userId, filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary List all settings for a user
         * @param {string} userId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesUserSettings(userId, filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesUserSettings(userId, filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get an API Token for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityApiTokens(userId, id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityApiTokens(userId, id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a setting for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityUserSettings(userId, id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityUserSettings(userId, id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put new API token for the user
         * @param {string} userId
         * @param {string} id
         * @param {JsonApiApiTokenInDocument} jsonApiApiTokenInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityApiTokens(userId, id, jsonApiApiTokenInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityApiTokens(userId, id, jsonApiApiTokenInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put new user settings for the user
         * @param {string} userId
         * @param {string} id
         * @param {JsonApiUserSettingInDocument} jsonApiUserSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityUserSettings(userId, id, jsonApiUserSettingInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityUserSettings(userId, id, jsonApiUserSettingInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * UserModelControllerApi - factory interface
 * @export
 */
export const UserModelControllerApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UserModelControllerApiFp(configuration);
    return {
        /**
         *
         * @summary Post a new API token for the user
         * @param {UserModelControllerApiCreateEntityApiTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityApiTokens(requestParameters, options) {
            return localVarFp
                .createEntityApiTokens(requestParameters.userId, requestParameters.jsonApiApiTokenInDocument, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post new user settings for the user
         * @param {UserModelControllerApiCreateEntityUserSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUserSettings(requestParameters, options) {
            return localVarFp
                .createEntityUserSettings(requestParameters.userId, requestParameters.jsonApiUserSettingInDocument, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete an API Token for a user
         * @param {UserModelControllerApiDeleteEntityApiTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityApiTokens(requestParameters, options) {
            return localVarFp
                .deleteEntityApiTokens(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a setting for a user
         * @param {UserModelControllerApiDeleteEntityUserSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUserSettings(requestParameters, options) {
            return localVarFp
                .deleteEntityUserSettings(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List all api tokens for a user
         * @param {UserModelControllerApiGetAllEntitiesApiTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesApiTokens(requestParameters, options) {
            return localVarFp
                .getAllEntitiesApiTokens(requestParameters.userId, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List all settings for a user
         * @param {UserModelControllerApiGetAllEntitiesUserSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserSettings(requestParameters, options) {
            return localVarFp
                .getAllEntitiesUserSettings(requestParameters.userId, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get an API Token for a user
         * @param {UserModelControllerApiGetEntityApiTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityApiTokens(requestParameters, options) {
            return localVarFp
                .getEntityApiTokens(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a setting for a user
         * @param {UserModelControllerApiGetEntityUserSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserSettings(requestParameters, options) {
            return localVarFp
                .getEntityUserSettings(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put new API token for the user
         * @param {UserModelControllerApiUpdateEntityApiTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityApiTokens(requestParameters, options) {
            return localVarFp
                .updateEntityApiTokens(requestParameters.userId, requestParameters.id, requestParameters.jsonApiApiTokenInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put new user settings for the user
         * @param {UserModelControllerApiUpdateEntityUserSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUserSettings(requestParameters, options) {
            return localVarFp
                .updateEntityUserSettings(requestParameters.userId, requestParameters.id, requestParameters.jsonApiUserSettingInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * UserModelControllerApi - object-oriented interface
 * @export
 * @class UserModelControllerApi
 * @extends {BaseAPI}
 */
export class UserModelControllerApi extends BaseAPI {
    /**
     *
     * @summary Post a new API token for the user
     * @param {UserModelControllerApiCreateEntityApiTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserModelControllerApi
     */
    createEntityApiTokens(requestParameters, options) {
        return UserModelControllerApiFp(this.configuration)
            .createEntityApiTokens(requestParameters.userId, requestParameters.jsonApiApiTokenInDocument, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post new user settings for the user
     * @param {UserModelControllerApiCreateEntityUserSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserModelControllerApi
     */
    createEntityUserSettings(requestParameters, options) {
        return UserModelControllerApiFp(this.configuration)
            .createEntityUserSettings(requestParameters.userId, requestParameters.jsonApiUserSettingInDocument, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete an API Token for a user
     * @param {UserModelControllerApiDeleteEntityApiTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserModelControllerApi
     */
    deleteEntityApiTokens(requestParameters, options) {
        return UserModelControllerApiFp(this.configuration)
            .deleteEntityApiTokens(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a setting for a user
     * @param {UserModelControllerApiDeleteEntityUserSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserModelControllerApi
     */
    deleteEntityUserSettings(requestParameters, options) {
        return UserModelControllerApiFp(this.configuration)
            .deleteEntityUserSettings(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List all api tokens for a user
     * @param {UserModelControllerApiGetAllEntitiesApiTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserModelControllerApi
     */
    getAllEntitiesApiTokens(requestParameters, options) {
        return UserModelControllerApiFp(this.configuration)
            .getAllEntitiesApiTokens(requestParameters.userId, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List all settings for a user
     * @param {UserModelControllerApiGetAllEntitiesUserSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserModelControllerApi
     */
    getAllEntitiesUserSettings(requestParameters, options) {
        return UserModelControllerApiFp(this.configuration)
            .getAllEntitiesUserSettings(requestParameters.userId, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get an API Token for a user
     * @param {UserModelControllerApiGetEntityApiTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserModelControllerApi
     */
    getEntityApiTokens(requestParameters, options) {
        return UserModelControllerApiFp(this.configuration)
            .getEntityApiTokens(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a setting for a user
     * @param {UserModelControllerApiGetEntityUserSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserModelControllerApi
     */
    getEntityUserSettings(requestParameters, options) {
        return UserModelControllerApiFp(this.configuration)
            .getEntityUserSettings(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put new API token for the user
     * @param {UserModelControllerApiUpdateEntityApiTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserModelControllerApi
     */
    updateEntityApiTokens(requestParameters, options) {
        return UserModelControllerApiFp(this.configuration)
            .updateEntityApiTokens(requestParameters.userId, requestParameters.id, requestParameters.jsonApiApiTokenInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put new user settings for the user
     * @param {UserModelControllerApiUpdateEntityUserSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserModelControllerApi
     */
    updateEntityUserSettings(requestParameters, options) {
        return UserModelControllerApiFp(this.configuration)
            .updateEntityUserSettings(requestParameters.userId, requestParameters.id, requestParameters.jsonApiUserSettingInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UserSettingsApi - axios parameter creator
 * @export
 */
export const UserSettingsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Post new user settings for the user
         * @param {string} userId
         * @param {JsonApiUserSettingInDocument} jsonApiUserSettingInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUserSettings: async (userId, jsonApiUserSettingInDocument, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("createEntityUserSettings", "userId", userId);
            // verify required parameter 'jsonApiUserSettingInDocument' is not null or undefined
            assertParamExists("createEntityUserSettings", "jsonApiUserSettingInDocument", jsonApiUserSettingInDocument);
            const localVarPath = `/api/v1/entities/users/{userId}/userSettings`.replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserSettingInDocument !== undefined ? jsonApiUserSettingInDocument : {})
                : jsonApiUserSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a setting for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUserSettings: async (userId, id, filter, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("deleteEntityUserSettings", "userId", userId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityUserSettings", "id", id);
            const localVarPath = `/api/v1/entities/users/{userId}/userSettings/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List all settings for a user
         * @param {string} userId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserSettings: async (userId, filter, page, size, sort, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("getAllEntitiesUserSettings", "userId", userId);
            const localVarPath = `/api/v1/entities/users/{userId}/userSettings`.replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a setting for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserSettings: async (userId, id, filter, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("getEntityUserSettings", "userId", userId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityUserSettings", "id", id);
            const localVarPath = `/api/v1/entities/users/{userId}/userSettings/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put new user settings for the user
         * @param {string} userId
         * @param {string} id
         * @param {JsonApiUserSettingInDocument} jsonApiUserSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUserSettings: async (userId, id, jsonApiUserSettingInDocument, filter, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("updateEntityUserSettings", "userId", userId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityUserSettings", "id", id);
            // verify required parameter 'jsonApiUserSettingInDocument' is not null or undefined
            assertParamExists("updateEntityUserSettings", "jsonApiUserSettingInDocument", jsonApiUserSettingInDocument);
            const localVarPath = `/api/v1/entities/users/{userId}/userSettings/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserSettingInDocument !== undefined ? jsonApiUserSettingInDocument : {})
                : jsonApiUserSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserSettingsApi - functional programming interface
 * @export
 */
export const UserSettingsApiFp = function (configuration) {
    const localVarAxiosParamCreator = UserSettingsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Post new user settings for the user
         * @param {string} userId
         * @param {JsonApiUserSettingInDocument} jsonApiUserSettingInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityUserSettings(userId, jsonApiUserSettingInDocument, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityUserSettings(userId, jsonApiUserSettingInDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a setting for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityUserSettings(userId, id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityUserSettings(userId, id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary List all settings for a user
         * @param {string} userId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesUserSettings(userId, filter, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesUserSettings(userId, filter, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a setting for a user
         * @param {string} userId
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityUserSettings(userId, id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityUserSettings(userId, id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put new user settings for the user
         * @param {string} userId
         * @param {string} id
         * @param {JsonApiUserSettingInDocument} jsonApiUserSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityUserSettings(userId, id, jsonApiUserSettingInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityUserSettings(userId, id, jsonApiUserSettingInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * UserSettingsApi - factory interface
 * @export
 */
export const UserSettingsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UserSettingsApiFp(configuration);
    return {
        /**
         *
         * @summary Post new user settings for the user
         * @param {UserSettingsApiCreateEntityUserSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUserSettings(requestParameters, options) {
            return localVarFp
                .createEntityUserSettings(requestParameters.userId, requestParameters.jsonApiUserSettingInDocument, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a setting for a user
         * @param {UserSettingsApiDeleteEntityUserSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUserSettings(requestParameters, options) {
            return localVarFp
                .deleteEntityUserSettings(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List all settings for a user
         * @param {UserSettingsApiGetAllEntitiesUserSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserSettings(requestParameters, options) {
            return localVarFp
                .getAllEntitiesUserSettings(requestParameters.userId, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a setting for a user
         * @param {UserSettingsApiGetEntityUserSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserSettings(requestParameters, options) {
            return localVarFp
                .getEntityUserSettings(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put new user settings for the user
         * @param {UserSettingsApiUpdateEntityUserSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUserSettings(requestParameters, options) {
            return localVarFp
                .updateEntityUserSettings(requestParameters.userId, requestParameters.id, requestParameters.jsonApiUserSettingInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * UserSettingsApi - object-oriented interface
 * @export
 * @class UserSettingsApi
 * @extends {BaseAPI}
 */
export class UserSettingsApi extends BaseAPI {
    /**
     *
     * @summary Post new user settings for the user
     * @param {UserSettingsApiCreateEntityUserSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    createEntityUserSettings(requestParameters, options) {
        return UserSettingsApiFp(this.configuration)
            .createEntityUserSettings(requestParameters.userId, requestParameters.jsonApiUserSettingInDocument, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a setting for a user
     * @param {UserSettingsApiDeleteEntityUserSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    deleteEntityUserSettings(requestParameters, options) {
        return UserSettingsApiFp(this.configuration)
            .deleteEntityUserSettings(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List all settings for a user
     * @param {UserSettingsApiGetAllEntitiesUserSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    getAllEntitiesUserSettings(requestParameters, options) {
        return UserSettingsApiFp(this.configuration)
            .getAllEntitiesUserSettings(requestParameters.userId, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a setting for a user
     * @param {UserSettingsApiGetEntityUserSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    getEntityUserSettings(requestParameters, options) {
        return UserSettingsApiFp(this.configuration)
            .getEntityUserSettings(requestParameters.userId, requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put new user settings for the user
     * @param {UserSettingsApiUpdateEntityUserSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    updateEntityUserSettings(requestParameters, options) {
        return UserSettingsApiFp(this.configuration)
            .updateEntityUserSettings(requestParameters.userId, requestParameters.id, requestParameters.jsonApiUserSettingInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UsersDeclarativeAPIsApi - axios parameter creator
 * @export
 */
export const UsersDeclarativeAPIsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve all users including authentication properties.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersLayout: async (options = {}) => {
            const localVarPath = `/api/v1/layout/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set all users and their authentication properties.
         * @summary Put all users
         * @param {DeclarativeUsers} declarativeUsers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersLayout: async (declarativeUsers, options = {}) => {
            // verify required parameter 'declarativeUsers' is not null or undefined
            assertParamExists("putUsersLayout", "declarativeUsers", declarativeUsers);
            const localVarPath = `/api/v1/layout/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeUsers !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeUsers !== undefined ? declarativeUsers : {})
                : declarativeUsers || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UsersDeclarativeAPIsApi - functional programming interface
 * @export
 */
export const UsersDeclarativeAPIsApiFp = function (configuration) {
    const localVarAxiosParamCreator = UsersDeclarativeAPIsApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieve all users including authentication properties.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersLayout(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersLayout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set all users and their authentication properties.
         * @summary Put all users
         * @param {DeclarativeUsers} declarativeUsers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUsersLayout(declarativeUsers, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUsersLayout(declarativeUsers, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * UsersDeclarativeAPIsApi - factory interface
 * @export
 */
export const UsersDeclarativeAPIsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UsersDeclarativeAPIsApiFp(configuration);
    return {
        /**
         * Retrieve all users including authentication properties.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersLayout(options) {
            return localVarFp.getUsersLayout(options).then((request) => request(axios, basePath));
        },
        /**
         * Set all users and their authentication properties.
         * @summary Put all users
         * @param {UsersDeclarativeAPIsApiPutUsersLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersLayout(requestParameters, options) {
            return localVarFp
                .putUsersLayout(requestParameters.declarativeUsers, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * UsersDeclarativeAPIsApi - object-oriented interface
 * @export
 * @class UsersDeclarativeAPIsApi
 * @extends {BaseAPI}
 */
export class UsersDeclarativeAPIsApi extends BaseAPI {
    /**
     * Retrieve all users including authentication properties.
     * @summary Get all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersDeclarativeAPIsApi
     */
    getUsersLayout(options) {
        return UsersDeclarativeAPIsApiFp(this.configuration)
            .getUsersLayout(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Set all users and their authentication properties.
     * @summary Put all users
     * @param {UsersDeclarativeAPIsApiPutUsersLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersDeclarativeAPIsApi
     */
    putUsersLayout(requestParameters, options) {
        return UsersDeclarativeAPIsApiFp(this.configuration)
            .putUsersLayout(requestParameters.declarativeUsers, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UsersEntityAPIsApi - axios parameter creator
 * @export
 */
export const UsersEntityAPIsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * User - represents entity interacting with platform
         * @summary Post User entities
         * @param {JsonApiUserInDocument} jsonApiUserInDocument
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUsers: async (jsonApiUserInDocument, include, options = {}) => {
            // verify required parameter 'jsonApiUserInDocument' is not null or undefined
            assertParamExists("createEntityUsers", "jsonApiUserInDocument", jsonApiUserInDocument);
            const localVarPath = `/api/v1/entities/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserInDocument !== undefined ? jsonApiUserInDocument : {})
                : jsonApiUserInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User - represents entity interacting with platform
         * @summary Delete User entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUsers: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityUsers", "id", id);
            const localVarPath = `/api/v1/entities/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User - represents entity interacting with platform
         * @summary Get User entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUsers: async (filter, include, page, size, sort, options = {}) => {
            const localVarPath = `/api/v1/entities/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User - represents entity interacting with platform
         * @summary Get User entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUsers: async (id, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityUsers", "id", id);
            const localVarPath = `/api/v1/entities/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User - represents entity interacting with platform
         * @summary Patch User entity
         * @param {string} id
         * @param {JsonApiUserPatchDocument} jsonApiUserPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUsers: async (id, jsonApiUserPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityUsers", "id", id);
            // verify required parameter 'jsonApiUserPatchDocument' is not null or undefined
            assertParamExists("patchEntityUsers", "jsonApiUserPatchDocument", jsonApiUserPatchDocument);
            const localVarPath = `/api/v1/entities/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserPatchDocument !== undefined ? jsonApiUserPatchDocument : {})
                : jsonApiUserPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User - represents entity interacting with platform
         * @summary Put User entity
         * @param {string} id
         * @param {JsonApiUserInDocument} jsonApiUserInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUsers: async (id, jsonApiUserInDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityUsers", "id", id);
            // verify required parameter 'jsonApiUserInDocument' is not null or undefined
            assertParamExists("updateEntityUsers", "jsonApiUserInDocument", jsonApiUserInDocument);
            const localVarPath = `/api/v1/entities/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserInDocument !== undefined ? jsonApiUserInDocument : {})
                : jsonApiUserInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UsersEntityAPIsApi - functional programming interface
 * @export
 */
export const UsersEntityAPIsApiFp = function (configuration) {
    const localVarAxiosParamCreator = UsersEntityAPIsApiAxiosParamCreator(configuration);
    return {
        /**
         * User - represents entity interacting with platform
         * @summary Post User entities
         * @param {JsonApiUserInDocument} jsonApiUserInDocument
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityUsers(jsonApiUserInDocument, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityUsers(jsonApiUserInDocument, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User - represents entity interacting with platform
         * @summary Delete User entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityUsers(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityUsers(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User - represents entity interacting with platform
         * @summary Get User entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesUsers(filter, include, page, size, sort, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesUsers(filter, include, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User - represents entity interacting with platform
         * @summary Get User entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityUsers(id, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityUsers(id, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User - represents entity interacting with platform
         * @summary Patch User entity
         * @param {string} id
         * @param {JsonApiUserPatchDocument} jsonApiUserPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityUsers(id, jsonApiUserPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityUsers(id, jsonApiUserPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User - represents entity interacting with platform
         * @summary Put User entity
         * @param {string} id
         * @param {JsonApiUserInDocument} jsonApiUserInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityUsers(id, jsonApiUserInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityUsers(id, jsonApiUserInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * UsersEntityAPIsApi - factory interface
 * @export
 */
export const UsersEntityAPIsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UsersEntityAPIsApiFp(configuration);
    return {
        /**
         * User - represents entity interacting with platform
         * @summary Post User entities
         * @param {UsersEntityAPIsApiCreateEntityUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUsers(requestParameters, options) {
            return localVarFp
                .createEntityUsers(requestParameters.jsonApiUserInDocument, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User - represents entity interacting with platform
         * @summary Delete User entity
         * @param {UsersEntityAPIsApiDeleteEntityUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUsers(requestParameters, options) {
            return localVarFp
                .deleteEntityUsers(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User - represents entity interacting with platform
         * @summary Get User entities
         * @param {UsersEntityAPIsApiGetAllEntitiesUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUsers(requestParameters, options) {
            return localVarFp
                .getAllEntitiesUsers(requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User - represents entity interacting with platform
         * @summary Get User entity
         * @param {UsersEntityAPIsApiGetEntityUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUsers(requestParameters, options) {
            return localVarFp
                .getEntityUsers(requestParameters.id, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User - represents entity interacting with platform
         * @summary Patch User entity
         * @param {UsersEntityAPIsApiPatchEntityUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUsers(requestParameters, options) {
            return localVarFp
                .patchEntityUsers(requestParameters.id, requestParameters.jsonApiUserPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * User - represents entity interacting with platform
         * @summary Put User entity
         * @param {UsersEntityAPIsApiUpdateEntityUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUsers(requestParameters, options) {
            return localVarFp
                .updateEntityUsers(requestParameters.id, requestParameters.jsonApiUserInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * UsersEntityAPIsApi - object-oriented interface
 * @export
 * @class UsersEntityAPIsApi
 * @extends {BaseAPI}
 */
export class UsersEntityAPIsApi extends BaseAPI {
    /**
     * User - represents entity interacting with platform
     * @summary Post User entities
     * @param {UsersEntityAPIsApiCreateEntityUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersEntityAPIsApi
     */
    createEntityUsers(requestParameters, options) {
        return UsersEntityAPIsApiFp(this.configuration)
            .createEntityUsers(requestParameters.jsonApiUserInDocument, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User - represents entity interacting with platform
     * @summary Delete User entity
     * @param {UsersEntityAPIsApiDeleteEntityUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersEntityAPIsApi
     */
    deleteEntityUsers(requestParameters, options) {
        return UsersEntityAPIsApiFp(this.configuration)
            .deleteEntityUsers(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User - represents entity interacting with platform
     * @summary Get User entities
     * @param {UsersEntityAPIsApiGetAllEntitiesUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersEntityAPIsApi
     */
    getAllEntitiesUsers(requestParameters = {}, options) {
        return UsersEntityAPIsApiFp(this.configuration)
            .getAllEntitiesUsers(requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User - represents entity interacting with platform
     * @summary Get User entity
     * @param {UsersEntityAPIsApiGetEntityUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersEntityAPIsApi
     */
    getEntityUsers(requestParameters, options) {
        return UsersEntityAPIsApiFp(this.configuration)
            .getEntityUsers(requestParameters.id, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User - represents entity interacting with platform
     * @summary Patch User entity
     * @param {UsersEntityAPIsApiPatchEntityUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersEntityAPIsApi
     */
    patchEntityUsers(requestParameters, options) {
        return UsersEntityAPIsApiFp(this.configuration)
            .patchEntityUsers(requestParameters.id, requestParameters.jsonApiUserPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * User - represents entity interacting with platform
     * @summary Put User entity
     * @param {UsersEntityAPIsApiUpdateEntityUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersEntityAPIsApi
     */
    updateEntityUsers(requestParameters, options) {
        return UsersEntityAPIsApiFp(this.configuration)
            .updateEntityUsers(requestParameters.id, requestParameters.jsonApiUserInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * VisualizationObjectApi - axios parameter creator
 * @export
 */
export const VisualizationObjectApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Post Visualization Objects
         * @param {string} workspaceId
         * @param {JsonApiVisualizationObjectPostOptionalIdDocument} jsonApiVisualizationObjectPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityVisualizationObjects: async (workspaceId, jsonApiVisualizationObjectPostOptionalIdDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityVisualizationObjects", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiVisualizationObjectPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityVisualizationObjects", "jsonApiVisualizationObjectPostOptionalIdDocument", jsonApiVisualizationObjectPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/visualizationObjects`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiVisualizationObjectPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiVisualizationObjectPostOptionalIdDocument !== undefined
                    ? jsonApiVisualizationObjectPostOptionalIdDocument
                    : {})
                : jsonApiVisualizationObjectPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityVisualizationObjects: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityVisualizationObjects", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityVisualizationObjects", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/visualizationObjects/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Visualization Objects
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesVisualizationObjects: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesVisualizationObjects", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/visualizationObjects`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityVisualizationObjects: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityVisualizationObjects", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityVisualizationObjects", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/visualizationObjects/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiVisualizationObjectPatchDocument} jsonApiVisualizationObjectPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityVisualizationObjects: async (workspaceId, objectId, jsonApiVisualizationObjectPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityVisualizationObjects", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityVisualizationObjects", "objectId", objectId);
            // verify required parameter 'jsonApiVisualizationObjectPatchDocument' is not null or undefined
            assertParamExists("patchEntityVisualizationObjects", "jsonApiVisualizationObjectPatchDocument", jsonApiVisualizationObjectPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/visualizationObjects/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiVisualizationObjectPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiVisualizationObjectPatchDocument !== undefined
                    ? jsonApiVisualizationObjectPatchDocument
                    : {})
                : jsonApiVisualizationObjectPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiVisualizationObjectInDocument} jsonApiVisualizationObjectInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityVisualizationObjects: async (workspaceId, objectId, jsonApiVisualizationObjectInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityVisualizationObjects", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityVisualizationObjects", "objectId", objectId);
            // verify required parameter 'jsonApiVisualizationObjectInDocument' is not null or undefined
            assertParamExists("updateEntityVisualizationObjects", "jsonApiVisualizationObjectInDocument", jsonApiVisualizationObjectInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/visualizationObjects/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiVisualizationObjectInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiVisualizationObjectInDocument !== undefined
                    ? jsonApiVisualizationObjectInDocument
                    : {})
                : jsonApiVisualizationObjectInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * VisualizationObjectApi - functional programming interface
 * @export
 */
export const VisualizationObjectApiFp = function (configuration) {
    const localVarAxiosParamCreator = VisualizationObjectApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Post Visualization Objects
         * @param {string} workspaceId
         * @param {JsonApiVisualizationObjectPostOptionalIdDocument} jsonApiVisualizationObjectPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityVisualizationObjects(workspaceId, jsonApiVisualizationObjectPostOptionalIdDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityVisualizationObjects(workspaceId, jsonApiVisualizationObjectPostOptionalIdDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityVisualizationObjects(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityVisualizationObjects(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Visualization Objects
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesVisualizationObjects(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesVisualizationObjects(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityVisualizationObjects(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityVisualizationObjects(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiVisualizationObjectPatchDocument} jsonApiVisualizationObjectPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityVisualizationObjects(workspaceId, objectId, jsonApiVisualizationObjectPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityVisualizationObjects(workspaceId, objectId, jsonApiVisualizationObjectPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiVisualizationObjectInDocument} jsonApiVisualizationObjectInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityVisualizationObjects(workspaceId, objectId, jsonApiVisualizationObjectInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityVisualizationObjects(workspaceId, objectId, jsonApiVisualizationObjectInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * VisualizationObjectApi - factory interface
 * @export
 */
export const VisualizationObjectApiFactory = function (configuration, basePath, axios) {
    const localVarFp = VisualizationObjectApiFp(configuration);
    return {
        /**
         *
         * @summary Post Visualization Objects
         * @param {VisualizationObjectApiCreateEntityVisualizationObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityVisualizationObjects(requestParameters, options) {
            return localVarFp
                .createEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.jsonApiVisualizationObjectPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Visualization Object
         * @param {VisualizationObjectApiDeleteEntityVisualizationObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityVisualizationObjects(requestParameters, options) {
            return localVarFp
                .deleteEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Visualization Objects
         * @param {VisualizationObjectApiGetAllEntitiesVisualizationObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesVisualizationObjects(requestParameters, options) {
            return localVarFp
                .getAllEntitiesVisualizationObjects(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Visualization Object
         * @param {VisualizationObjectApiGetEntityVisualizationObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityVisualizationObjects(requestParameters, options) {
            return localVarFp
                .getEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Visualization Object
         * @param {VisualizationObjectApiPatchEntityVisualizationObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityVisualizationObjects(requestParameters, options) {
            return localVarFp
                .patchEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiVisualizationObjectPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Visualization Object
         * @param {VisualizationObjectApiUpdateEntityVisualizationObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityVisualizationObjects(requestParameters, options) {
            return localVarFp
                .updateEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiVisualizationObjectInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * VisualizationObjectApi - object-oriented interface
 * @export
 * @class VisualizationObjectApi
 * @extends {BaseAPI}
 */
export class VisualizationObjectApi extends BaseAPI {
    /**
     *
     * @summary Post Visualization Objects
     * @param {VisualizationObjectApiCreateEntityVisualizationObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualizationObjectApi
     */
    createEntityVisualizationObjects(requestParameters, options) {
        return VisualizationObjectApiFp(this.configuration)
            .createEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.jsonApiVisualizationObjectPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Visualization Object
     * @param {VisualizationObjectApiDeleteEntityVisualizationObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualizationObjectApi
     */
    deleteEntityVisualizationObjects(requestParameters, options) {
        return VisualizationObjectApiFp(this.configuration)
            .deleteEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Visualization Objects
     * @param {VisualizationObjectApiGetAllEntitiesVisualizationObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualizationObjectApi
     */
    getAllEntitiesVisualizationObjects(requestParameters, options) {
        return VisualizationObjectApiFp(this.configuration)
            .getAllEntitiesVisualizationObjects(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Visualization Object
     * @param {VisualizationObjectApiGetEntityVisualizationObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualizationObjectApi
     */
    getEntityVisualizationObjects(requestParameters, options) {
        return VisualizationObjectApiFp(this.configuration)
            .getEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Visualization Object
     * @param {VisualizationObjectApiPatchEntityVisualizationObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualizationObjectApi
     */
    patchEntityVisualizationObjects(requestParameters, options) {
        return VisualizationObjectApiFp(this.configuration)
            .patchEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiVisualizationObjectPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Visualization Object
     * @param {VisualizationObjectApiUpdateEntityVisualizationObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualizationObjectApi
     */
    updateEntityVisualizationObjects(requestParameters, options) {
        return VisualizationObjectApiFp(this.configuration)
            .updateEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiVisualizationObjectInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * WorkspaceObjectControllerApi - axios parameter creator
 * @export
 */
export const WorkspaceObjectControllerApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Post Dashboards
         * @param {string} workspaceId
         * @param {JsonApiAnalyticalDashboardPostOptionalIdDocument} jsonApiAnalyticalDashboardPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'permissions' | 'origin' | 'accessInfo' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityAnalyticalDashboards: async (workspaceId, jsonApiAnalyticalDashboardPostOptionalIdDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityAnalyticalDashboards", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiAnalyticalDashboardPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityAnalyticalDashboards", "jsonApiAnalyticalDashboardPostOptionalIdDocument", jsonApiAnalyticalDashboardPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/analyticalDashboards`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiAnalyticalDashboardPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiAnalyticalDashboardPostOptionalIdDocument !== undefined
                    ? jsonApiAnalyticalDashboardPostOptionalIdDocument
                    : {})
                : jsonApiAnalyticalDashboardPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Attribute Hierarchies
         * @param {string} workspaceId
         * @param {JsonApiAttributeHierarchyInDocument} jsonApiAttributeHierarchyInDocument
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityAttributeHierarchies: async (workspaceId, jsonApiAttributeHierarchyInDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityAttributeHierarchies", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiAttributeHierarchyInDocument' is not null or undefined
            assertParamExists("createEntityAttributeHierarchies", "jsonApiAttributeHierarchyInDocument", jsonApiAttributeHierarchyInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributeHierarchies`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiAttributeHierarchyInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiAttributeHierarchyInDocument !== undefined
                    ? jsonApiAttributeHierarchyInDocument
                    : {})
                : jsonApiAttributeHierarchyInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Custom Application Settings
         * @param {string} workspaceId
         * @param {JsonApiCustomApplicationSettingPostOptionalIdDocument} jsonApiCustomApplicationSettingPostOptionalIdDocument
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityCustomApplicationSettings: async (workspaceId, jsonApiCustomApplicationSettingPostOptionalIdDocument, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityCustomApplicationSettings", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiCustomApplicationSettingPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityCustomApplicationSettings", "jsonApiCustomApplicationSettingPostOptionalIdDocument", jsonApiCustomApplicationSettingPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/customApplicationSettings`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCustomApplicationSettingPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCustomApplicationSettingPostOptionalIdDocument !== undefined
                    ? jsonApiCustomApplicationSettingPostOptionalIdDocument
                    : {})
                : jsonApiCustomApplicationSettingPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Plugins
         * @param {string} workspaceId
         * @param {JsonApiDashboardPluginPostOptionalIdDocument} jsonApiDashboardPluginPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityDashboardPlugins: async (workspaceId, jsonApiDashboardPluginPostOptionalIdDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityDashboardPlugins", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiDashboardPluginPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityDashboardPlugins", "jsonApiDashboardPluginPostOptionalIdDocument", jsonApiDashboardPluginPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/dashboardPlugins`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiDashboardPluginPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiDashboardPluginPostOptionalIdDocument !== undefined
                    ? jsonApiDashboardPluginPostOptionalIdDocument
                    : {})
                : jsonApiDashboardPluginPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Context Filters
         * @param {string} workspaceId
         * @param {JsonApiFilterContextPostOptionalIdDocument} jsonApiFilterContextPostOptionalIdDocument
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityFilterContexts: async (workspaceId, jsonApiFilterContextPostOptionalIdDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityFilterContexts", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiFilterContextPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityFilterContexts", "jsonApiFilterContextPostOptionalIdDocument", jsonApiFilterContextPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/filterContexts`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiFilterContextPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiFilterContextPostOptionalIdDocument !== undefined
                    ? jsonApiFilterContextPostOptionalIdDocument
                    : {})
                : jsonApiFilterContextPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Metrics
         * @param {string} workspaceId
         * @param {JsonApiMetricPostOptionalIdDocument} jsonApiMetricPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityMetrics: async (workspaceId, jsonApiMetricPostOptionalIdDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityMetrics", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiMetricPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityMetrics", "jsonApiMetricPostOptionalIdDocument", jsonApiMetricPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/metrics`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiMetricPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiMetricPostOptionalIdDocument !== undefined
                    ? jsonApiMetricPostOptionalIdDocument
                    : {})
                : jsonApiMetricPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post User Data Filters
         * @param {string} workspaceId
         * @param {JsonApiUserDataFilterPostOptionalIdDocument} jsonApiUserDataFilterPostOptionalIdDocument
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUserDataFilters: async (workspaceId, jsonApiUserDataFilterPostOptionalIdDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityUserDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiUserDataFilterPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityUserDataFilters", "jsonApiUserDataFilterPostOptionalIdDocument", jsonApiUserDataFilterPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/userDataFilters`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserDataFilterPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserDataFilterPostOptionalIdDocument !== undefined
                    ? jsonApiUserDataFilterPostOptionalIdDocument
                    : {})
                : jsonApiUserDataFilterPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Visualization Objects
         * @param {string} workspaceId
         * @param {JsonApiVisualizationObjectPostOptionalIdDocument} jsonApiVisualizationObjectPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityVisualizationObjects: async (workspaceId, jsonApiVisualizationObjectPostOptionalIdDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityVisualizationObjects", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiVisualizationObjectPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityVisualizationObjects", "jsonApiVisualizationObjectPostOptionalIdDocument", jsonApiVisualizationObjectPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/visualizationObjects`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiVisualizationObjectPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiVisualizationObjectPostOptionalIdDocument !== undefined
                    ? jsonApiVisualizationObjectPostOptionalIdDocument
                    : {})
                : jsonApiVisualizationObjectPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Settings for Workspace Data Filters
         * @param {string} workspaceId
         * @param {JsonApiWorkspaceDataFilterSettingInDocument} jsonApiWorkspaceDataFilterSettingInDocument
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaceDataFilterSettings: async (workspaceId, jsonApiWorkspaceDataFilterSettingInDocument, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityWorkspaceDataFilterSettings", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiWorkspaceDataFilterSettingInDocument' is not null or undefined
            assertParamExists("createEntityWorkspaceDataFilterSettings", "jsonApiWorkspaceDataFilterSettingInDocument", jsonApiWorkspaceDataFilterSettingInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilterSettings`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceDataFilterSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceDataFilterSettingInDocument !== undefined
                    ? jsonApiWorkspaceDataFilterSettingInDocument
                    : {})
                : jsonApiWorkspaceDataFilterSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Workspace Data Filters
         * @param {string} workspaceId
         * @param {JsonApiWorkspaceDataFilterInDocument} jsonApiWorkspaceDataFilterInDocument
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaceDataFilters: async (workspaceId, jsonApiWorkspaceDataFilterInDocument, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityWorkspaceDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiWorkspaceDataFilterInDocument' is not null or undefined
            assertParamExists("createEntityWorkspaceDataFilters", "jsonApiWorkspaceDataFilterInDocument", jsonApiWorkspaceDataFilterInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilters`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceDataFilterInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceDataFilterInDocument !== undefined
                    ? jsonApiWorkspaceDataFilterInDocument
                    : {})
                : jsonApiWorkspaceDataFilterInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Settings for Workspaces
         * @param {string} workspaceId
         * @param {JsonApiWorkspaceSettingPostOptionalIdDocument} jsonApiWorkspaceSettingPostOptionalIdDocument
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaceSettings: async (workspaceId, jsonApiWorkspaceSettingPostOptionalIdDocument, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityWorkspaceSettings", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiWorkspaceSettingPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityWorkspaceSettings", "jsonApiWorkspaceSettingPostOptionalIdDocument", jsonApiWorkspaceSettingPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceSettings`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceSettingPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceSettingPostOptionalIdDocument !== undefined
                    ? jsonApiWorkspaceSettingPostOptionalIdDocument
                    : {})
                : jsonApiWorkspaceSettingPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Dashboard
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityAnalyticalDashboards: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityAnalyticalDashboards", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityAnalyticalDashboards", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/analyticalDashboards/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityAttributeHierarchies: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityAttributeHierarchies", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityAttributeHierarchies", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributeHierarchies/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityCustomApplicationSettings: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityCustomApplicationSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityCustomApplicationSettings", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/customApplicationSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityDashboardPlugins: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityDashboardPlugins", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityDashboardPlugins", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/dashboardPlugins/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityFilterContexts: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityFilterContexts", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityFilterContexts", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/filterContexts/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityMetrics: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityMetrics", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityMetrics", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/metrics/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUserDataFilters: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityUserDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityUserDataFilters", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/userDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityVisualizationObjects: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityVisualizationObjects", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityVisualizationObjects", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/visualizationObjects/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Settings for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaceDataFilterSettings: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityWorkspaceDataFilterSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityWorkspaceDataFilterSettings", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilterSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaceDataFilters: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityWorkspaceDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityWorkspaceDataFilters", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Setting for Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaceSettings: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityWorkspaceSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityWorkspaceSettings", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Dashboards
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'permissions' | 'origin' | 'accessInfo' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAnalyticalDashboards: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesAnalyticalDashboards", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/analyticalDashboards`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Attribute Hierarchies
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAttributeHierarchies: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesAttributeHierarchies", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributeHierarchies`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Attributes
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'labels' | 'attributeHierarchies' | 'dataset' | 'defaultView' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAttributes: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesAttributes", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributes`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Custom Application Settings
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesCustomApplicationSettings: async (workspaceId, origin, filter, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesCustomApplicationSettings", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/customApplicationSettings`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Plugins
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDashboardPlugins: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesDashboardPlugins", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/dashboardPlugins`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Datasets
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'facts' | 'datasets' | 'workspaceDataFilters' | 'references' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDatasets: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesDatasets", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/datasets`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Facts
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'dataset' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesFacts: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesFacts", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/facts`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Context Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesFilterContexts: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesFilterContexts", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/filterContexts`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Labels
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'attribute' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesLabels: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesLabels", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/labels`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Metrics
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesMetrics: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesMetrics", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/metrics`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all User Data Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserDataFilters: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesUserDataFilters", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/userDataFilters`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Visualization Objects
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesVisualizationObjects: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesVisualizationObjects", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/visualizationObjects`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Settings for Workspace Data Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceDataFilterSettings: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesWorkspaceDataFilterSettings", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilterSettings`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Workspace Data Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceDataFilters: async (workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesWorkspaceDataFilters", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilters`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Setting for Workspaces
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceSettings: async (workspaceId, origin, filter, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesWorkspaceSettings", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceSettings`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Dashboard
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'permissions' | 'origin' | 'accessInfo' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAnalyticalDashboards: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityAnalyticalDashboards", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityAnalyticalDashboards", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/analyticalDashboards/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAttributeHierarchies: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityAttributeHierarchies", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityAttributeHierarchies", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributeHierarchies/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get an Attribute
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'labels' | 'attributeHierarchies' | 'dataset' | 'defaultView' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAttributes: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityAttributes", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityAttributes", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributes/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityCustomApplicationSettings: async (workspaceId, objectId, filter, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityCustomApplicationSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityCustomApplicationSettings", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/customApplicationSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDashboardPlugins: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityDashboardPlugins", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityDashboardPlugins", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/dashboardPlugins/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Dataset
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'facts' | 'datasets' | 'workspaceDataFilters' | 'references' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDatasets: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityDatasets", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityDatasets", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/datasets/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Fact
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'dataset' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityFacts: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityFacts", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityFacts", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/facts/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityFilterContexts: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityFilterContexts", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityFilterContexts", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/filterContexts/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Label
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'attribute' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityLabels: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityLabels", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityLabels", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/labels/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityMetrics: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityMetrics", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityMetrics", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/metrics/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserDataFilters: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityUserDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityUserDataFilters", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/userDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityVisualizationObjects: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityVisualizationObjects", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityVisualizationObjects", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/visualizationObjects/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Setting for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceDataFilterSettings: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityWorkspaceDataFilterSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityWorkspaceDataFilterSettings", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilterSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceDataFilters: async (workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityWorkspaceDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityWorkspaceDataFilters", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Setting for Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceSettings: async (workspaceId, objectId, filter, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityWorkspaceSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityWorkspaceSettings", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Dashboard
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAnalyticalDashboardPatchDocument} jsonApiAnalyticalDashboardPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityAnalyticalDashboards: async (workspaceId, objectId, jsonApiAnalyticalDashboardPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityAnalyticalDashboards", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityAnalyticalDashboards", "objectId", objectId);
            // verify required parameter 'jsonApiAnalyticalDashboardPatchDocument' is not null or undefined
            assertParamExists("patchEntityAnalyticalDashboards", "jsonApiAnalyticalDashboardPatchDocument", jsonApiAnalyticalDashboardPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/analyticalDashboards/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiAnalyticalDashboardPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiAnalyticalDashboardPatchDocument !== undefined
                    ? jsonApiAnalyticalDashboardPatchDocument
                    : {})
                : jsonApiAnalyticalDashboardPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAttributeHierarchyPatchDocument} jsonApiAttributeHierarchyPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityAttributeHierarchies: async (workspaceId, objectId, jsonApiAttributeHierarchyPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityAttributeHierarchies", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityAttributeHierarchies", "objectId", objectId);
            // verify required parameter 'jsonApiAttributeHierarchyPatchDocument' is not null or undefined
            assertParamExists("patchEntityAttributeHierarchies", "jsonApiAttributeHierarchyPatchDocument", jsonApiAttributeHierarchyPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributeHierarchies/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiAttributeHierarchyPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiAttributeHierarchyPatchDocument !== undefined
                    ? jsonApiAttributeHierarchyPatchDocument
                    : {})
                : jsonApiAttributeHierarchyPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiCustomApplicationSettingPatchDocument} jsonApiCustomApplicationSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityCustomApplicationSettings: async (workspaceId, objectId, jsonApiCustomApplicationSettingPatchDocument, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityCustomApplicationSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityCustomApplicationSettings", "objectId", objectId);
            // verify required parameter 'jsonApiCustomApplicationSettingPatchDocument' is not null or undefined
            assertParamExists("patchEntityCustomApplicationSettings", "jsonApiCustomApplicationSettingPatchDocument", jsonApiCustomApplicationSettingPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/customApplicationSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCustomApplicationSettingPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCustomApplicationSettingPatchDocument !== undefined
                    ? jsonApiCustomApplicationSettingPatchDocument
                    : {})
                : jsonApiCustomApplicationSettingPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiDashboardPluginPatchDocument} jsonApiDashboardPluginPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityDashboardPlugins: async (workspaceId, objectId, jsonApiDashboardPluginPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityDashboardPlugins", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityDashboardPlugins", "objectId", objectId);
            // verify required parameter 'jsonApiDashboardPluginPatchDocument' is not null or undefined
            assertParamExists("patchEntityDashboardPlugins", "jsonApiDashboardPluginPatchDocument", jsonApiDashboardPluginPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/dashboardPlugins/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiDashboardPluginPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiDashboardPluginPatchDocument !== undefined
                    ? jsonApiDashboardPluginPatchDocument
                    : {})
                : jsonApiDashboardPluginPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiFilterContextPatchDocument} jsonApiFilterContextPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityFilterContexts: async (workspaceId, objectId, jsonApiFilterContextPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityFilterContexts", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityFilterContexts", "objectId", objectId);
            // verify required parameter 'jsonApiFilterContextPatchDocument' is not null or undefined
            assertParamExists("patchEntityFilterContexts", "jsonApiFilterContextPatchDocument", jsonApiFilterContextPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/filterContexts/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiFilterContextPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiFilterContextPatchDocument !== undefined
                    ? jsonApiFilterContextPatchDocument
                    : {})
                : jsonApiFilterContextPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiMetricPatchDocument} jsonApiMetricPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityMetrics: async (workspaceId, objectId, jsonApiMetricPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityMetrics", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityMetrics", "objectId", objectId);
            // verify required parameter 'jsonApiMetricPatchDocument' is not null or undefined
            assertParamExists("patchEntityMetrics", "jsonApiMetricPatchDocument", jsonApiMetricPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/metrics/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiMetricPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiMetricPatchDocument !== undefined ? jsonApiMetricPatchDocument : {})
                : jsonApiMetricPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiUserDataFilterPatchDocument} jsonApiUserDataFilterPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUserDataFilters: async (workspaceId, objectId, jsonApiUserDataFilterPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityUserDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityUserDataFilters", "objectId", objectId);
            // verify required parameter 'jsonApiUserDataFilterPatchDocument' is not null or undefined
            assertParamExists("patchEntityUserDataFilters", "jsonApiUserDataFilterPatchDocument", jsonApiUserDataFilterPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/userDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserDataFilterPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserDataFilterPatchDocument !== undefined
                    ? jsonApiUserDataFilterPatchDocument
                    : {})
                : jsonApiUserDataFilterPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiVisualizationObjectPatchDocument} jsonApiVisualizationObjectPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityVisualizationObjects: async (workspaceId, objectId, jsonApiVisualizationObjectPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityVisualizationObjects", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityVisualizationObjects", "objectId", objectId);
            // verify required parameter 'jsonApiVisualizationObjectPatchDocument' is not null or undefined
            assertParamExists("patchEntityVisualizationObjects", "jsonApiVisualizationObjectPatchDocument", jsonApiVisualizationObjectPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/visualizationObjects/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiVisualizationObjectPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiVisualizationObjectPatchDocument !== undefined
                    ? jsonApiVisualizationObjectPatchDocument
                    : {})
                : jsonApiVisualizationObjectPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Settings for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterSettingPatchDocument} jsonApiWorkspaceDataFilterSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaceDataFilterSettings: async (workspaceId, objectId, jsonApiWorkspaceDataFilterSettingPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityWorkspaceDataFilterSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityWorkspaceDataFilterSettings", "objectId", objectId);
            // verify required parameter 'jsonApiWorkspaceDataFilterSettingPatchDocument' is not null or undefined
            assertParamExists("patchEntityWorkspaceDataFilterSettings", "jsonApiWorkspaceDataFilterSettingPatchDocument", jsonApiWorkspaceDataFilterSettingPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilterSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceDataFilterSettingPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceDataFilterSettingPatchDocument !== undefined
                    ? jsonApiWorkspaceDataFilterSettingPatchDocument
                    : {})
                : jsonApiWorkspaceDataFilterSettingPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterPatchDocument} jsonApiWorkspaceDataFilterPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaceDataFilters: async (workspaceId, objectId, jsonApiWorkspaceDataFilterPatchDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityWorkspaceDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityWorkspaceDataFilters", "objectId", objectId);
            // verify required parameter 'jsonApiWorkspaceDataFilterPatchDocument' is not null or undefined
            assertParamExists("patchEntityWorkspaceDataFilters", "jsonApiWorkspaceDataFilterPatchDocument", jsonApiWorkspaceDataFilterPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceDataFilterPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceDataFilterPatchDocument !== undefined
                    ? jsonApiWorkspaceDataFilterPatchDocument
                    : {})
                : jsonApiWorkspaceDataFilterPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Setting for Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceSettingPatchDocument} jsonApiWorkspaceSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaceSettings: async (workspaceId, objectId, jsonApiWorkspaceSettingPatchDocument, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityWorkspaceSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityWorkspaceSettings", "objectId", objectId);
            // verify required parameter 'jsonApiWorkspaceSettingPatchDocument' is not null or undefined
            assertParamExists("patchEntityWorkspaceSettings", "jsonApiWorkspaceSettingPatchDocument", jsonApiWorkspaceSettingPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceSettingPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceSettingPatchDocument !== undefined
                    ? jsonApiWorkspaceSettingPatchDocument
                    : {})
                : jsonApiWorkspaceSettingPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put Dashboards
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAnalyticalDashboardInDocument} jsonApiAnalyticalDashboardInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityAnalyticalDashboards: async (workspaceId, objectId, jsonApiAnalyticalDashboardInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityAnalyticalDashboards", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityAnalyticalDashboards", "objectId", objectId);
            // verify required parameter 'jsonApiAnalyticalDashboardInDocument' is not null or undefined
            assertParamExists("updateEntityAnalyticalDashboards", "jsonApiAnalyticalDashboardInDocument", jsonApiAnalyticalDashboardInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/analyticalDashboards/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiAnalyticalDashboardInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiAnalyticalDashboardInDocument !== undefined
                    ? jsonApiAnalyticalDashboardInDocument
                    : {})
                : jsonApiAnalyticalDashboardInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAttributeHierarchyInDocument} jsonApiAttributeHierarchyInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityAttributeHierarchies: async (workspaceId, objectId, jsonApiAttributeHierarchyInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityAttributeHierarchies", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityAttributeHierarchies", "objectId", objectId);
            // verify required parameter 'jsonApiAttributeHierarchyInDocument' is not null or undefined
            assertParamExists("updateEntityAttributeHierarchies", "jsonApiAttributeHierarchyInDocument", jsonApiAttributeHierarchyInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/attributeHierarchies/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiAttributeHierarchyInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiAttributeHierarchyInDocument !== undefined
                    ? jsonApiAttributeHierarchyInDocument
                    : {})
                : jsonApiAttributeHierarchyInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiCustomApplicationSettingInDocument} jsonApiCustomApplicationSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityCustomApplicationSettings: async (workspaceId, objectId, jsonApiCustomApplicationSettingInDocument, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityCustomApplicationSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityCustomApplicationSettings", "objectId", objectId);
            // verify required parameter 'jsonApiCustomApplicationSettingInDocument' is not null or undefined
            assertParamExists("updateEntityCustomApplicationSettings", "jsonApiCustomApplicationSettingInDocument", jsonApiCustomApplicationSettingInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/customApplicationSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCustomApplicationSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCustomApplicationSettingInDocument !== undefined
                    ? jsonApiCustomApplicationSettingInDocument
                    : {})
                : jsonApiCustomApplicationSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiDashboardPluginInDocument} jsonApiDashboardPluginInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityDashboardPlugins: async (workspaceId, objectId, jsonApiDashboardPluginInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityDashboardPlugins", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityDashboardPlugins", "objectId", objectId);
            // verify required parameter 'jsonApiDashboardPluginInDocument' is not null or undefined
            assertParamExists("updateEntityDashboardPlugins", "jsonApiDashboardPluginInDocument", jsonApiDashboardPluginInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/dashboardPlugins/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiDashboardPluginInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiDashboardPluginInDocument !== undefined ? jsonApiDashboardPluginInDocument : {})
                : jsonApiDashboardPluginInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiFilterContextInDocument} jsonApiFilterContextInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityFilterContexts: async (workspaceId, objectId, jsonApiFilterContextInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityFilterContexts", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityFilterContexts", "objectId", objectId);
            // verify required parameter 'jsonApiFilterContextInDocument' is not null or undefined
            assertParamExists("updateEntityFilterContexts", "jsonApiFilterContextInDocument", jsonApiFilterContextInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/filterContexts/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiFilterContextInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiFilterContextInDocument !== undefined ? jsonApiFilterContextInDocument : {})
                : jsonApiFilterContextInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiMetricInDocument} jsonApiMetricInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityMetrics: async (workspaceId, objectId, jsonApiMetricInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityMetrics", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityMetrics", "objectId", objectId);
            // verify required parameter 'jsonApiMetricInDocument' is not null or undefined
            assertParamExists("updateEntityMetrics", "jsonApiMetricInDocument", jsonApiMetricInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/metrics/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiMetricInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiMetricInDocument !== undefined ? jsonApiMetricInDocument : {})
                : jsonApiMetricInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiUserDataFilterInDocument} jsonApiUserDataFilterInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUserDataFilters: async (workspaceId, objectId, jsonApiUserDataFilterInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityUserDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityUserDataFilters", "objectId", objectId);
            // verify required parameter 'jsonApiUserDataFilterInDocument' is not null or undefined
            assertParamExists("updateEntityUserDataFilters", "jsonApiUserDataFilterInDocument", jsonApiUserDataFilterInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/userDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiUserDataFilterInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserDataFilterInDocument !== undefined ? jsonApiUserDataFilterInDocument : {})
                : jsonApiUserDataFilterInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiVisualizationObjectInDocument} jsonApiVisualizationObjectInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityVisualizationObjects: async (workspaceId, objectId, jsonApiVisualizationObjectInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityVisualizationObjects", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityVisualizationObjects", "objectId", objectId);
            // verify required parameter 'jsonApiVisualizationObjectInDocument' is not null or undefined
            assertParamExists("updateEntityVisualizationObjects", "jsonApiVisualizationObjectInDocument", jsonApiVisualizationObjectInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/visualizationObjects/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiVisualizationObjectInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiVisualizationObjectInDocument !== undefined
                    ? jsonApiVisualizationObjectInDocument
                    : {})
                : jsonApiVisualizationObjectInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Settings for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterSettingInDocument} jsonApiWorkspaceDataFilterSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaceDataFilterSettings: async (workspaceId, objectId, jsonApiWorkspaceDataFilterSettingInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityWorkspaceDataFilterSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityWorkspaceDataFilterSettings", "objectId", objectId);
            // verify required parameter 'jsonApiWorkspaceDataFilterSettingInDocument' is not null or undefined
            assertParamExists("updateEntityWorkspaceDataFilterSettings", "jsonApiWorkspaceDataFilterSettingInDocument", jsonApiWorkspaceDataFilterSettingInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilterSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceDataFilterSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceDataFilterSettingInDocument !== undefined
                    ? jsonApiWorkspaceDataFilterSettingInDocument
                    : {})
                : jsonApiWorkspaceDataFilterSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterInDocument} jsonApiWorkspaceDataFilterInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaceDataFilters: async (workspaceId, objectId, jsonApiWorkspaceDataFilterInDocument, filter, include, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityWorkspaceDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityWorkspaceDataFilters", "objectId", objectId);
            // verify required parameter 'jsonApiWorkspaceDataFilterInDocument' is not null or undefined
            assertParamExists("updateEntityWorkspaceDataFilters", "jsonApiWorkspaceDataFilterInDocument", jsonApiWorkspaceDataFilterInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceDataFilterInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceDataFilterInDocument !== undefined
                    ? jsonApiWorkspaceDataFilterInDocument
                    : {})
                : jsonApiWorkspaceDataFilterInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Setting for a Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceSettingInDocument} jsonApiWorkspaceSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaceSettings: async (workspaceId, objectId, jsonApiWorkspaceSettingInDocument, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityWorkspaceSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityWorkspaceSettings", "objectId", objectId);
            // verify required parameter 'jsonApiWorkspaceSettingInDocument' is not null or undefined
            assertParamExists("updateEntityWorkspaceSettings", "jsonApiWorkspaceSettingInDocument", jsonApiWorkspaceSettingInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceSettingInDocument !== undefined
                    ? jsonApiWorkspaceSettingInDocument
                    : {})
                : jsonApiWorkspaceSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * WorkspaceObjectControllerApi - functional programming interface
 * @export
 */
export const WorkspaceObjectControllerApiFp = function (configuration) {
    const localVarAxiosParamCreator = WorkspaceObjectControllerApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Post Dashboards
         * @param {string} workspaceId
         * @param {JsonApiAnalyticalDashboardPostOptionalIdDocument} jsonApiAnalyticalDashboardPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'permissions' | 'origin' | 'accessInfo' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityAnalyticalDashboards(workspaceId, jsonApiAnalyticalDashboardPostOptionalIdDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityAnalyticalDashboards(workspaceId, jsonApiAnalyticalDashboardPostOptionalIdDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Attribute Hierarchies
         * @param {string} workspaceId
         * @param {JsonApiAttributeHierarchyInDocument} jsonApiAttributeHierarchyInDocument
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityAttributeHierarchies(workspaceId, jsonApiAttributeHierarchyInDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityAttributeHierarchies(workspaceId, jsonApiAttributeHierarchyInDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Custom Application Settings
         * @param {string} workspaceId
         * @param {JsonApiCustomApplicationSettingPostOptionalIdDocument} jsonApiCustomApplicationSettingPostOptionalIdDocument
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityCustomApplicationSettings(workspaceId, jsonApiCustomApplicationSettingPostOptionalIdDocument, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityCustomApplicationSettings(workspaceId, jsonApiCustomApplicationSettingPostOptionalIdDocument, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Plugins
         * @param {string} workspaceId
         * @param {JsonApiDashboardPluginPostOptionalIdDocument} jsonApiDashboardPluginPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityDashboardPlugins(workspaceId, jsonApiDashboardPluginPostOptionalIdDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityDashboardPlugins(workspaceId, jsonApiDashboardPluginPostOptionalIdDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Context Filters
         * @param {string} workspaceId
         * @param {JsonApiFilterContextPostOptionalIdDocument} jsonApiFilterContextPostOptionalIdDocument
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityFilterContexts(workspaceId, jsonApiFilterContextPostOptionalIdDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityFilterContexts(workspaceId, jsonApiFilterContextPostOptionalIdDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Metrics
         * @param {string} workspaceId
         * @param {JsonApiMetricPostOptionalIdDocument} jsonApiMetricPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityMetrics(workspaceId, jsonApiMetricPostOptionalIdDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityMetrics(workspaceId, jsonApiMetricPostOptionalIdDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post User Data Filters
         * @param {string} workspaceId
         * @param {JsonApiUserDataFilterPostOptionalIdDocument} jsonApiUserDataFilterPostOptionalIdDocument
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityUserDataFilters(workspaceId, jsonApiUserDataFilterPostOptionalIdDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityUserDataFilters(workspaceId, jsonApiUserDataFilterPostOptionalIdDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Visualization Objects
         * @param {string} workspaceId
         * @param {JsonApiVisualizationObjectPostOptionalIdDocument} jsonApiVisualizationObjectPostOptionalIdDocument
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityVisualizationObjects(workspaceId, jsonApiVisualizationObjectPostOptionalIdDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityVisualizationObjects(workspaceId, jsonApiVisualizationObjectPostOptionalIdDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Settings for Workspace Data Filters
         * @param {string} workspaceId
         * @param {JsonApiWorkspaceDataFilterSettingInDocument} jsonApiWorkspaceDataFilterSettingInDocument
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityWorkspaceDataFilterSettings(workspaceId, jsonApiWorkspaceDataFilterSettingInDocument, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityWorkspaceDataFilterSettings(workspaceId, jsonApiWorkspaceDataFilterSettingInDocument, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Workspace Data Filters
         * @param {string} workspaceId
         * @param {JsonApiWorkspaceDataFilterInDocument} jsonApiWorkspaceDataFilterInDocument
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityWorkspaceDataFilters(workspaceId, jsonApiWorkspaceDataFilterInDocument, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityWorkspaceDataFilters(workspaceId, jsonApiWorkspaceDataFilterInDocument, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Settings for Workspaces
         * @param {string} workspaceId
         * @param {JsonApiWorkspaceSettingPostOptionalIdDocument} jsonApiWorkspaceSettingPostOptionalIdDocument
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityWorkspaceSettings(workspaceId, jsonApiWorkspaceSettingPostOptionalIdDocument, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityWorkspaceSettings(workspaceId, jsonApiWorkspaceSettingPostOptionalIdDocument, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Dashboard
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityAnalyticalDashboards(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityAnalyticalDashboards(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityAttributeHierarchies(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityAttributeHierarchies(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityCustomApplicationSettings(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityCustomApplicationSettings(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityDashboardPlugins(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityDashboardPlugins(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityFilterContexts(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityFilterContexts(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityMetrics(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityMetrics(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityUserDataFilters(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityUserDataFilters(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityVisualizationObjects(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityVisualizationObjects(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Settings for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityWorkspaceDataFilterSettings(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityWorkspaceDataFilterSettings(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityWorkspaceDataFilters(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityWorkspaceDataFilters(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Setting for Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityWorkspaceSettings(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityWorkspaceSettings(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Dashboards
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'permissions' | 'origin' | 'accessInfo' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesAnalyticalDashboards(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesAnalyticalDashboards(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Attribute Hierarchies
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesAttributeHierarchies(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesAttributeHierarchies(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Attributes
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'labels' | 'attributeHierarchies' | 'dataset' | 'defaultView' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesAttributes(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesAttributes(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Custom Application Settings
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesCustomApplicationSettings(workspaceId, origin, filter, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesCustomApplicationSettings(workspaceId, origin, filter, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Plugins
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesDashboardPlugins(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesDashboardPlugins(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Datasets
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'facts' | 'datasets' | 'workspaceDataFilters' | 'references' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesDatasets(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesDatasets(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Facts
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'dataset' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesFacts(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesFacts(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Context Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesFilterContexts(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesFilterContexts(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Labels
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'attribute' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesLabels(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesLabels(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Metrics
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesMetrics(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesMetrics(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all User Data Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesUserDataFilters(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesUserDataFilters(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Visualization Objects
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesVisualizationObjects(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesVisualizationObjects(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Settings for Workspace Data Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesWorkspaceDataFilterSettings(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesWorkspaceDataFilterSettings(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Workspace Data Filters
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesWorkspaceDataFilters(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesWorkspaceDataFilters(workspaceId, origin, filter, include, page, size, sort, xGDCVALIDATERELATIONS, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Setting for Workspaces
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesWorkspaceSettings(workspaceId, origin, filter, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesWorkspaceSettings(workspaceId, origin, filter, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Dashboard
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'permissions' | 'origin' | 'accessInfo' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityAnalyticalDashboards(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityAnalyticalDashboards(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityAttributeHierarchies(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityAttributeHierarchies(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get an Attribute
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'labels' | 'attributeHierarchies' | 'dataset' | 'defaultView' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityAttributes(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityAttributes(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityCustomApplicationSettings(workspaceId, objectId, filter, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityCustomApplicationSettings(workspaceId, objectId, filter, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityDashboardPlugins(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityDashboardPlugins(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Dataset
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'facts' | 'datasets' | 'workspaceDataFilters' | 'references' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityDatasets(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityDatasets(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Fact
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'dataset' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityFacts(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityFacts(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityFilterContexts(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityFilterContexts(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Label
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'attribute' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityLabels(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityLabels(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityMetrics(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityMetrics(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityUserDataFilters(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityUserDataFilters(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityVisualizationObjects(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityVisualizationObjects(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Setting for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityWorkspaceDataFilterSettings(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityWorkspaceDataFilterSettings(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityWorkspaceDataFilters(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityWorkspaceDataFilters(workspaceId, objectId, filter, include, xGDCVALIDATERELATIONS, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Setting for Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityWorkspaceSettings(workspaceId, objectId, filter, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityWorkspaceSettings(workspaceId, objectId, filter, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Dashboard
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAnalyticalDashboardPatchDocument} jsonApiAnalyticalDashboardPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityAnalyticalDashboards(workspaceId, objectId, jsonApiAnalyticalDashboardPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityAnalyticalDashboards(workspaceId, objectId, jsonApiAnalyticalDashboardPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAttributeHierarchyPatchDocument} jsonApiAttributeHierarchyPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityAttributeHierarchies(workspaceId, objectId, jsonApiAttributeHierarchyPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityAttributeHierarchies(workspaceId, objectId, jsonApiAttributeHierarchyPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiCustomApplicationSettingPatchDocument} jsonApiCustomApplicationSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityCustomApplicationSettings(workspaceId, objectId, jsonApiCustomApplicationSettingPatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityCustomApplicationSettings(workspaceId, objectId, jsonApiCustomApplicationSettingPatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiDashboardPluginPatchDocument} jsonApiDashboardPluginPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityDashboardPlugins(workspaceId, objectId, jsonApiDashboardPluginPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityDashboardPlugins(workspaceId, objectId, jsonApiDashboardPluginPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiFilterContextPatchDocument} jsonApiFilterContextPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityFilterContexts(workspaceId, objectId, jsonApiFilterContextPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityFilterContexts(workspaceId, objectId, jsonApiFilterContextPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiMetricPatchDocument} jsonApiMetricPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityMetrics(workspaceId, objectId, jsonApiMetricPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityMetrics(workspaceId, objectId, jsonApiMetricPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiUserDataFilterPatchDocument} jsonApiUserDataFilterPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityUserDataFilters(workspaceId, objectId, jsonApiUserDataFilterPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityUserDataFilters(workspaceId, objectId, jsonApiUserDataFilterPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiVisualizationObjectPatchDocument} jsonApiVisualizationObjectPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityVisualizationObjects(workspaceId, objectId, jsonApiVisualizationObjectPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityVisualizationObjects(workspaceId, objectId, jsonApiVisualizationObjectPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Settings for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterSettingPatchDocument} jsonApiWorkspaceDataFilterSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityWorkspaceDataFilterSettings(workspaceId, objectId, jsonApiWorkspaceDataFilterSettingPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityWorkspaceDataFilterSettings(workspaceId, objectId, jsonApiWorkspaceDataFilterSettingPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterPatchDocument} jsonApiWorkspaceDataFilterPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityWorkspaceDataFilters(workspaceId, objectId, jsonApiWorkspaceDataFilterPatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityWorkspaceDataFilters(workspaceId, objectId, jsonApiWorkspaceDataFilterPatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Setting for Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceSettingPatchDocument} jsonApiWorkspaceSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityWorkspaceSettings(workspaceId, objectId, jsonApiWorkspaceSettingPatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityWorkspaceSettings(workspaceId, objectId, jsonApiWorkspaceSettingPatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put Dashboards
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAnalyticalDashboardInDocument} jsonApiAnalyticalDashboardInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityAnalyticalDashboards(workspaceId, objectId, jsonApiAnalyticalDashboardInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityAnalyticalDashboards(workspaceId, objectId, jsonApiAnalyticalDashboardInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put an Attribute Hierarchy
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAttributeHierarchyInDocument} jsonApiAttributeHierarchyInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'attributes' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityAttributeHierarchies(workspaceId, objectId, jsonApiAttributeHierarchyInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityAttributeHierarchies(workspaceId, objectId, jsonApiAttributeHierarchyInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiCustomApplicationSettingInDocument} jsonApiCustomApplicationSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityCustomApplicationSettings(workspaceId, objectId, jsonApiCustomApplicationSettingInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityCustomApplicationSettings(workspaceId, objectId, jsonApiCustomApplicationSettingInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Plugin
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiDashboardPluginInDocument} jsonApiDashboardPluginInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityDashboardPlugins(workspaceId, objectId, jsonApiDashboardPluginInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityDashboardPlugins(workspaceId, objectId, jsonApiDashboardPluginInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Context Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiFilterContextInDocument} jsonApiFilterContextInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityFilterContexts(workspaceId, objectId, jsonApiFilterContextInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityFilterContexts(workspaceId, objectId, jsonApiFilterContextInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Metric
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiMetricInDocument} jsonApiMetricInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityMetrics(workspaceId, objectId, jsonApiMetricInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityMetrics(workspaceId, objectId, jsonApiMetricInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a User Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiUserDataFilterInDocument} jsonApiUserDataFilterInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'user' | 'userGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityUserDataFilters(workspaceId, objectId, jsonApiUserDataFilterInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityUserDataFilters(workspaceId, objectId, jsonApiUserDataFilterInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Visualization Object
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiVisualizationObjectInDocument} jsonApiVisualizationObjectInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userIdentifiers' | 'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'createdBy' | 'modifiedBy' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityVisualizationObjects(workspaceId, objectId, jsonApiVisualizationObjectInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityVisualizationObjects(workspaceId, objectId, jsonApiVisualizationObjectInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Settings for Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterSettingInDocument} jsonApiWorkspaceDataFilterSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityWorkspaceDataFilterSettings(workspaceId, objectId, jsonApiWorkspaceDataFilterSettingInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityWorkspaceDataFilterSettings(workspaceId, objectId, jsonApiWorkspaceDataFilterSettingInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Workspace Data Filter
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterInDocument} jsonApiWorkspaceDataFilterInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityWorkspaceDataFilters(workspaceId, objectId, jsonApiWorkspaceDataFilterInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityWorkspaceDataFilters(workspaceId, objectId, jsonApiWorkspaceDataFilterInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Setting for a Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceSettingInDocument} jsonApiWorkspaceSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityWorkspaceSettings(workspaceId, objectId, jsonApiWorkspaceSettingInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityWorkspaceSettings(workspaceId, objectId, jsonApiWorkspaceSettingInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * WorkspaceObjectControllerApi - factory interface
 * @export
 */
export const WorkspaceObjectControllerApiFactory = function (configuration, basePath, axios) {
    const localVarFp = WorkspaceObjectControllerApiFp(configuration);
    return {
        /**
         *
         * @summary Post Dashboards
         * @param {WorkspaceObjectControllerApiCreateEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityAnalyticalDashboards(requestParameters, options) {
            return localVarFp
                .createEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.jsonApiAnalyticalDashboardPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Attribute Hierarchies
         * @param {WorkspaceObjectControllerApiCreateEntityAttributeHierarchiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityAttributeHierarchies(requestParameters, options) {
            return localVarFp
                .createEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.jsonApiAttributeHierarchyInDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Custom Application Settings
         * @param {WorkspaceObjectControllerApiCreateEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityCustomApplicationSettings(requestParameters, options) {
            return localVarFp
                .createEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.jsonApiCustomApplicationSettingPostOptionalIdDocument, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Plugins
         * @param {WorkspaceObjectControllerApiCreateEntityDashboardPluginsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityDashboardPlugins(requestParameters, options) {
            return localVarFp
                .createEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.jsonApiDashboardPluginPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Context Filters
         * @param {WorkspaceObjectControllerApiCreateEntityFilterContextsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityFilterContexts(requestParameters, options) {
            return localVarFp
                .createEntityFilterContexts(requestParameters.workspaceId, requestParameters.jsonApiFilterContextPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Metrics
         * @param {WorkspaceObjectControllerApiCreateEntityMetricsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityMetrics(requestParameters, options) {
            return localVarFp
                .createEntityMetrics(requestParameters.workspaceId, requestParameters.jsonApiMetricPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post User Data Filters
         * @param {WorkspaceObjectControllerApiCreateEntityUserDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUserDataFilters(requestParameters, options) {
            return localVarFp
                .createEntityUserDataFilters(requestParameters.workspaceId, requestParameters.jsonApiUserDataFilterPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Visualization Objects
         * @param {WorkspaceObjectControllerApiCreateEntityVisualizationObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityVisualizationObjects(requestParameters, options) {
            return localVarFp
                .createEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.jsonApiVisualizationObjectPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Settings for Workspace Data Filters
         * @param {WorkspaceObjectControllerApiCreateEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaceDataFilterSettings(requestParameters, options) {
            return localVarFp
                .createEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.jsonApiWorkspaceDataFilterSettingInDocument, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Workspace Data Filters
         * @param {WorkspaceObjectControllerApiCreateEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaceDataFilters(requestParameters, options) {
            return localVarFp
                .createEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.jsonApiWorkspaceDataFilterInDocument, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Settings for Workspaces
         * @param {WorkspaceObjectControllerApiCreateEntityWorkspaceSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaceSettings(requestParameters, options) {
            return localVarFp
                .createEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.jsonApiWorkspaceSettingPostOptionalIdDocument, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Dashboard
         * @param {WorkspaceObjectControllerApiDeleteEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityAnalyticalDashboards(requestParameters, options) {
            return localVarFp
                .deleteEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete an Attribute Hierarchy
         * @param {WorkspaceObjectControllerApiDeleteEntityAttributeHierarchiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityAttributeHierarchies(requestParameters, options) {
            return localVarFp
                .deleteEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Custom Application Setting
         * @param {WorkspaceObjectControllerApiDeleteEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityCustomApplicationSettings(requestParameters, options) {
            return localVarFp
                .deleteEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Plugin
         * @param {WorkspaceObjectControllerApiDeleteEntityDashboardPluginsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityDashboardPlugins(requestParameters, options) {
            return localVarFp
                .deleteEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Context Filter
         * @param {WorkspaceObjectControllerApiDeleteEntityFilterContextsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityFilterContexts(requestParameters, options) {
            return localVarFp
                .deleteEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Metric
         * @param {WorkspaceObjectControllerApiDeleteEntityMetricsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityMetrics(requestParameters, options) {
            return localVarFp
                .deleteEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a User Data Filter
         * @param {WorkspaceObjectControllerApiDeleteEntityUserDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUserDataFilters(requestParameters, options) {
            return localVarFp
                .deleteEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Visualization Object
         * @param {WorkspaceObjectControllerApiDeleteEntityVisualizationObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityVisualizationObjects(requestParameters, options) {
            return localVarFp
                .deleteEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Settings for Workspace Data Filter
         * @param {WorkspaceObjectControllerApiDeleteEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaceDataFilterSettings(requestParameters, options) {
            return localVarFp
                .deleteEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Workspace Data Filter
         * @param {WorkspaceObjectControllerApiDeleteEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaceDataFilters(requestParameters, options) {
            return localVarFp
                .deleteEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Setting for Workspace
         * @param {WorkspaceObjectControllerApiDeleteEntityWorkspaceSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaceSettings(requestParameters, options) {
            return localVarFp
                .deleteEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Dashboards
         * @param {WorkspaceObjectControllerApiGetAllEntitiesAnalyticalDashboardsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAnalyticalDashboards(requestParameters, options) {
            return localVarFp
                .getAllEntitiesAnalyticalDashboards(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Attribute Hierarchies
         * @param {WorkspaceObjectControllerApiGetAllEntitiesAttributeHierarchiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAttributeHierarchies(requestParameters, options) {
            return localVarFp
                .getAllEntitiesAttributeHierarchies(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Attributes
         * @param {WorkspaceObjectControllerApiGetAllEntitiesAttributesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAttributes(requestParameters, options) {
            return localVarFp
                .getAllEntitiesAttributes(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Custom Application Settings
         * @param {WorkspaceObjectControllerApiGetAllEntitiesCustomApplicationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesCustomApplicationSettings(requestParameters, options) {
            return localVarFp
                .getAllEntitiesCustomApplicationSettings(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Plugins
         * @param {WorkspaceObjectControllerApiGetAllEntitiesDashboardPluginsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDashboardPlugins(requestParameters, options) {
            return localVarFp
                .getAllEntitiesDashboardPlugins(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Datasets
         * @param {WorkspaceObjectControllerApiGetAllEntitiesDatasetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDatasets(requestParameters, options) {
            return localVarFp
                .getAllEntitiesDatasets(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Facts
         * @param {WorkspaceObjectControllerApiGetAllEntitiesFactsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesFacts(requestParameters, options) {
            return localVarFp
                .getAllEntitiesFacts(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Context Filters
         * @param {WorkspaceObjectControllerApiGetAllEntitiesFilterContextsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesFilterContexts(requestParameters, options) {
            return localVarFp
                .getAllEntitiesFilterContexts(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Labels
         * @param {WorkspaceObjectControllerApiGetAllEntitiesLabelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesLabels(requestParameters, options) {
            return localVarFp
                .getAllEntitiesLabels(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Metrics
         * @param {WorkspaceObjectControllerApiGetAllEntitiesMetricsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesMetrics(requestParameters, options) {
            return localVarFp
                .getAllEntitiesMetrics(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all User Data Filters
         * @param {WorkspaceObjectControllerApiGetAllEntitiesUserDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserDataFilters(requestParameters, options) {
            return localVarFp
                .getAllEntitiesUserDataFilters(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Visualization Objects
         * @param {WorkspaceObjectControllerApiGetAllEntitiesVisualizationObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesVisualizationObjects(requestParameters, options) {
            return localVarFp
                .getAllEntitiesVisualizationObjects(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Settings for Workspace Data Filters
         * @param {WorkspaceObjectControllerApiGetAllEntitiesWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceDataFilterSettings(requestParameters, options) {
            return localVarFp
                .getAllEntitiesWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Workspace Data Filters
         * @param {WorkspaceObjectControllerApiGetAllEntitiesWorkspaceDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceDataFilters(requestParameters, options) {
            return localVarFp
                .getAllEntitiesWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Setting for Workspaces
         * @param {WorkspaceObjectControllerApiGetAllEntitiesWorkspaceSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceSettings(requestParameters, options) {
            return localVarFp
                .getAllEntitiesWorkspaceSettings(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Dashboard
         * @param {WorkspaceObjectControllerApiGetEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAnalyticalDashboards(requestParameters, options) {
            return localVarFp
                .getEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get an Attribute Hierarchy
         * @param {WorkspaceObjectControllerApiGetEntityAttributeHierarchiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAttributeHierarchies(requestParameters, options) {
            return localVarFp
                .getEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get an Attribute
         * @param {WorkspaceObjectControllerApiGetEntityAttributesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAttributes(requestParameters, options) {
            return localVarFp
                .getEntityAttributes(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Custom Application Setting
         * @param {WorkspaceObjectControllerApiGetEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityCustomApplicationSettings(requestParameters, options) {
            return localVarFp
                .getEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Plugin
         * @param {WorkspaceObjectControllerApiGetEntityDashboardPluginsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDashboardPlugins(requestParameters, options) {
            return localVarFp
                .getEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Dataset
         * @param {WorkspaceObjectControllerApiGetEntityDatasetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDatasets(requestParameters, options) {
            return localVarFp
                .getEntityDatasets(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Fact
         * @param {WorkspaceObjectControllerApiGetEntityFactsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityFacts(requestParameters, options) {
            return localVarFp
                .getEntityFacts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Context Filter
         * @param {WorkspaceObjectControllerApiGetEntityFilterContextsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityFilterContexts(requestParameters, options) {
            return localVarFp
                .getEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Label
         * @param {WorkspaceObjectControllerApiGetEntityLabelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityLabels(requestParameters, options) {
            return localVarFp
                .getEntityLabels(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Metric
         * @param {WorkspaceObjectControllerApiGetEntityMetricsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityMetrics(requestParameters, options) {
            return localVarFp
                .getEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a User Data Filter
         * @param {WorkspaceObjectControllerApiGetEntityUserDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserDataFilters(requestParameters, options) {
            return localVarFp
                .getEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Visualization Object
         * @param {WorkspaceObjectControllerApiGetEntityVisualizationObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityVisualizationObjects(requestParameters, options) {
            return localVarFp
                .getEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Setting for Workspace Data Filter
         * @param {WorkspaceObjectControllerApiGetEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceDataFilterSettings(requestParameters, options) {
            return localVarFp
                .getEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Workspace Data Filter
         * @param {WorkspaceObjectControllerApiGetEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceDataFilters(requestParameters, options) {
            return localVarFp
                .getEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Setting for Workspace
         * @param {WorkspaceObjectControllerApiGetEntityWorkspaceSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceSettings(requestParameters, options) {
            return localVarFp
                .getEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Dashboard
         * @param {WorkspaceObjectControllerApiPatchEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityAnalyticalDashboards(requestParameters, options) {
            return localVarFp
                .patchEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAnalyticalDashboardPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch an Attribute Hierarchy
         * @param {WorkspaceObjectControllerApiPatchEntityAttributeHierarchiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityAttributeHierarchies(requestParameters, options) {
            return localVarFp
                .patchEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAttributeHierarchyPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Custom Application Setting
         * @param {WorkspaceObjectControllerApiPatchEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityCustomApplicationSettings(requestParameters, options) {
            return localVarFp
                .patchEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiCustomApplicationSettingPatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Plugin
         * @param {WorkspaceObjectControllerApiPatchEntityDashboardPluginsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityDashboardPlugins(requestParameters, options) {
            return localVarFp
                .patchEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiDashboardPluginPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Context Filter
         * @param {WorkspaceObjectControllerApiPatchEntityFilterContextsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityFilterContexts(requestParameters, options) {
            return localVarFp
                .patchEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiFilterContextPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Metric
         * @param {WorkspaceObjectControllerApiPatchEntityMetricsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityMetrics(requestParameters, options) {
            return localVarFp
                .patchEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiMetricPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a User Data Filter
         * @param {WorkspaceObjectControllerApiPatchEntityUserDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUserDataFilters(requestParameters, options) {
            return localVarFp
                .patchEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiUserDataFilterPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Visualization Object
         * @param {WorkspaceObjectControllerApiPatchEntityVisualizationObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityVisualizationObjects(requestParameters, options) {
            return localVarFp
                .patchEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiVisualizationObjectPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Settings for Workspace Data Filter
         * @param {WorkspaceObjectControllerApiPatchEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaceDataFilterSettings(requestParameters, options) {
            return localVarFp
                .patchEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterSettingPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Workspace Data Filter
         * @param {WorkspaceObjectControllerApiPatchEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaceDataFilters(requestParameters, options) {
            return localVarFp
                .patchEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterPatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Setting for Workspace
         * @param {WorkspaceObjectControllerApiPatchEntityWorkspaceSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaceSettings(requestParameters, options) {
            return localVarFp
                .patchEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceSettingPatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put Dashboards
         * @param {WorkspaceObjectControllerApiUpdateEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityAnalyticalDashboards(requestParameters, options) {
            return localVarFp
                .updateEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAnalyticalDashboardInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put an Attribute Hierarchy
         * @param {WorkspaceObjectControllerApiUpdateEntityAttributeHierarchiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityAttributeHierarchies(requestParameters, options) {
            return localVarFp
                .updateEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAttributeHierarchyInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Custom Application Setting
         * @param {WorkspaceObjectControllerApiUpdateEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityCustomApplicationSettings(requestParameters, options) {
            return localVarFp
                .updateEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiCustomApplicationSettingInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Plugin
         * @param {WorkspaceObjectControllerApiUpdateEntityDashboardPluginsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityDashboardPlugins(requestParameters, options) {
            return localVarFp
                .updateEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiDashboardPluginInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Context Filter
         * @param {WorkspaceObjectControllerApiUpdateEntityFilterContextsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityFilterContexts(requestParameters, options) {
            return localVarFp
                .updateEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiFilterContextInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Metric
         * @param {WorkspaceObjectControllerApiUpdateEntityMetricsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityMetrics(requestParameters, options) {
            return localVarFp
                .updateEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiMetricInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a User Data Filter
         * @param {WorkspaceObjectControllerApiUpdateEntityUserDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUserDataFilters(requestParameters, options) {
            return localVarFp
                .updateEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiUserDataFilterInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Visualization Object
         * @param {WorkspaceObjectControllerApiUpdateEntityVisualizationObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityVisualizationObjects(requestParameters, options) {
            return localVarFp
                .updateEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiVisualizationObjectInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Settings for Workspace Data Filter
         * @param {WorkspaceObjectControllerApiUpdateEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaceDataFilterSettings(requestParameters, options) {
            return localVarFp
                .updateEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterSettingInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Workspace Data Filter
         * @param {WorkspaceObjectControllerApiUpdateEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaceDataFilters(requestParameters, options) {
            return localVarFp
                .updateEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Setting for a Workspace
         * @param {WorkspaceObjectControllerApiUpdateEntityWorkspaceSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaceSettings(requestParameters, options) {
            return localVarFp
                .updateEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceSettingInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * WorkspaceObjectControllerApi - object-oriented interface
 * @export
 * @class WorkspaceObjectControllerApi
 * @extends {BaseAPI}
 */
export class WorkspaceObjectControllerApi extends BaseAPI {
    /**
     *
     * @summary Post Dashboards
     * @param {WorkspaceObjectControllerApiCreateEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    createEntityAnalyticalDashboards(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .createEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.jsonApiAnalyticalDashboardPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Attribute Hierarchies
     * @param {WorkspaceObjectControllerApiCreateEntityAttributeHierarchiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    createEntityAttributeHierarchies(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .createEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.jsonApiAttributeHierarchyInDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Custom Application Settings
     * @param {WorkspaceObjectControllerApiCreateEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    createEntityCustomApplicationSettings(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .createEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.jsonApiCustomApplicationSettingPostOptionalIdDocument, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Plugins
     * @param {WorkspaceObjectControllerApiCreateEntityDashboardPluginsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    createEntityDashboardPlugins(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .createEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.jsonApiDashboardPluginPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Context Filters
     * @param {WorkspaceObjectControllerApiCreateEntityFilterContextsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    createEntityFilterContexts(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .createEntityFilterContexts(requestParameters.workspaceId, requestParameters.jsonApiFilterContextPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Metrics
     * @param {WorkspaceObjectControllerApiCreateEntityMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    createEntityMetrics(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .createEntityMetrics(requestParameters.workspaceId, requestParameters.jsonApiMetricPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post User Data Filters
     * @param {WorkspaceObjectControllerApiCreateEntityUserDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    createEntityUserDataFilters(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .createEntityUserDataFilters(requestParameters.workspaceId, requestParameters.jsonApiUserDataFilterPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Visualization Objects
     * @param {WorkspaceObjectControllerApiCreateEntityVisualizationObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    createEntityVisualizationObjects(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .createEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.jsonApiVisualizationObjectPostOptionalIdDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Settings for Workspace Data Filters
     * @param {WorkspaceObjectControllerApiCreateEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    createEntityWorkspaceDataFilterSettings(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .createEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.jsonApiWorkspaceDataFilterSettingInDocument, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Workspace Data Filters
     * @param {WorkspaceObjectControllerApiCreateEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    createEntityWorkspaceDataFilters(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .createEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.jsonApiWorkspaceDataFilterInDocument, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Settings for Workspaces
     * @param {WorkspaceObjectControllerApiCreateEntityWorkspaceSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    createEntityWorkspaceSettings(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .createEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.jsonApiWorkspaceSettingPostOptionalIdDocument, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Dashboard
     * @param {WorkspaceObjectControllerApiDeleteEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    deleteEntityAnalyticalDashboards(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .deleteEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete an Attribute Hierarchy
     * @param {WorkspaceObjectControllerApiDeleteEntityAttributeHierarchiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    deleteEntityAttributeHierarchies(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .deleteEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Custom Application Setting
     * @param {WorkspaceObjectControllerApiDeleteEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    deleteEntityCustomApplicationSettings(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .deleteEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Plugin
     * @param {WorkspaceObjectControllerApiDeleteEntityDashboardPluginsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    deleteEntityDashboardPlugins(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .deleteEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Context Filter
     * @param {WorkspaceObjectControllerApiDeleteEntityFilterContextsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    deleteEntityFilterContexts(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .deleteEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Metric
     * @param {WorkspaceObjectControllerApiDeleteEntityMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    deleteEntityMetrics(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .deleteEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a User Data Filter
     * @param {WorkspaceObjectControllerApiDeleteEntityUserDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    deleteEntityUserDataFilters(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .deleteEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Visualization Object
     * @param {WorkspaceObjectControllerApiDeleteEntityVisualizationObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    deleteEntityVisualizationObjects(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .deleteEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Settings for Workspace Data Filter
     * @param {WorkspaceObjectControllerApiDeleteEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    deleteEntityWorkspaceDataFilterSettings(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .deleteEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Workspace Data Filter
     * @param {WorkspaceObjectControllerApiDeleteEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    deleteEntityWorkspaceDataFilters(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .deleteEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Setting for Workspace
     * @param {WorkspaceObjectControllerApiDeleteEntityWorkspaceSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    deleteEntityWorkspaceSettings(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .deleteEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Dashboards
     * @param {WorkspaceObjectControllerApiGetAllEntitiesAnalyticalDashboardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getAllEntitiesAnalyticalDashboards(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getAllEntitiesAnalyticalDashboards(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Attribute Hierarchies
     * @param {WorkspaceObjectControllerApiGetAllEntitiesAttributeHierarchiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getAllEntitiesAttributeHierarchies(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getAllEntitiesAttributeHierarchies(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Attributes
     * @param {WorkspaceObjectControllerApiGetAllEntitiesAttributesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getAllEntitiesAttributes(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getAllEntitiesAttributes(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Custom Application Settings
     * @param {WorkspaceObjectControllerApiGetAllEntitiesCustomApplicationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getAllEntitiesCustomApplicationSettings(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getAllEntitiesCustomApplicationSettings(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Plugins
     * @param {WorkspaceObjectControllerApiGetAllEntitiesDashboardPluginsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getAllEntitiesDashboardPlugins(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getAllEntitiesDashboardPlugins(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Datasets
     * @param {WorkspaceObjectControllerApiGetAllEntitiesDatasetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getAllEntitiesDatasets(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getAllEntitiesDatasets(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Facts
     * @param {WorkspaceObjectControllerApiGetAllEntitiesFactsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getAllEntitiesFacts(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getAllEntitiesFacts(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Context Filters
     * @param {WorkspaceObjectControllerApiGetAllEntitiesFilterContextsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getAllEntitiesFilterContexts(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getAllEntitiesFilterContexts(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Labels
     * @param {WorkspaceObjectControllerApiGetAllEntitiesLabelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getAllEntitiesLabels(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getAllEntitiesLabels(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Metrics
     * @param {WorkspaceObjectControllerApiGetAllEntitiesMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getAllEntitiesMetrics(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getAllEntitiesMetrics(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all User Data Filters
     * @param {WorkspaceObjectControllerApiGetAllEntitiesUserDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getAllEntitiesUserDataFilters(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getAllEntitiesUserDataFilters(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Visualization Objects
     * @param {WorkspaceObjectControllerApiGetAllEntitiesVisualizationObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getAllEntitiesVisualizationObjects(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getAllEntitiesVisualizationObjects(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Settings for Workspace Data Filters
     * @param {WorkspaceObjectControllerApiGetAllEntitiesWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getAllEntitiesWorkspaceDataFilterSettings(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getAllEntitiesWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Workspace Data Filters
     * @param {WorkspaceObjectControllerApiGetAllEntitiesWorkspaceDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getAllEntitiesWorkspaceDataFilters(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getAllEntitiesWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Setting for Workspaces
     * @param {WorkspaceObjectControllerApiGetAllEntitiesWorkspaceSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getAllEntitiesWorkspaceSettings(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getAllEntitiesWorkspaceSettings(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Dashboard
     * @param {WorkspaceObjectControllerApiGetEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getEntityAnalyticalDashboards(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get an Attribute Hierarchy
     * @param {WorkspaceObjectControllerApiGetEntityAttributeHierarchiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getEntityAttributeHierarchies(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get an Attribute
     * @param {WorkspaceObjectControllerApiGetEntityAttributesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getEntityAttributes(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getEntityAttributes(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Custom Application Setting
     * @param {WorkspaceObjectControllerApiGetEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getEntityCustomApplicationSettings(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Plugin
     * @param {WorkspaceObjectControllerApiGetEntityDashboardPluginsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getEntityDashboardPlugins(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Dataset
     * @param {WorkspaceObjectControllerApiGetEntityDatasetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getEntityDatasets(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getEntityDatasets(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Fact
     * @param {WorkspaceObjectControllerApiGetEntityFactsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getEntityFacts(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getEntityFacts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Context Filter
     * @param {WorkspaceObjectControllerApiGetEntityFilterContextsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getEntityFilterContexts(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Label
     * @param {WorkspaceObjectControllerApiGetEntityLabelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getEntityLabels(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getEntityLabels(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Metric
     * @param {WorkspaceObjectControllerApiGetEntityMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getEntityMetrics(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a User Data Filter
     * @param {WorkspaceObjectControllerApiGetEntityUserDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getEntityUserDataFilters(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Visualization Object
     * @param {WorkspaceObjectControllerApiGetEntityVisualizationObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getEntityVisualizationObjects(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Setting for Workspace Data Filter
     * @param {WorkspaceObjectControllerApiGetEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getEntityWorkspaceDataFilterSettings(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Workspace Data Filter
     * @param {WorkspaceObjectControllerApiGetEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getEntityWorkspaceDataFilters(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.include, requestParameters.xGDCVALIDATERELATIONS, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Setting for Workspace
     * @param {WorkspaceObjectControllerApiGetEntityWorkspaceSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    getEntityWorkspaceSettings(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .getEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Dashboard
     * @param {WorkspaceObjectControllerApiPatchEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    patchEntityAnalyticalDashboards(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .patchEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAnalyticalDashboardPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch an Attribute Hierarchy
     * @param {WorkspaceObjectControllerApiPatchEntityAttributeHierarchiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    patchEntityAttributeHierarchies(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .patchEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAttributeHierarchyPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Custom Application Setting
     * @param {WorkspaceObjectControllerApiPatchEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    patchEntityCustomApplicationSettings(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .patchEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiCustomApplicationSettingPatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Plugin
     * @param {WorkspaceObjectControllerApiPatchEntityDashboardPluginsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    patchEntityDashboardPlugins(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .patchEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiDashboardPluginPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Context Filter
     * @param {WorkspaceObjectControllerApiPatchEntityFilterContextsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    patchEntityFilterContexts(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .patchEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiFilterContextPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Metric
     * @param {WorkspaceObjectControllerApiPatchEntityMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    patchEntityMetrics(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .patchEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiMetricPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a User Data Filter
     * @param {WorkspaceObjectControllerApiPatchEntityUserDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    patchEntityUserDataFilters(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .patchEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiUserDataFilterPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Visualization Object
     * @param {WorkspaceObjectControllerApiPatchEntityVisualizationObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    patchEntityVisualizationObjects(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .patchEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiVisualizationObjectPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Settings for Workspace Data Filter
     * @param {WorkspaceObjectControllerApiPatchEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    patchEntityWorkspaceDataFilterSettings(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .patchEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterSettingPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Workspace Data Filter
     * @param {WorkspaceObjectControllerApiPatchEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    patchEntityWorkspaceDataFilters(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .patchEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterPatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Setting for Workspace
     * @param {WorkspaceObjectControllerApiPatchEntityWorkspaceSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    patchEntityWorkspaceSettings(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .patchEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceSettingPatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put Dashboards
     * @param {WorkspaceObjectControllerApiUpdateEntityAnalyticalDashboardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    updateEntityAnalyticalDashboards(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .updateEntityAnalyticalDashboards(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAnalyticalDashboardInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put an Attribute Hierarchy
     * @param {WorkspaceObjectControllerApiUpdateEntityAttributeHierarchiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    updateEntityAttributeHierarchies(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .updateEntityAttributeHierarchies(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiAttributeHierarchyInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Custom Application Setting
     * @param {WorkspaceObjectControllerApiUpdateEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    updateEntityCustomApplicationSettings(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .updateEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiCustomApplicationSettingInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Plugin
     * @param {WorkspaceObjectControllerApiUpdateEntityDashboardPluginsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    updateEntityDashboardPlugins(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .updateEntityDashboardPlugins(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiDashboardPluginInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Context Filter
     * @param {WorkspaceObjectControllerApiUpdateEntityFilterContextsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    updateEntityFilterContexts(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .updateEntityFilterContexts(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiFilterContextInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Metric
     * @param {WorkspaceObjectControllerApiUpdateEntityMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    updateEntityMetrics(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .updateEntityMetrics(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiMetricInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a User Data Filter
     * @param {WorkspaceObjectControllerApiUpdateEntityUserDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    updateEntityUserDataFilters(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .updateEntityUserDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiUserDataFilterInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Visualization Object
     * @param {WorkspaceObjectControllerApiUpdateEntityVisualizationObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    updateEntityVisualizationObjects(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .updateEntityVisualizationObjects(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiVisualizationObjectInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Settings for Workspace Data Filter
     * @param {WorkspaceObjectControllerApiUpdateEntityWorkspaceDataFilterSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    updateEntityWorkspaceDataFilterSettings(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .updateEntityWorkspaceDataFilterSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterSettingInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Workspace Data Filter
     * @param {WorkspaceObjectControllerApiUpdateEntityWorkspaceDataFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    updateEntityWorkspaceDataFilters(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .updateEntityWorkspaceDataFilters(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceDataFilterInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Setting for a Workspace
     * @param {WorkspaceObjectControllerApiUpdateEntityWorkspaceSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceObjectControllerApi
     */
    updateEntityWorkspaceSettings(requestParameters, options) {
        return WorkspaceObjectControllerApiFp(this.configuration)
            .updateEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceSettingInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * WorkspacesDeclarativeAPIsApi - axios parameter creator
 * @export
 */
export const WorkspacesDeclarativeAPIsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve current model of the workspace in declarative form.
         * @summary Get workspace layout
         * @param {string} workspaceId
         * @param {Array<'ACTIVITY_INFO'>} [exclude]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceLayout: async (workspaceId, exclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getWorkspaceLayout", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/layout/workspaces/{workspaceId}`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (exclude) {
                localVarQueryParameter["exclude"] = exclude;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets complete layout of workspaces, their hierarchy, models.
         * @summary Get all workspaces layout
         * @param {Array<'ACTIVITY_INFO'>} [exclude]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspacesLayout: async (exclude, options = {}) => {
            const localVarPath = `/api/v1/layout/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (exclude) {
                localVarQueryParameter["exclude"] = exclude;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set complete layout of workspace, like model, authorization, etc.
         * @summary Set workspace layout
         * @param {string} workspaceId
         * @param {DeclarativeWorkspaceModel} declarativeWorkspaceModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWorkspaceLayout: async (workspaceId, declarativeWorkspaceModel, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("putWorkspaceLayout", "workspaceId", workspaceId);
            // verify required parameter 'declarativeWorkspaceModel' is not null or undefined
            assertParamExists("putWorkspaceLayout", "declarativeWorkspaceModel", declarativeWorkspaceModel);
            const localVarPath = `/api/v1/layout/workspaces/{workspaceId}`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeWorkspaceModel !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeWorkspaceModel !== undefined ? declarativeWorkspaceModel : {})
                : declarativeWorkspaceModel || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets complete layout of workspaces, their hierarchy, models.
         * @summary Set all workspaces layout
         * @param {DeclarativeWorkspaces} declarativeWorkspaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspacesLayout: async (declarativeWorkspaces, options = {}) => {
            // verify required parameter 'declarativeWorkspaces' is not null or undefined
            assertParamExists("setWorkspacesLayout", "declarativeWorkspaces", declarativeWorkspaces);
            const localVarPath = `/api/v1/layout/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof declarativeWorkspaces !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeWorkspaces !== undefined ? declarativeWorkspaces : {})
                : declarativeWorkspaces || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * WorkspacesDeclarativeAPIsApi - functional programming interface
 * @export
 */
export const WorkspacesDeclarativeAPIsApiFp = function (configuration) {
    const localVarAxiosParamCreator = WorkspacesDeclarativeAPIsApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieve current model of the workspace in declarative form.
         * @summary Get workspace layout
         * @param {string} workspaceId
         * @param {Array<'ACTIVITY_INFO'>} [exclude]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceLayout(workspaceId, exclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceLayout(workspaceId, exclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets complete layout of workspaces, their hierarchy, models.
         * @summary Get all workspaces layout
         * @param {Array<'ACTIVITY_INFO'>} [exclude]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspacesLayout(exclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspacesLayout(exclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set complete layout of workspace, like model, authorization, etc.
         * @summary Set workspace layout
         * @param {string} workspaceId
         * @param {DeclarativeWorkspaceModel} declarativeWorkspaceModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putWorkspaceLayout(workspaceId, declarativeWorkspaceModel, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putWorkspaceLayout(workspaceId, declarativeWorkspaceModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets complete layout of workspaces, their hierarchy, models.
         * @summary Set all workspaces layout
         * @param {DeclarativeWorkspaces} declarativeWorkspaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setWorkspacesLayout(declarativeWorkspaces, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setWorkspacesLayout(declarativeWorkspaces, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * WorkspacesDeclarativeAPIsApi - factory interface
 * @export
 */
export const WorkspacesDeclarativeAPIsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = WorkspacesDeclarativeAPIsApiFp(configuration);
    return {
        /**
         * Retrieve current model of the workspace in declarative form.
         * @summary Get workspace layout
         * @param {WorkspacesDeclarativeAPIsApiGetWorkspaceLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceLayout(requestParameters, options) {
            return localVarFp
                .getWorkspaceLayout(requestParameters.workspaceId, requestParameters.exclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Gets complete layout of workspaces, their hierarchy, models.
         * @summary Get all workspaces layout
         * @param {WorkspacesDeclarativeAPIsApiGetWorkspacesLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspacesLayout(requestParameters, options) {
            return localVarFp
                .getWorkspacesLayout(requestParameters.exclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Set complete layout of workspace, like model, authorization, etc.
         * @summary Set workspace layout
         * @param {WorkspacesDeclarativeAPIsApiPutWorkspaceLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWorkspaceLayout(requestParameters, options) {
            return localVarFp
                .putWorkspaceLayout(requestParameters.workspaceId, requestParameters.declarativeWorkspaceModel, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Sets complete layout of workspaces, their hierarchy, models.
         * @summary Set all workspaces layout
         * @param {WorkspacesDeclarativeAPIsApiSetWorkspacesLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspacesLayout(requestParameters, options) {
            return localVarFp
                .setWorkspacesLayout(requestParameters.declarativeWorkspaces, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * WorkspacesDeclarativeAPIsApi - object-oriented interface
 * @export
 * @class WorkspacesDeclarativeAPIsApi
 * @extends {BaseAPI}
 */
export class WorkspacesDeclarativeAPIsApi extends BaseAPI {
    /**
     * Retrieve current model of the workspace in declarative form.
     * @summary Get workspace layout
     * @param {WorkspacesDeclarativeAPIsApiGetWorkspaceLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesDeclarativeAPIsApi
     */
    getWorkspaceLayout(requestParameters, options) {
        return WorkspacesDeclarativeAPIsApiFp(this.configuration)
            .getWorkspaceLayout(requestParameters.workspaceId, requestParameters.exclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets complete layout of workspaces, their hierarchy, models.
     * @summary Get all workspaces layout
     * @param {WorkspacesDeclarativeAPIsApiGetWorkspacesLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesDeclarativeAPIsApi
     */
    getWorkspacesLayout(requestParameters = {}, options) {
        return WorkspacesDeclarativeAPIsApiFp(this.configuration)
            .getWorkspacesLayout(requestParameters.exclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Set complete layout of workspace, like model, authorization, etc.
     * @summary Set workspace layout
     * @param {WorkspacesDeclarativeAPIsApiPutWorkspaceLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesDeclarativeAPIsApi
     */
    putWorkspaceLayout(requestParameters, options) {
        return WorkspacesDeclarativeAPIsApiFp(this.configuration)
            .putWorkspaceLayout(requestParameters.workspaceId, requestParameters.declarativeWorkspaceModel, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets complete layout of workspaces, their hierarchy, models.
     * @summary Set all workspaces layout
     * @param {WorkspacesDeclarativeAPIsApiSetWorkspacesLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesDeclarativeAPIsApi
     */
    setWorkspacesLayout(requestParameters, options) {
        return WorkspacesDeclarativeAPIsApiFp(this.configuration)
            .setWorkspacesLayout(requestParameters.declarativeWorkspaces, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * WorkspacesEntityAPIsApi - axios parameter creator
 * @export
 */
export const WorkspacesEntityAPIsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Space of the shared interest
         * @summary Post Workspace entities
         * @param {JsonApiWorkspaceInDocument} jsonApiWorkspaceInDocument
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaces: async (jsonApiWorkspaceInDocument, include, metaInclude, options = {}) => {
            // verify required parameter 'jsonApiWorkspaceInDocument' is not null or undefined
            assertParamExists("createEntityWorkspaces", "jsonApiWorkspaceInDocument", jsonApiWorkspaceInDocument);
            const localVarPath = `/api/v1/entities/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceInDocument !== undefined ? jsonApiWorkspaceInDocument : {})
                : jsonApiWorkspaceInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Space of the shared interest
         * @summary Delete Workspace entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaces: async (id, filter, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityWorkspaces", "id", id);
            const localVarPath = `/api/v1/entities/workspaces/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Space of the shared interest
         * @summary Get Workspace entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaces: async (filter, include, page, size, sort, metaInclude, options = {}) => {
            const localVarPath = `/api/v1/entities/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Space of the shared interest
         * @summary Get Workspace entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaces: async (id, filter, include, metaInclude, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityWorkspaces", "id", id);
            const localVarPath = `/api/v1/entities/workspaces/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Space of the shared interest
         * @summary Patch Workspace entity
         * @param {string} id
         * @param {JsonApiWorkspacePatchDocument} jsonApiWorkspacePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaces: async (id, jsonApiWorkspacePatchDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityWorkspaces", "id", id);
            // verify required parameter 'jsonApiWorkspacePatchDocument' is not null or undefined
            assertParamExists("patchEntityWorkspaces", "jsonApiWorkspacePatchDocument", jsonApiWorkspacePatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspacePatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspacePatchDocument !== undefined ? jsonApiWorkspacePatchDocument : {})
                : jsonApiWorkspacePatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Space of the shared interest
         * @summary Put Workspace entity
         * @param {string} id
         * @param {JsonApiWorkspaceInDocument} jsonApiWorkspaceInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaces: async (id, jsonApiWorkspaceInDocument, filter, include, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityWorkspaces", "id", id);
            // verify required parameter 'jsonApiWorkspaceInDocument' is not null or undefined
            assertParamExists("updateEntityWorkspaces", "jsonApiWorkspaceInDocument", jsonApiWorkspaceInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceInDocument !== undefined ? jsonApiWorkspaceInDocument : {})
                : jsonApiWorkspaceInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * WorkspacesEntityAPIsApi - functional programming interface
 * @export
 */
export const WorkspacesEntityAPIsApiFp = function (configuration) {
    const localVarAxiosParamCreator = WorkspacesEntityAPIsApiAxiosParamCreator(configuration);
    return {
        /**
         * Space of the shared interest
         * @summary Post Workspace entities
         * @param {JsonApiWorkspaceInDocument} jsonApiWorkspaceInDocument
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityWorkspaces(jsonApiWorkspaceInDocument, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityWorkspaces(jsonApiWorkspaceInDocument, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Space of the shared interest
         * @summary Delete Workspace entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityWorkspaces(id, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityWorkspaces(id, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Space of the shared interest
         * @summary Get Workspace entities
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesWorkspaces(filter, include, page, size, sort, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesWorkspaces(filter, include, page, size, sort, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Space of the shared interest
         * @summary Get Workspace entity
         * @param {string} id
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityWorkspaces(id, filter, include, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityWorkspaces(id, filter, include, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Space of the shared interest
         * @summary Patch Workspace entity
         * @param {string} id
         * @param {JsonApiWorkspacePatchDocument} jsonApiWorkspacePatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityWorkspaces(id, jsonApiWorkspacePatchDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityWorkspaces(id, jsonApiWorkspacePatchDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Space of the shared interest
         * @summary Put Workspace entity
         * @param {string} id
         * @param {JsonApiWorkspaceInDocument} jsonApiWorkspaceInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityWorkspaces(id, jsonApiWorkspaceInDocument, filter, include, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityWorkspaces(id, jsonApiWorkspaceInDocument, filter, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * WorkspacesEntityAPIsApi - factory interface
 * @export
 */
export const WorkspacesEntityAPIsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = WorkspacesEntityAPIsApiFp(configuration);
    return {
        /**
         * Space of the shared interest
         * @summary Post Workspace entities
         * @param {WorkspacesEntityAPIsApiCreateEntityWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaces(requestParameters, options) {
            return localVarFp
                .createEntityWorkspaces(requestParameters.jsonApiWorkspaceInDocument, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Space of the shared interest
         * @summary Delete Workspace entity
         * @param {WorkspacesEntityAPIsApiDeleteEntityWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaces(requestParameters, options) {
            return localVarFp
                .deleteEntityWorkspaces(requestParameters.id, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Space of the shared interest
         * @summary Get Workspace entities
         * @param {WorkspacesEntityAPIsApiGetAllEntitiesWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaces(requestParameters, options) {
            return localVarFp
                .getAllEntitiesWorkspaces(requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Space of the shared interest
         * @summary Get Workspace entity
         * @param {WorkspacesEntityAPIsApiGetEntityWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaces(requestParameters, options) {
            return localVarFp
                .getEntityWorkspaces(requestParameters.id, requestParameters.filter, requestParameters.include, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Space of the shared interest
         * @summary Patch Workspace entity
         * @param {WorkspacesEntityAPIsApiPatchEntityWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaces(requestParameters, options) {
            return localVarFp
                .patchEntityWorkspaces(requestParameters.id, requestParameters.jsonApiWorkspacePatchDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Space of the shared interest
         * @summary Put Workspace entity
         * @param {WorkspacesEntityAPIsApiUpdateEntityWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaces(requestParameters, options) {
            return localVarFp
                .updateEntityWorkspaces(requestParameters.id, requestParameters.jsonApiWorkspaceInDocument, requestParameters.filter, requestParameters.include, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * WorkspacesEntityAPIsApi - object-oriented interface
 * @export
 * @class WorkspacesEntityAPIsApi
 * @extends {BaseAPI}
 */
export class WorkspacesEntityAPIsApi extends BaseAPI {
    /**
     * Space of the shared interest
     * @summary Post Workspace entities
     * @param {WorkspacesEntityAPIsApiCreateEntityWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesEntityAPIsApi
     */
    createEntityWorkspaces(requestParameters, options) {
        return WorkspacesEntityAPIsApiFp(this.configuration)
            .createEntityWorkspaces(requestParameters.jsonApiWorkspaceInDocument, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Space of the shared interest
     * @summary Delete Workspace entity
     * @param {WorkspacesEntityAPIsApiDeleteEntityWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesEntityAPIsApi
     */
    deleteEntityWorkspaces(requestParameters, options) {
        return WorkspacesEntityAPIsApiFp(this.configuration)
            .deleteEntityWorkspaces(requestParameters.id, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Space of the shared interest
     * @summary Get Workspace entities
     * @param {WorkspacesEntityAPIsApiGetAllEntitiesWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesEntityAPIsApi
     */
    getAllEntitiesWorkspaces(requestParameters = {}, options) {
        return WorkspacesEntityAPIsApiFp(this.configuration)
            .getAllEntitiesWorkspaces(requestParameters.filter, requestParameters.include, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Space of the shared interest
     * @summary Get Workspace entity
     * @param {WorkspacesEntityAPIsApiGetEntityWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesEntityAPIsApi
     */
    getEntityWorkspaces(requestParameters, options) {
        return WorkspacesEntityAPIsApiFp(this.configuration)
            .getEntityWorkspaces(requestParameters.id, requestParameters.filter, requestParameters.include, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Space of the shared interest
     * @summary Patch Workspace entity
     * @param {WorkspacesEntityAPIsApiPatchEntityWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesEntityAPIsApi
     */
    patchEntityWorkspaces(requestParameters, options) {
        return WorkspacesEntityAPIsApiFp(this.configuration)
            .patchEntityWorkspaces(requestParameters.id, requestParameters.jsonApiWorkspacePatchDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Space of the shared interest
     * @summary Put Workspace entity
     * @param {WorkspacesEntityAPIsApiUpdateEntityWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesEntityAPIsApi
     */
    updateEntityWorkspaces(requestParameters, options) {
        return WorkspacesEntityAPIsApiFp(this.configuration)
            .updateEntityWorkspaces(requestParameters.id, requestParameters.jsonApiWorkspaceInDocument, requestParameters.filter, requestParameters.include, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * WorkspacesSettingsApi - axios parameter creator
 * @export
 */
export const WorkspacesSettingsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Post Custom Application Settings
         * @param {string} workspaceId
         * @param {JsonApiCustomApplicationSettingPostOptionalIdDocument} jsonApiCustomApplicationSettingPostOptionalIdDocument
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityCustomApplicationSettings: async (workspaceId, jsonApiCustomApplicationSettingPostOptionalIdDocument, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityCustomApplicationSettings", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiCustomApplicationSettingPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityCustomApplicationSettings", "jsonApiCustomApplicationSettingPostOptionalIdDocument", jsonApiCustomApplicationSettingPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/customApplicationSettings`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCustomApplicationSettingPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCustomApplicationSettingPostOptionalIdDocument !== undefined
                    ? jsonApiCustomApplicationSettingPostOptionalIdDocument
                    : {})
                : jsonApiCustomApplicationSettingPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post Settings for Workspaces
         * @param {string} workspaceId
         * @param {JsonApiWorkspaceSettingPostOptionalIdDocument} jsonApiWorkspaceSettingPostOptionalIdDocument
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaceSettings: async (workspaceId, jsonApiWorkspaceSettingPostOptionalIdDocument, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityWorkspaceSettings", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiWorkspaceSettingPostOptionalIdDocument' is not null or undefined
            assertParamExists("createEntityWorkspaceSettings", "jsonApiWorkspaceSettingPostOptionalIdDocument", jsonApiWorkspaceSettingPostOptionalIdDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceSettings`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceSettingPostOptionalIdDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceSettingPostOptionalIdDocument !== undefined
                    ? jsonApiWorkspaceSettingPostOptionalIdDocument
                    : {})
                : jsonApiWorkspaceSettingPostOptionalIdDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityCustomApplicationSettings: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityCustomApplicationSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityCustomApplicationSettings", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/customApplicationSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Setting for Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaceSettings: async (workspaceId, objectId, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityWorkspaceSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityWorkspaceSettings", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Custom Application Settings
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesCustomApplicationSettings: async (workspaceId, origin, filter, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesCustomApplicationSettings", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/customApplicationSettings`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Setting for Workspaces
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceSettings: async (workspaceId, origin, filter, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesWorkspaceSettings", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceSettings`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin !== undefined) {
                localVarQueryParameter["origin"] = origin;
            }
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }
            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityCustomApplicationSettings: async (workspaceId, objectId, filter, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityCustomApplicationSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityCustomApplicationSettings", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/customApplicationSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Setting for Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceSettings: async (workspaceId, objectId, filter, xGDCVALIDATERELATIONS, metaInclude, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityWorkspaceSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityWorkspaceSettings", "objectId", objectId);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude).join(COLLECTION_FORMATS.csv);
            }
            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(JSON.stringify(xGDCVALIDATERELATIONS));
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiCustomApplicationSettingPatchDocument} jsonApiCustomApplicationSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityCustomApplicationSettings: async (workspaceId, objectId, jsonApiCustomApplicationSettingPatchDocument, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityCustomApplicationSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityCustomApplicationSettings", "objectId", objectId);
            // verify required parameter 'jsonApiCustomApplicationSettingPatchDocument' is not null or undefined
            assertParamExists("patchEntityCustomApplicationSettings", "jsonApiCustomApplicationSettingPatchDocument", jsonApiCustomApplicationSettingPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/customApplicationSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCustomApplicationSettingPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCustomApplicationSettingPatchDocument !== undefined
                    ? jsonApiCustomApplicationSettingPatchDocument
                    : {})
                : jsonApiCustomApplicationSettingPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a Setting for Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceSettingPatchDocument} jsonApiWorkspaceSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaceSettings: async (workspaceId, objectId, jsonApiWorkspaceSettingPatchDocument, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityWorkspaceSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityWorkspaceSettings", "objectId", objectId);
            // verify required parameter 'jsonApiWorkspaceSettingPatchDocument' is not null or undefined
            assertParamExists("patchEntityWorkspaceSettings", "jsonApiWorkspaceSettingPatchDocument", jsonApiWorkspaceSettingPatchDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PATCH" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceSettingPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceSettingPatchDocument !== undefined
                    ? jsonApiWorkspaceSettingPatchDocument
                    : {})
                : jsonApiWorkspaceSettingPatchDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiCustomApplicationSettingInDocument} jsonApiCustomApplicationSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityCustomApplicationSettings: async (workspaceId, objectId, jsonApiCustomApplicationSettingInDocument, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityCustomApplicationSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityCustomApplicationSettings", "objectId", objectId);
            // verify required parameter 'jsonApiCustomApplicationSettingInDocument' is not null or undefined
            assertParamExists("updateEntityCustomApplicationSettings", "jsonApiCustomApplicationSettingInDocument", jsonApiCustomApplicationSettingInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/customApplicationSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiCustomApplicationSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiCustomApplicationSettingInDocument !== undefined
                    ? jsonApiCustomApplicationSettingInDocument
                    : {})
                : jsonApiCustomApplicationSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Put a Setting for a Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceSettingInDocument} jsonApiWorkspaceSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaceSettings: async (workspaceId, objectId, jsonApiWorkspaceSettingInDocument, filter, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityWorkspaceSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityWorkspaceSettings", "objectId", objectId);
            // verify required parameter 'jsonApiWorkspaceSettingInDocument' is not null or undefined
            assertParamExists("updateEntityWorkspaceSettings", "jsonApiWorkspaceSettingInDocument", jsonApiWorkspaceSettingInDocument);
            const localVarPath = `/api/v1/entities/workspaces/{workspaceId}/workspaceSettings/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filter !== undefined) {
                localVarQueryParameter["filter"] = filter;
            }
            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof jsonApiWorkspaceSettingInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceSettingInDocument !== undefined
                    ? jsonApiWorkspaceSettingInDocument
                    : {})
                : jsonApiWorkspaceSettingInDocument || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolves values for all settings in a workspace by current user, workspace, organization, or default settings.
         * @summary Values for all settings.
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceResolveAllSettings: async (workspaceId, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("workspaceResolveAllSettings", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/resolveSettings`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolves value for selected settings in a workspace by current user, workspace, organization, or default settings.
         * @summary Values for selected settings.
         * @param {string} workspaceId
         * @param {ResolveSettingsRequest} resolveSettingsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceResolveSettings: async (workspaceId, resolveSettingsRequest, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("workspaceResolveSettings", "workspaceId", workspaceId);
            // verify required parameter 'resolveSettingsRequest' is not null or undefined
            assertParamExists("workspaceResolveSettings", "resolveSettingsRequest", resolveSettingsRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/resolveSettings`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof resolveSettingsRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(resolveSettingsRequest !== undefined ? resolveSettingsRequest : {})
                : resolveSettingsRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * WorkspacesSettingsApi - functional programming interface
 * @export
 */
export const WorkspacesSettingsApiFp = function (configuration) {
    const localVarAxiosParamCreator = WorkspacesSettingsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Post Custom Application Settings
         * @param {string} workspaceId
         * @param {JsonApiCustomApplicationSettingPostOptionalIdDocument} jsonApiCustomApplicationSettingPostOptionalIdDocument
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityCustomApplicationSettings(workspaceId, jsonApiCustomApplicationSettingPostOptionalIdDocument, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityCustomApplicationSettings(workspaceId, jsonApiCustomApplicationSettingPostOptionalIdDocument, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Post Settings for Workspaces
         * @param {string} workspaceId
         * @param {JsonApiWorkspaceSettingPostOptionalIdDocument} jsonApiWorkspaceSettingPostOptionalIdDocument
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityWorkspaceSettings(workspaceId, jsonApiWorkspaceSettingPostOptionalIdDocument, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityWorkspaceSettings(workspaceId, jsonApiWorkspaceSettingPostOptionalIdDocument, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityCustomApplicationSettings(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityCustomApplicationSettings(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a Setting for Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntityWorkspaceSettings(workspaceId, objectId, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntityWorkspaceSettings(workspaceId, objectId, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Custom Application Settings
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesCustomApplicationSettings(workspaceId, origin, filter, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesCustomApplicationSettings(workspaceId, origin, filter, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all Setting for Workspaces
         * @param {string} workspaceId
         * @param {'ALL' | 'PARENTS' | 'NATIVE'} [origin]
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEntitiesWorkspaceSettings(workspaceId, origin, filter, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEntitiesWorkspaceSettings(workspaceId, origin, filter, page, size, sort, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityCustomApplicationSettings(workspaceId, objectId, filter, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityCustomApplicationSettings(workspaceId, objectId, filter, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Setting for Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {Array<'origin' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntityWorkspaceSettings(workspaceId, objectId, filter, xGDCVALIDATERELATIONS, metaInclude, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntityWorkspaceSettings(workspaceId, objectId, filter, xGDCVALIDATERELATIONS, metaInclude, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiCustomApplicationSettingPatchDocument} jsonApiCustomApplicationSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityCustomApplicationSettings(workspaceId, objectId, jsonApiCustomApplicationSettingPatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityCustomApplicationSettings(workspaceId, objectId, jsonApiCustomApplicationSettingPatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Patch a Setting for Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceSettingPatchDocument} jsonApiWorkspaceSettingPatchDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntityWorkspaceSettings(workspaceId, objectId, jsonApiWorkspaceSettingPatchDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntityWorkspaceSettings(workspaceId, objectId, jsonApiWorkspaceSettingPatchDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Custom Application Setting
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiCustomApplicationSettingInDocument} jsonApiCustomApplicationSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityCustomApplicationSettings(workspaceId, objectId, jsonApiCustomApplicationSettingInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityCustomApplicationSettings(workspaceId, objectId, jsonApiCustomApplicationSettingInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Put a Setting for a Workspace
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceSettingInDocument} jsonApiWorkspaceSettingInDocument
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntityWorkspaceSettings(workspaceId, objectId, jsonApiWorkspaceSettingInDocument, filter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntityWorkspaceSettings(workspaceId, objectId, jsonApiWorkspaceSettingInDocument, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resolves values for all settings in a workspace by current user, workspace, organization, or default settings.
         * @summary Values for all settings.
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceResolveAllSettings(workspaceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceResolveAllSettings(workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resolves value for selected settings in a workspace by current user, workspace, organization, or default settings.
         * @summary Values for selected settings.
         * @param {string} workspaceId
         * @param {ResolveSettingsRequest} resolveSettingsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceResolveSettings(workspaceId, resolveSettingsRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceResolveSettings(workspaceId, resolveSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * WorkspacesSettingsApi - factory interface
 * @export
 */
export const WorkspacesSettingsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = WorkspacesSettingsApiFp(configuration);
    return {
        /**
         *
         * @summary Post Custom Application Settings
         * @param {WorkspacesSettingsApiCreateEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityCustomApplicationSettings(requestParameters, options) {
            return localVarFp
                .createEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.jsonApiCustomApplicationSettingPostOptionalIdDocument, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post Settings for Workspaces
         * @param {WorkspacesSettingsApiCreateEntityWorkspaceSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaceSettings(requestParameters, options) {
            return localVarFp
                .createEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.jsonApiWorkspaceSettingPostOptionalIdDocument, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Custom Application Setting
         * @param {WorkspacesSettingsApiDeleteEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityCustomApplicationSettings(requestParameters, options) {
            return localVarFp
                .deleteEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a Setting for Workspace
         * @param {WorkspacesSettingsApiDeleteEntityWorkspaceSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaceSettings(requestParameters, options) {
            return localVarFp
                .deleteEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Custom Application Settings
         * @param {WorkspacesSettingsApiGetAllEntitiesCustomApplicationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesCustomApplicationSettings(requestParameters, options) {
            return localVarFp
                .getAllEntitiesCustomApplicationSettings(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all Setting for Workspaces
         * @param {WorkspacesSettingsApiGetAllEntitiesWorkspaceSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceSettings(requestParameters, options) {
            return localVarFp
                .getAllEntitiesWorkspaceSettings(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Custom Application Setting
         * @param {WorkspacesSettingsApiGetEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityCustomApplicationSettings(requestParameters, options) {
            return localVarFp
                .getEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Setting for Workspace
         * @param {WorkspacesSettingsApiGetEntityWorkspaceSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceSettings(requestParameters, options) {
            return localVarFp
                .getEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Custom Application Setting
         * @param {WorkspacesSettingsApiPatchEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityCustomApplicationSettings(requestParameters, options) {
            return localVarFp
                .patchEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiCustomApplicationSettingPatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a Setting for Workspace
         * @param {WorkspacesSettingsApiPatchEntityWorkspaceSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaceSettings(requestParameters, options) {
            return localVarFp
                .patchEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceSettingPatchDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Custom Application Setting
         * @param {WorkspacesSettingsApiUpdateEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityCustomApplicationSettings(requestParameters, options) {
            return localVarFp
                .updateEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiCustomApplicationSettingInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put a Setting for a Workspace
         * @param {WorkspacesSettingsApiUpdateEntityWorkspaceSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaceSettings(requestParameters, options) {
            return localVarFp
                .updateEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceSettingInDocument, requestParameters.filter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Resolves values for all settings in a workspace by current user, workspace, organization, or default settings.
         * @summary Values for all settings.
         * @param {WorkspacesSettingsApiWorkspaceResolveAllSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceResolveAllSettings(requestParameters, options) {
            return localVarFp
                .workspaceResolveAllSettings(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Resolves value for selected settings in a workspace by current user, workspace, organization, or default settings.
         * @summary Values for selected settings.
         * @param {WorkspacesSettingsApiWorkspaceResolveSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceResolveSettings(requestParameters, options) {
            return localVarFp
                .workspaceResolveSettings(requestParameters.workspaceId, requestParameters.resolveSettingsRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * WorkspacesSettingsApi - object-oriented interface
 * @export
 * @class WorkspacesSettingsApi
 * @extends {BaseAPI}
 */
export class WorkspacesSettingsApi extends BaseAPI {
    /**
     *
     * @summary Post Custom Application Settings
     * @param {WorkspacesSettingsApiCreateEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSettingsApi
     */
    createEntityCustomApplicationSettings(requestParameters, options) {
        return WorkspacesSettingsApiFp(this.configuration)
            .createEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.jsonApiCustomApplicationSettingPostOptionalIdDocument, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post Settings for Workspaces
     * @param {WorkspacesSettingsApiCreateEntityWorkspaceSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSettingsApi
     */
    createEntityWorkspaceSettings(requestParameters, options) {
        return WorkspacesSettingsApiFp(this.configuration)
            .createEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.jsonApiWorkspaceSettingPostOptionalIdDocument, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Custom Application Setting
     * @param {WorkspacesSettingsApiDeleteEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSettingsApi
     */
    deleteEntityCustomApplicationSettings(requestParameters, options) {
        return WorkspacesSettingsApiFp(this.configuration)
            .deleteEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a Setting for Workspace
     * @param {WorkspacesSettingsApiDeleteEntityWorkspaceSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSettingsApi
     */
    deleteEntityWorkspaceSettings(requestParameters, options) {
        return WorkspacesSettingsApiFp(this.configuration)
            .deleteEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Custom Application Settings
     * @param {WorkspacesSettingsApiGetAllEntitiesCustomApplicationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSettingsApi
     */
    getAllEntitiesCustomApplicationSettings(requestParameters, options) {
        return WorkspacesSettingsApiFp(this.configuration)
            .getAllEntitiesCustomApplicationSettings(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all Setting for Workspaces
     * @param {WorkspacesSettingsApiGetAllEntitiesWorkspaceSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSettingsApi
     */
    getAllEntitiesWorkspaceSettings(requestParameters, options) {
        return WorkspacesSettingsApiFp(this.configuration)
            .getAllEntitiesWorkspaceSettings(requestParameters.workspaceId, requestParameters.origin, requestParameters.filter, requestParameters.page, requestParameters.size, requestParameters.sort, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Custom Application Setting
     * @param {WorkspacesSettingsApiGetEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSettingsApi
     */
    getEntityCustomApplicationSettings(requestParameters, options) {
        return WorkspacesSettingsApiFp(this.configuration)
            .getEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Setting for Workspace
     * @param {WorkspacesSettingsApiGetEntityWorkspaceSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSettingsApi
     */
    getEntityWorkspaceSettings(requestParameters, options) {
        return WorkspacesSettingsApiFp(this.configuration)
            .getEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.filter, requestParameters.xGDCVALIDATERELATIONS, requestParameters.metaInclude, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Custom Application Setting
     * @param {WorkspacesSettingsApiPatchEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSettingsApi
     */
    patchEntityCustomApplicationSettings(requestParameters, options) {
        return WorkspacesSettingsApiFp(this.configuration)
            .patchEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiCustomApplicationSettingPatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Patch a Setting for Workspace
     * @param {WorkspacesSettingsApiPatchEntityWorkspaceSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSettingsApi
     */
    patchEntityWorkspaceSettings(requestParameters, options) {
        return WorkspacesSettingsApiFp(this.configuration)
            .patchEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceSettingPatchDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Custom Application Setting
     * @param {WorkspacesSettingsApiUpdateEntityCustomApplicationSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSettingsApi
     */
    updateEntityCustomApplicationSettings(requestParameters, options) {
        return WorkspacesSettingsApiFp(this.configuration)
            .updateEntityCustomApplicationSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiCustomApplicationSettingInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put a Setting for a Workspace
     * @param {WorkspacesSettingsApiUpdateEntityWorkspaceSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSettingsApi
     */
    updateEntityWorkspaceSettings(requestParameters, options) {
        return WorkspacesSettingsApiFp(this.configuration)
            .updateEntityWorkspaceSettings(requestParameters.workspaceId, requestParameters.objectId, requestParameters.jsonApiWorkspaceSettingInDocument, requestParameters.filter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Resolves values for all settings in a workspace by current user, workspace, organization, or default settings.
     * @summary Values for all settings.
     * @param {WorkspacesSettingsApiWorkspaceResolveAllSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSettingsApi
     */
    workspaceResolveAllSettings(requestParameters, options) {
        return WorkspacesSettingsApiFp(this.configuration)
            .workspaceResolveAllSettings(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Resolves value for selected settings in a workspace by current user, workspace, organization, or default settings.
     * @summary Values for selected settings.
     * @param {WorkspacesSettingsApiWorkspaceResolveSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSettingsApi
     */
    workspaceResolveSettings(requestParameters, options) {
        return WorkspacesSettingsApiFp(this.configuration)
            .workspaceResolveSettings(requestParameters.workspaceId, requestParameters.resolveSettingsRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
//# sourceMappingURL=api.js.map