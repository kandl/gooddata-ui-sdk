/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import globalAxios from "axios";
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setSearchParams, toPathString, createRequestFunction } from './common.js';
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI } from './base.js';
export const AfmObjectIdentifierAttributeIdentifierTypeEnum = {
    ATTRIBUTE: "attribute",
};
export const AfmObjectIdentifierCoreIdentifierTypeEnum = {
    ATTRIBUTE: "attribute",
    LABEL: "label",
    FACT: "fact",
    METRIC: "metric",
};
export const AfmObjectIdentifierDatasetIdentifierTypeEnum = {
    DATASET: "dataset",
};
export const AfmObjectIdentifierIdentifierTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
    ATTRIBUTE: "attribute",
    DASHBOARD_PLUGIN: "dashboardPlugin",
    DATASET: "dataset",
    FACT: "fact",
    LABEL: "label",
    METRIC: "metric",
    PROMPT: "prompt",
    VISUALIZATION_OBJECT: "visualizationObject",
    FILTER_CONTEXT: "filterContext",
};
export const AfmObjectIdentifierLabelIdentifierTypeEnum = {
    LABEL: "label",
};
export const AfmValidObjectsQueryTypesEnum = {
    FACTS: "facts",
    ATTRIBUTES: "attributes",
    MEASURES: "measures",
    UNRECOGNIZED: "UNRECOGNIZED",
};
export const ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum = {
    SUM: "SUM",
    DIFFERENCE: "DIFFERENCE",
    MULTIPLICATION: "MULTIPLICATION",
    RATIO: "RATIO",
    CHANGE: "CHANGE",
};
export const AttributeHeaderOutAttributeHeaderGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
};
export const ComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum = {
    GREATER_THAN: "GREATER_THAN",
    GREATER_THAN_OR_EQUAL_TO: "GREATER_THAN_OR_EQUAL_TO",
    LESS_THAN: "LESS_THAN",
    LESS_THAN_OR_EQUAL_TO: "LESS_THAN_OR_EQUAL_TO",
    EQUAL_TO: "EQUAL_TO",
    NOT_EQUAL_TO: "NOT_EQUAL_TO",
};
export const ElementsRequestSortOrderEnum = {
    ASC: "ASC",
    DESC: "DESC",
};
export const ElementsResponseGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
};
export const FilterByLabelTypeEnum = {
    PRIMARY: "PRIMARY",
    REQUESTED: "REQUESTED",
};
export const RangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum = {
    BETWEEN: "BETWEEN",
    NOT_BETWEEN: "NOT_BETWEEN",
};
export const RankingFilterRankingFilterOperatorEnum = {
    TOP: "TOP",
    BOTTOM: "BOTTOM",
};
export const RelativeDateFilterRelativeDateFilterGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
};
export const SimpleMeasureDefinitionMeasureAggregationEnum = {
    SUM: "SUM",
    COUNT: "COUNT",
    AVG: "AVG",
    MIN: "MIN",
    MAX: "MAX",
    MEDIAN: "MEDIAN",
    RUNSUM: "RUNSUM",
    APPROXIMATE_COUNT: "APPROXIMATE_COUNT",
};
export const SortKeyAttributeAttributeSortTypeEnum = {
    DEFAULT: "DEFAULT",
    LABEL: "LABEL",
    ATTRIBUTE: "ATTRIBUTE",
    AREA: "AREA",
};
export const SortKeyAttributeAttributeDirectionEnum = {
    ASC: "ASC",
    DESC: "DESC",
};
export const SortKeyTotalTotalDirectionEnum = {
    ASC: "ASC",
    DESC: "DESC",
};
export const SortKeyValueValueDirectionEnum = {
    ASC: "ASC",
    DESC: "DESC",
};
export const TotalFunctionEnum = {
    SUM: "SUM",
    MIN: "MIN",
    MAX: "MAX",
    AVG: "AVG",
    MED: "MED",
};
/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {number} [limit] Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost: async (workspaceId, elementsRequest, offset, limit, skipCache, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeLabelElementsPost", "workspaceId", workspaceId);
            // verify required parameter 'elementsRequest' is not null or undefined
            assertParamExists("computeLabelElementsPost", "elementsRequest", elementsRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/collectLabelElements`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }
            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof elementsRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(elementsRequest !== undefined ? elementsRequest : {})
                : elementsRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport: async (workspaceId, afmExecution, skipCache, timestamp, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeReport", "workspaceId", workspaceId);
            // verify required parameter 'afmExecution' is not null or undefined
            assertParamExists("computeReport", "afmExecution", afmExecution);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter["timestamp"] = String(timestamp);
            }
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidDescendantsQuery} afmValidDescendantsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidDescendants: async (workspaceId, afmValidDescendantsQuery, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeValidDescendants", "workspaceId", workspaceId);
            // verify required parameter 'afmValidDescendantsQuery' is not null or undefined
            assertParamExists("computeValidDescendants", "afmValidDescendantsQuery", afmValidDescendantsQuery);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/computeValidDescendants`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof afmValidDescendantsQuery !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmValidDescendantsQuery !== undefined ? afmValidDescendantsQuery : {})
                : afmValidDescendantsQuery || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects: async (workspaceId, afmValidObjectsQuery, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeValidObjects", "workspaceId", workspaceId);
            // verify required parameter 'afmValidObjectsQuery' is not null or undefined
            assertParamExists("computeValidObjects", "afmValidObjectsQuery", afmValidObjectsQuery);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/computeValidObjects`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof afmValidObjectsQuery !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmValidObjectsQuery !== undefined ? afmValidObjectsQuery : {})
                : afmValidObjectsQuery || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS'} [explainType] Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;SETTINGS&#x60; - Settings used to execute explain request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM: async (workspaceId, afmExecution, explainType, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("explainAFM", "workspaceId", workspaceId);
            // verify required parameter 'afmExecution' is not null or undefined
            assertParamExists("explainAFM", "afmExecution", afmExecution);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/explain`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (explainType !== undefined) {
                localVarQueryParameter["explainType"] = explainType;
            }
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveExecutionMetadata: async (workspaceId, resultId, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("retrieveExecutionMetadata", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("retrieveExecutionMetadata", "resultId", resultId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}/metadata`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {Array<string>} [excludedTotalDimensions] Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult: async (workspaceId, resultId, offset, limit, excludedTotalDimensions, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("retrieveResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("retrieveResult", "resultId", resultId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (offset) {
                localVarQueryParameter["offset"] = offset.join(COLLECTION_FORMATS.csv);
            }
            if (limit) {
                localVarQueryParameter["limit"] = limit.join(COLLECTION_FORMATS.csv);
            }
            if (excludedTotalDimensions) {
                localVarQueryParameter["excludedTotalDimensions"] = excludedTotalDimensions.join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {number} [limit] Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeLabelElementsPost(workspaceId, elementsRequest, offset, limit, skipCache, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeLabelElementsPost(workspaceId, elementsRequest, offset, limit, skipCache, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeReport(workspaceId, afmExecution, skipCache, timestamp, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeReport(workspaceId, afmExecution, skipCache, timestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidDescendantsQuery} afmValidDescendantsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeValidDescendants(workspaceId, afmValidDescendantsQuery, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeValidDescendants(workspaceId, afmValidDescendantsQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeValidObjects(workspaceId, afmValidObjectsQuery, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeValidObjects(workspaceId, afmValidObjectsQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS'} [explainType] Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;SETTINGS&#x60; - Settings used to execute explain request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async explainAFM(workspaceId, afmExecution, explainType, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.explainAFM(workspaceId, afmExecution, explainType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveExecutionMetadata(workspaceId, resultId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveExecutionMetadata(workspaceId, resultId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {Array<string>} [excludedTotalDimensions] Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveResult(workspaceId, resultId, offset, limit, excludedTotalDimensions, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveResult(workspaceId, resultId, offset, limit, excludedTotalDimensions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ActionsApiFp(configuration);
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {ActionsApiComputeLabelElementsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost(requestParameters, options) {
            return localVarFp
                .computeLabelElementsPost(requestParameters.workspaceId, requestParameters.elementsRequest, requestParameters.offset, requestParameters.limit, requestParameters.skipCache, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {ActionsApiComputeReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport(requestParameters, options) {
            return localVarFp
                .computeReport(requestParameters.workspaceId, requestParameters.afmExecution, requestParameters.skipCache, requestParameters.timestamp, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {ActionsApiComputeValidDescendantsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidDescendants(requestParameters, options) {
            return localVarFp
                .computeValidDescendants(requestParameters.workspaceId, requestParameters.afmValidDescendantsQuery, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {ActionsApiComputeValidObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects(requestParameters, options) {
            return localVarFp
                .computeValidObjects(requestParameters.workspaceId, requestParameters.afmValidObjectsQuery, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {ActionsApiExplainAFMRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM(requestParameters, options) {
            return localVarFp
                .explainAFM(requestParameters.workspaceId, requestParameters.afmExecution, requestParameters.explainType, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {ActionsApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveExecutionMetadata(requestParameters, options) {
            return localVarFp
                .retrieveExecutionMetadata(requestParameters.workspaceId, requestParameters.resultId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {ActionsApiRetrieveResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult(requestParameters, options) {
            return localVarFp
                .retrieveResult(requestParameters.workspaceId, requestParameters.resultId, requestParameters.offset, requestParameters.limit, requestParameters.excludedTotalDimensions, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI {
    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
     * @param {ActionsApiComputeLabelElementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    computeLabelElementsPost(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .computeLabelElementsPost(requestParameters.workspaceId, requestParameters.elementsRequest, requestParameters.offset, requestParameters.limit, requestParameters.skipCache, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {ActionsApiComputeReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    computeReport(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .computeReport(requestParameters.workspaceId, requestParameters.afmExecution, requestParameters.skipCache, requestParameters.timestamp, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
     * @summary (BETA) Valid descendants
     * @param {ActionsApiComputeValidDescendantsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    computeValidDescendants(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .computeValidDescendants(requestParameters.workspaceId, requestParameters.afmValidDescendantsQuery, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {ActionsApiComputeValidObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    computeValidObjects(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .computeValidObjects(requestParameters.workspaceId, requestParameters.afmValidObjectsQuery, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * The resource provides static structures needed for investigation of a problem with given AFM.
     * @summary AFM explain resource.
     * @param {ActionsApiExplainAFMRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    explainAFM(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .explainAFM(requestParameters.workspaceId, requestParameters.afmExecution, requestParameters.explainType, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
     * @summary Get a single execution result\'s metadata.
     * @param {ActionsApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    retrieveExecutionMetadata(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .retrieveExecutionMetadata(requestParameters.workspaceId, requestParameters.resultId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {ActionsApiRetrieveResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    retrieveResult(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .retrieveResult(requestParameters.workspaceId, requestParameters.resultId, requestParameters.offset, requestParameters.limit, requestParameters.excludedTotalDimensions, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ComputationApi - axios parameter creator
 * @export
 */
export const ComputationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {number} [limit] Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost: async (workspaceId, elementsRequest, offset, limit, skipCache, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeLabelElementsPost", "workspaceId", workspaceId);
            // verify required parameter 'elementsRequest' is not null or undefined
            assertParamExists("computeLabelElementsPost", "elementsRequest", elementsRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/collectLabelElements`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }
            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof elementsRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(elementsRequest !== undefined ? elementsRequest : {})
                : elementsRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport: async (workspaceId, afmExecution, skipCache, timestamp, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeReport", "workspaceId", workspaceId);
            // verify required parameter 'afmExecution' is not null or undefined
            assertParamExists("computeReport", "afmExecution", afmExecution);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter["timestamp"] = String(timestamp);
            }
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidDescendantsQuery} afmValidDescendantsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidDescendants: async (workspaceId, afmValidDescendantsQuery, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeValidDescendants", "workspaceId", workspaceId);
            // verify required parameter 'afmValidDescendantsQuery' is not null or undefined
            assertParamExists("computeValidDescendants", "afmValidDescendantsQuery", afmValidDescendantsQuery);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/computeValidDescendants`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof afmValidDescendantsQuery !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmValidDescendantsQuery !== undefined ? afmValidDescendantsQuery : {})
                : afmValidDescendantsQuery || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects: async (workspaceId, afmValidObjectsQuery, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeValidObjects", "workspaceId", workspaceId);
            // verify required parameter 'afmValidObjectsQuery' is not null or undefined
            assertParamExists("computeValidObjects", "afmValidObjectsQuery", afmValidObjectsQuery);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/computeValidObjects`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof afmValidObjectsQuery !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmValidObjectsQuery !== undefined ? afmValidObjectsQuery : {})
                : afmValidObjectsQuery || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS'} [explainType] Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;SETTINGS&#x60; - Settings used to execute explain request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM: async (workspaceId, afmExecution, explainType, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("explainAFM", "workspaceId", workspaceId);
            // verify required parameter 'afmExecution' is not null or undefined
            assertParamExists("explainAFM", "afmExecution", afmExecution);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/explain`.replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (explainType !== undefined) {
                localVarQueryParameter["explainType"] = explainType;
            }
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveExecutionMetadata: async (workspaceId, resultId, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("retrieveExecutionMetadata", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("retrieveExecutionMetadata", "resultId", resultId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}/metadata`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {Array<string>} [excludedTotalDimensions] Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult: async (workspaceId, resultId, offset, limit, excludedTotalDimensions, options = {}) => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("retrieveResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("retrieveResult", "resultId", resultId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (offset) {
                localVarQueryParameter["offset"] = offset.join(COLLECTION_FORMATS.csv);
            }
            if (limit) {
                localVarQueryParameter["limit"] = limit.join(COLLECTION_FORMATS.csv);
            }
            if (excludedTotalDimensions) {
                localVarQueryParameter["excludedTotalDimensions"] = excludedTotalDimensions.join(COLLECTION_FORMATS.csv);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ComputationApi - functional programming interface
 * @export
 */
export const ComputationApiFp = function (configuration) {
    const localVarAxiosParamCreator = ComputationApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {number} [limit] Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeLabelElementsPost(workspaceId, elementsRequest, offset, limit, skipCache, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeLabelElementsPost(workspaceId, elementsRequest, offset, limit, skipCache, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeReport(workspaceId, afmExecution, skipCache, timestamp, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeReport(workspaceId, afmExecution, skipCache, timestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidDescendantsQuery} afmValidDescendantsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeValidDescendants(workspaceId, afmValidDescendantsQuery, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeValidDescendants(workspaceId, afmValidDescendantsQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeValidObjects(workspaceId, afmValidObjectsQuery, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeValidObjects(workspaceId, afmValidObjectsQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS'} [explainType] Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;SETTINGS&#x60; - Settings used to execute explain request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async explainAFM(workspaceId, afmExecution, explainType, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.explainAFM(workspaceId, afmExecution, explainType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveExecutionMetadata(workspaceId, resultId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveExecutionMetadata(workspaceId, resultId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {Array<string>} [excludedTotalDimensions] Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveResult(workspaceId, resultId, offset, limit, excludedTotalDimensions, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveResult(workspaceId, resultId, offset, limit, excludedTotalDimensions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ComputationApi - factory interface
 * @export
 */
export const ComputationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ComputationApiFp(configuration);
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {ComputationApiComputeLabelElementsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost(requestParameters, options) {
            return localVarFp
                .computeLabelElementsPost(requestParameters.workspaceId, requestParameters.elementsRequest, requestParameters.offset, requestParameters.limit, requestParameters.skipCache, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {ComputationApiComputeReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport(requestParameters, options) {
            return localVarFp
                .computeReport(requestParameters.workspaceId, requestParameters.afmExecution, requestParameters.skipCache, requestParameters.timestamp, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {ComputationApiComputeValidDescendantsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidDescendants(requestParameters, options) {
            return localVarFp
                .computeValidDescendants(requestParameters.workspaceId, requestParameters.afmValidDescendantsQuery, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {ComputationApiComputeValidObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects(requestParameters, options) {
            return localVarFp
                .computeValidObjects(requestParameters.workspaceId, requestParameters.afmValidObjectsQuery, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {ComputationApiExplainAFMRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM(requestParameters, options) {
            return localVarFp
                .explainAFM(requestParameters.workspaceId, requestParameters.afmExecution, requestParameters.explainType, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {ComputationApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveExecutionMetadata(requestParameters, options) {
            return localVarFp
                .retrieveExecutionMetadata(requestParameters.workspaceId, requestParameters.resultId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {ComputationApiRetrieveResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult(requestParameters, options) {
            return localVarFp
                .retrieveResult(requestParameters.workspaceId, requestParameters.resultId, requestParameters.offset, requestParameters.limit, requestParameters.excludedTotalDimensions, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * ComputationApi - object-oriented interface
 * @export
 * @class ComputationApi
 * @extends {BaseAPI}
 */
export class ComputationApi extends BaseAPI {
    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
     * @param {ComputationApiComputeLabelElementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    computeLabelElementsPost(requestParameters, options) {
        return ComputationApiFp(this.configuration)
            .computeLabelElementsPost(requestParameters.workspaceId, requestParameters.elementsRequest, requestParameters.offset, requestParameters.limit, requestParameters.skipCache, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {ComputationApiComputeReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    computeReport(requestParameters, options) {
        return ComputationApiFp(this.configuration)
            .computeReport(requestParameters.workspaceId, requestParameters.afmExecution, requestParameters.skipCache, requestParameters.timestamp, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
     * @summary (BETA) Valid descendants
     * @param {ComputationApiComputeValidDescendantsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    computeValidDescendants(requestParameters, options) {
        return ComputationApiFp(this.configuration)
            .computeValidDescendants(requestParameters.workspaceId, requestParameters.afmValidDescendantsQuery, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {ComputationApiComputeValidObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    computeValidObjects(requestParameters, options) {
        return ComputationApiFp(this.configuration)
            .computeValidObjects(requestParameters.workspaceId, requestParameters.afmValidObjectsQuery, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * The resource provides static structures needed for investigation of a problem with given AFM.
     * @summary AFM explain resource.
     * @param {ComputationApiExplainAFMRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    explainAFM(requestParameters, options) {
        return ComputationApiFp(this.configuration)
            .explainAFM(requestParameters.workspaceId, requestParameters.afmExecution, requestParameters.explainType, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
     * @summary Get a single execution result\'s metadata.
     * @param {ComputationApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    retrieveExecutionMetadata(requestParameters, options) {
        return ComputationApiFp(this.configuration)
            .retrieveExecutionMetadata(requestParameters.workspaceId, requestParameters.resultId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {ComputationApiRetrieveResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    retrieveResult(requestParameters, options) {
        return ComputationApiFp(this.configuration)
            .retrieveResult(requestParameters.workspaceId, requestParameters.resultId, requestParameters.offset, requestParameters.limit, requestParameters.excludedTotalDimensions, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
//# sourceMappingURL=api.js.map