/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import globalAxios from "axios";
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setSearchParams, toPathString, createRequestFunction } from './common.js';
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { BASE_PATH, BaseAPI } from './base.js';
export const DeclarativeColumnDataTypeEnum = {
    INT: "INT",
    STRING: "STRING",
    DATE: "DATE",
    NUMERIC: "NUMERIC",
    TIMESTAMP: "TIMESTAMP",
    TIMESTAMP_TZ: "TIMESTAMP_TZ",
    BOOLEAN: "BOOLEAN",
};
export const SqlColumnDataTypeEnum = {
    INT: "INT",
    STRING: "STRING",
    DATE: "DATE",
    NUMERIC: "NUMERIC",
    TIMESTAMP: "TIMESTAMP",
    TIMESTAMP_TZ: "TIMESTAMP_TZ",
    BOOLEAN: "BOOLEAN",
};
export const TestDefinitionRequestTypeEnum = {
    POSTGRESQL: "POSTGRESQL",
    REDSHIFT: "REDSHIFT",
    VERTICA: "VERTICA",
    SNOWFLAKE: "SNOWFLAKE",
    ADS: "ADS",
    BIGQUERY: "BIGQUERY",
    MSSQL: "MSSQL",
    PRESTO: "PRESTO",
    DREMIO: "DREMIO",
    DRILL: "DRILL",
    GREENPLUM: "GREENPLUM",
    AZURESQL: "AZURESQL",
    SYNAPSESQL: "SYNAPSESQL",
    DATABRICKS: "DATABRICKS",
};
/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
         * @summary Get a list of schema names of a database
         * @param {string} dataSourceId Data source id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceSchemata: async (dataSourceId, options = {}) => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("getDataSourceSchemata", "dataSourceId", dataSourceId);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/scanSchemata`.replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
         * @summary Scan a database to get a physical data model (PDM)
         * @param {string} dataSourceId Data source id
         * @param {ScanRequest} scanRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanDataSource: async (dataSourceId, scanRequest, options = {}) => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("scanDataSource", "dataSourceId", dataSourceId);
            // verify required parameter 'scanRequest' is not null or undefined
            assertParamExists("scanDataSource", "scanRequest", scanRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/scan`.replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof scanRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(scanRequest !== undefined ? scanRequest : {})
                : scanRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
         * @summary Collect metadata about SQL query
         * @param {string} dataSourceId Data source id
         * @param {ScanSqlRequest} scanSqlRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanSql: async (dataSourceId, scanSqlRequest, options = {}) => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("scanSql", "dataSourceId", dataSourceId);
            // verify required parameter 'scanSqlRequest' is not null or undefined
            assertParamExists("scanSql", "scanSqlRequest", scanSqlRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/scanSql`.replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof scanSqlRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(scanSqlRequest !== undefined ? scanSqlRequest : {})
                : scanSqlRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test if it is possible to connect to a database using an existing data source definition.
         * @summary Test data source connection by data source id
         * @param {string} dataSourceId Data source id
         * @param {TestRequest} testRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDataSource: async (dataSourceId, testRequest, options = {}) => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("testDataSource", "dataSourceId", dataSourceId);
            // verify required parameter 'testRequest' is not null or undefined
            assertParamExists("testDataSource", "testRequest", testRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/test`.replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof testRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(testRequest !== undefined ? testRequest : {})
                : testRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
         * @summary Test connection by data source definition
         * @param {TestDefinitionRequest} testDefinitionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDataSourceDefinition: async (testDefinitionRequest, options = {}) => {
            // verify required parameter 'testDefinitionRequest' is not null or undefined
            assertParamExists("testDataSourceDefinition", "testDefinitionRequest", testDefinitionRequest);
            const localVarPath = `/api/v1/actions/dataSource/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof testDefinitionRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(testDefinitionRequest !== undefined ? testDefinitionRequest : {})
                : testDefinitionRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration);
    return {
        /**
         * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
         * @summary Get a list of schema names of a database
         * @param {string} dataSourceId Data source id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataSourceSchemata(dataSourceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataSourceSchemata(dataSourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
         * @summary Scan a database to get a physical data model (PDM)
         * @param {string} dataSourceId Data source id
         * @param {ScanRequest} scanRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scanDataSource(dataSourceId, scanRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scanDataSource(dataSourceId, scanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
         * @summary Collect metadata about SQL query
         * @param {string} dataSourceId Data source id
         * @param {ScanSqlRequest} scanSqlRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scanSql(dataSourceId, scanSqlRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scanSql(dataSourceId, scanSqlRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test if it is possible to connect to a database using an existing data source definition.
         * @summary Test data source connection by data source id
         * @param {string} dataSourceId Data source id
         * @param {TestRequest} testRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testDataSource(dataSourceId, testRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testDataSource(dataSourceId, testRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
         * @summary Test connection by data source definition
         * @param {TestDefinitionRequest} testDefinitionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testDataSourceDefinition(testDefinitionRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testDataSourceDefinition(testDefinitionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ActionsApiFp(configuration);
    return {
        /**
         * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
         * @summary Get a list of schema names of a database
         * @param {ActionsApiGetDataSourceSchemataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceSchemata(requestParameters, options) {
            return localVarFp
                .getDataSourceSchemata(requestParameters.dataSourceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
         * @summary Scan a database to get a physical data model (PDM)
         * @param {ActionsApiScanDataSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanDataSource(requestParameters, options) {
            return localVarFp
                .scanDataSource(requestParameters.dataSourceId, requestParameters.scanRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
         * @summary Collect metadata about SQL query
         * @param {ActionsApiScanSqlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanSql(requestParameters, options) {
            return localVarFp
                .scanSql(requestParameters.dataSourceId, requestParameters.scanSqlRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Test if it is possible to connect to a database using an existing data source definition.
         * @summary Test data source connection by data source id
         * @param {ActionsApiTestDataSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDataSource(requestParameters, options) {
            return localVarFp
                .testDataSource(requestParameters.dataSourceId, requestParameters.testRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
         * @summary Test connection by data source definition
         * @param {ActionsApiTestDataSourceDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDataSourceDefinition(requestParameters, options) {
            return localVarFp
                .testDataSourceDefinition(requestParameters.testDefinitionRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI {
    /**
     * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
     * @summary Get a list of schema names of a database
     * @param {ActionsApiGetDataSourceSchemataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    getDataSourceSchemata(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .getDataSourceSchemata(requestParameters.dataSourceId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
     * @summary Scan a database to get a physical data model (PDM)
     * @param {ActionsApiScanDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    scanDataSource(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .scanDataSource(requestParameters.dataSourceId, requestParameters.scanRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
     * @summary Collect metadata about SQL query
     * @param {ActionsApiScanSqlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    scanSql(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .scanSql(requestParameters.dataSourceId, requestParameters.scanSqlRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Test if it is possible to connect to a database using an existing data source definition.
     * @summary Test data source connection by data source id
     * @param {ActionsApiTestDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    testDataSource(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .testDataSource(requestParameters.dataSourceId, requestParameters.testRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
     * @summary Test connection by data source definition
     * @param {ActionsApiTestDataSourceDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    testDataSourceDefinition(requestParameters, options) {
        return ActionsApiFp(this.configuration)
            .testDataSourceDefinition(requestParameters.testDefinitionRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ScanningApi - axios parameter creator
 * @export
 */
export const ScanningApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
         * @summary Get a list of schema names of a database
         * @param {string} dataSourceId Data source id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceSchemata: async (dataSourceId, options = {}) => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("getDataSourceSchemata", "dataSourceId", dataSourceId);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/scanSchemata`.replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
         * @summary Scan a database to get a physical data model (PDM)
         * @param {string} dataSourceId Data source id
         * @param {ScanRequest} scanRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanDataSource: async (dataSourceId, scanRequest, options = {}) => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("scanDataSource", "dataSourceId", dataSourceId);
            // verify required parameter 'scanRequest' is not null or undefined
            assertParamExists("scanDataSource", "scanRequest", scanRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/scan`.replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof scanRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(scanRequest !== undefined ? scanRequest : {})
                : scanRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
         * @summary Collect metadata about SQL query
         * @param {string} dataSourceId Data source id
         * @param {ScanSqlRequest} scanSqlRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanSql: async (dataSourceId, scanSqlRequest, options = {}) => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("scanSql", "dataSourceId", dataSourceId);
            // verify required parameter 'scanSqlRequest' is not null or undefined
            assertParamExists("scanSql", "scanSqlRequest", scanSqlRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/scanSql`.replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof scanSqlRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(scanSqlRequest !== undefined ? scanSqlRequest : {})
                : scanSqlRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ScanningApi - functional programming interface
 * @export
 */
export const ScanningApiFp = function (configuration) {
    const localVarAxiosParamCreator = ScanningApiAxiosParamCreator(configuration);
    return {
        /**
         * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
         * @summary Get a list of schema names of a database
         * @param {string} dataSourceId Data source id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataSourceSchemata(dataSourceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataSourceSchemata(dataSourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
         * @summary Scan a database to get a physical data model (PDM)
         * @param {string} dataSourceId Data source id
         * @param {ScanRequest} scanRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scanDataSource(dataSourceId, scanRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scanDataSource(dataSourceId, scanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
         * @summary Collect metadata about SQL query
         * @param {string} dataSourceId Data source id
         * @param {ScanSqlRequest} scanSqlRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scanSql(dataSourceId, scanSqlRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scanSql(dataSourceId, scanSqlRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ScanningApi - factory interface
 * @export
 */
export const ScanningApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ScanningApiFp(configuration);
    return {
        /**
         * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
         * @summary Get a list of schema names of a database
         * @param {ScanningApiGetDataSourceSchemataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceSchemata(requestParameters, options) {
            return localVarFp
                .getDataSourceSchemata(requestParameters.dataSourceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
         * @summary Scan a database to get a physical data model (PDM)
         * @param {ScanningApiScanDataSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanDataSource(requestParameters, options) {
            return localVarFp
                .scanDataSource(requestParameters.dataSourceId, requestParameters.scanRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
         * @summary Collect metadata about SQL query
         * @param {ScanningApiScanSqlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanSql(requestParameters, options) {
            return localVarFp
                .scanSql(requestParameters.dataSourceId, requestParameters.scanSqlRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * ScanningApi - object-oriented interface
 * @export
 * @class ScanningApi
 * @extends {BaseAPI}
 */
export class ScanningApi extends BaseAPI {
    /**
     * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
     * @summary Get a list of schema names of a database
     * @param {ScanningApiGetDataSourceSchemataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScanningApi
     */
    getDataSourceSchemata(requestParameters, options) {
        return ScanningApiFp(this.configuration)
            .getDataSourceSchemata(requestParameters.dataSourceId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
     * @summary Scan a database to get a physical data model (PDM)
     * @param {ScanningApiScanDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScanningApi
     */
    scanDataSource(requestParameters, options) {
        return ScanningApiFp(this.configuration)
            .scanDataSource(requestParameters.dataSourceId, requestParameters.scanRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
     * @summary Collect metadata about SQL query
     * @param {ScanningApiScanSqlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScanningApi
     */
    scanSql(requestParameters, options) {
        return ScanningApiFp(this.configuration)
            .scanSql(requestParameters.dataSourceId, requestParameters.scanSqlRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
/**
 * TestConnectionApi - axios parameter creator
 * @export
 */
export const TestConnectionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Test if it is possible to connect to a database using an existing data source definition.
         * @summary Test data source connection by data source id
         * @param {string} dataSourceId Data source id
         * @param {TestRequest} testRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDataSource: async (dataSourceId, testRequest, options = {}) => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("testDataSource", "dataSourceId", dataSourceId);
            // verify required parameter 'testRequest' is not null or undefined
            assertParamExists("testDataSource", "testRequest", testRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/test`.replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof testRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(testRequest !== undefined ? testRequest : {})
                : testRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
         * @summary Test connection by data source definition
         * @param {TestDefinitionRequest} testDefinitionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDataSourceDefinition: async (testDefinitionRequest, options = {}) => {
            // verify required parameter 'testDefinitionRequest' is not null or undefined
            assertParamExists("testDataSourceDefinition", "testDefinitionRequest", testDefinitionRequest);
            const localVarPath = `/api/v1/actions/dataSource/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = typeof testDefinitionRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(testDefinitionRequest !== undefined ? testDefinitionRequest : {})
                : testDefinitionRequest || "";
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TestConnectionApi - functional programming interface
 * @export
 */
export const TestConnectionApiFp = function (configuration) {
    const localVarAxiosParamCreator = TestConnectionApiAxiosParamCreator(configuration);
    return {
        /**
         * Test if it is possible to connect to a database using an existing data source definition.
         * @summary Test data source connection by data source id
         * @param {string} dataSourceId Data source id
         * @param {TestRequest} testRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testDataSource(dataSourceId, testRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testDataSource(dataSourceId, testRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
         * @summary Test connection by data source definition
         * @param {TestDefinitionRequest} testDefinitionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testDataSourceDefinition(testDefinitionRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testDataSourceDefinition(testDefinitionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * TestConnectionApi - factory interface
 * @export
 */
export const TestConnectionApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TestConnectionApiFp(configuration);
    return {
        /**
         * Test if it is possible to connect to a database using an existing data source definition.
         * @summary Test data source connection by data source id
         * @param {TestConnectionApiTestDataSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDataSource(requestParameters, options) {
            return localVarFp
                .testDataSource(requestParameters.dataSourceId, requestParameters.testRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
         * @summary Test connection by data source definition
         * @param {TestConnectionApiTestDataSourceDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDataSourceDefinition(requestParameters, options) {
            return localVarFp
                .testDataSourceDefinition(requestParameters.testDefinitionRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};
/**
 * TestConnectionApi - object-oriented interface
 * @export
 * @class TestConnectionApi
 * @extends {BaseAPI}
 */
export class TestConnectionApi extends BaseAPI {
    /**
     * Test if it is possible to connect to a database using an existing data source definition.
     * @summary Test data source connection by data source id
     * @param {TestConnectionApiTestDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestConnectionApi
     */
    testDataSource(requestParameters, options) {
        return TestConnectionApiFp(this.configuration)
            .testDataSource(requestParameters.dataSourceId, requestParameters.testRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
     * @summary Test connection by data source definition
     * @param {TestConnectionApiTestDataSourceDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestConnectionApi
     */
    testDataSourceDefinition(requestParameters, options) {
        return TestConnectionApiFp(this.configuration)
            .testDataSourceDefinition(requestParameters.testDefinitionRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
//# sourceMappingURL=api.js.map