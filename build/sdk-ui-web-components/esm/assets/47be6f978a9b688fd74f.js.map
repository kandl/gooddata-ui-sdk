{"version":3,"file":"assets/47be6f978a9b688fd74f.js","mappings":"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","sources":["webpack://@gooddata/sdk-ui-web-components/../sdk-backend-base/esm/decoratedBackend/execution.js","webpack://@gooddata/sdk-ui-web-components/../sdk-backend-base/esm/toolkit/execution.js","webpack://@gooddata/sdk-ui-web-components/../sdk-backend-spi/esm/errors/index.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/execution/attribute/factory.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/execution/attribute/index.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/execution/base/dimension.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/execution/base/sort.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/execution/base/totals.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/execution/buckets/bucketArray.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/execution/buckets/index.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/execution/executionDefinition/validation.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/execution/executionDefinition/factory.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/execution/filter/fingerprint.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/execution/measure/fingerprint.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/execution/executionDefinition/fingerprints.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/execution/base/fingerprint.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/execution/executionDefinition/index.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/execution/filter/filterMerge.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/execution/filter/index.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/execution/measure/factory.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/execution/measure/index.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/execution/results/index.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/insight/index.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/objRef/factory.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/objRef/index.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/sanitizeLocalId.js"],"sourcesContent":["import identity from \"lodash/identity.js\";\n/**\n * Base class for execution factory decorators. Implements all delegates.\n *\n * There is an opt-in functionality to decorate the prepared executions - which is a typical use case for\n * factory decorators.\n *\n * @alpha\n */\nexport class DecoratedExecutionFactory {\n    constructor(decorated, wrapper = identity) {\n        this.decorated = decorated;\n        this.wrapper = wrapper;\n        /**\n         * This method is a hook that can be used to wrap the execution prepared by the decorated factory - in essence\n         * to keep the decorator chain going and add extra functionality to the prepared execution.\n         *\n         * By default, this method will call the wrapper function passed to this class at construction time - so use\n         * that unless you need anything more fancy.\n         *\n         * @param execution - execution to wrap\n         */\n        this.wrap = (execution) => {\n            return this.wrapper(execution);\n        };\n    }\n    forDefinition(def) {\n        return this.wrap(this.decorated.forDefinition(def));\n    }\n    forItems(items, filters) {\n        return this.wrap(this.decorated.forItems(items, filters));\n    }\n    forBuckets(buckets, filters) {\n        return this.wrap(this.decorated.forBuckets(buckets, filters));\n    }\n    forInsight(insight, filters) {\n        return this.wrap(this.decorated.forInsight(insight, filters));\n    }\n    forInsightByRef(insight, filters) {\n        return this.wrap(this.decorated.forInsightByRef(insight, filters));\n    }\n}\n/**\n * Abstract base class for prepared execution decorators. Implements delegates to decorated execution. Concrete\n * implementations can override just the functions they are interested in.\n *\n * @alpha\n */\nexport class DecoratedPreparedExecution {\n    constructor(decorated) {\n        this.decorated = decorated;\n        this.definition = decorated.definition;\n    }\n    equals(other) {\n        return this.decorated.equals(other);\n    }\n    execute() {\n        return this.decorated.execute();\n    }\n    explain(config) {\n        return this.decorated.explain(config);\n    }\n    fingerprint() {\n        return this.decorated.fingerprint();\n    }\n    withDimensions(...dim) {\n        return this.createNew(this.decorated.withDimensions(...dim));\n    }\n    withSorting(...items) {\n        return this.createNew(this.decorated.withSorting(...items));\n    }\n    withDateFormat(dateFormat) {\n        return this.createNew(this.decorated.withDateFormat(dateFormat));\n    }\n    withExecConfig(config) {\n        return this.createNew(this.decorated.withExecConfig(config));\n    }\n}\n/**\n * Abstract base class for execution result decorators. Implements delegates to decorated execution. Concrete\n * implementations can override just the functions they are interested in.\n *\n * The prepared execution wrap is needed here because of the transform function which normally creates new\n * instances of prepared execution - and so the decoration needs to be maintained.\n *\n * @alpha\n */\nexport class DecoratedExecutionResult {\n    constructor(decorated, wrapper = identity) {\n        this.decorated = decorated;\n        this.wrapper = wrapper;\n        this.definition = decorated.definition;\n        this.dimensions = decorated.dimensions;\n    }\n    export(options) {\n        return this.decorated.export(options);\n    }\n    readAll() {\n        return this.decorated.readAll();\n    }\n    readWindow(offset, size) {\n        return this.decorated.readWindow(offset, size);\n    }\n    transform() {\n        return this.wrapper(this.decorated.transform());\n    }\n    equals(other) {\n        return this.decorated.equals(other);\n    }\n    fingerprint() {\n        return this.decorated.fingerprint();\n    }\n}\n/**\n * Abstract base class for data view decorators. Implements delegates to decorated data view. Concrete\n * implementations can override just the functions they are interested in.\n *\n * @alpha\n */\nexport class DecoratedDataView {\n    constructor(decorated, result) {\n        this.decorated = decorated;\n        this.result = result !== null && result !== void 0 ? result : decorated.result;\n        this.count = decorated.count;\n        this.data = decorated.data;\n        this.definition = decorated.definition;\n        this.headerItems = decorated.headerItems;\n        this.offset = decorated.offset;\n        this.totalCount = decorated.totalCount;\n        this.totals = decorated.totals;\n        this.totalTotals = decorated.totalTotals;\n        this.warnings = decorated.warnings;\n    }\n    equals(other) {\n        return this.decorated.equals(other);\n    }\n    fingerprint() {\n        return this.decorated.fingerprint();\n    }\n}\n//# sourceMappingURL=execution.js.map","// (C) 2019-2020 GoodData Corporation\nimport { defaultDimensionsGenerator, defWithDimensions, newDefForBuckets, newDefForInsight, newDefForItems, isInsight, } from \"@gooddata/sdk-model\";\nimport { DecoratedExecutionFactory } from \"../decoratedBackend/execution.js\";\n/**\n * Abstract base class that can be extended to implement concrete execution factories for different\n * backend implementations.\n *\n * This class implements the convenience methods which do not need to change in implementations.\n *\n * Note: the `forInsightByRef` is implemented as fallback to freeform execution done by `forInsight`. The\n * rationale is that most backends do not support that anyway so it is a safe default behavior. If the backend\n * supports execute-by-reference, then overload the method with your own implementation (see sdk-backend-bear for\n * inspiration)\n *\n * @internal\n */\nexport class AbstractExecutionFactory {\n    constructor(workspace) {\n        this.workspace = workspace;\n    }\n    forItems(items, filters) {\n        const def = defWithDimensions(newDefForItems(this.workspace, items, filters), defaultDimensionsGenerator);\n        return this.forDefinition(def);\n    }\n    forBuckets(buckets, filters) {\n        const def = defWithDimensions(newDefForBuckets(this.workspace, buckets, filters), defaultDimensionsGenerator);\n        return this.forDefinition(def);\n    }\n    forInsight(insight, filters) {\n        const def = defWithDimensions(newDefForInsight(this.workspace, insight, filters), defaultDimensionsGenerator);\n        return this.forDefinition(def);\n    }\n    forInsightByRef(insight, filters) {\n        return this.forInsight(insight, filters);\n    }\n}\n/**\n * This implementation of execution factory allows transparent injection of fixed set of filters to all\n * executions started through it.\n *\n * This factory will not perform any filter merging. All it does is ensure some filters are always passed\n * to the underlying factory. The responsibility to do the filter merging lies in the underlying factory.\n *\n * @internal\n */\nexport class ExecutionFactoryWithFixedFilters extends DecoratedExecutionFactory {\n    constructor(decorated, filters = []) {\n        super(decorated);\n        this.filters = filters;\n    }\n    forItems(items, filters = []) {\n        return super.forItems(items, this.filters.concat(filters));\n    }\n    forBuckets(buckets, filters = []) {\n        return super.forBuckets(buckets, this.filters.concat(filters));\n    }\n    forInsight(insight, filters = []) {\n        return super.forInsight(insight, this.filters.concat(filters));\n    }\n    forInsightByRef(insight, filters = []) {\n        return super.forInsightByRef(insight, this.filters.concat(filters));\n    }\n}\n/**\n * This implementation of execution factory will transparently upgrade any `forInsight` execution\n * to `forInsightByRef` execution IF the argument to `forInsight` is actually a persisted insight (`IInsight` which\n * is subtype of `IInsightDefinition`).\n *\n * @internal\n */\nexport class ExecutionFactoryUpgradingToExecByReference extends DecoratedExecutionFactory {\n    constructor(decorated) {\n        super(decorated);\n    }\n    forInsight(insight, filters) {\n        if (isInsight(insight)) {\n            return this.forInsightByRef(insight, filters);\n        }\n        return super.forInsight(insight, filters);\n    }\n}\n//# sourceMappingURL=execution.js.map","// (C) 2019-2023 GoodData Corporation\nimport isEmpty from \"lodash/isEmpty.js\";\n/**\n * Types of errors that can be raised by Analytical Backends.\n *\n * @public\n */\nexport const AnalyticalBackendErrorTypes = {\n    NO_DATA: \"ND\",\n    DATA_TOO_LARGE: \"DTL\",\n    PROTECTED_DATA: \"PD\",\n    UNEXPECTED_HTTP: \"UH\",\n    UNEXPECTED: \"UE\",\n    NOT_SUPPORTED: \"NS\",\n    NOT_IMPLEMENTED: \"NI!\",\n    NOT_AUTHENTICATED: \"NAuth\",\n    LIMIT_REACHED: \"LR\",\n    CONTRACT_EXPIRED: \"CE\",\n    TIMEOUT_ERROR: \"TE\",\n};\n/**\n * Superclass for all exceptions that can occur in Analytical Backend.\n *\n * @public\n */\nexport class AnalyticalBackendError extends Error {\n    constructor(message, abeType, cause) {\n        super(message);\n        this.abeType = abeType;\n        this.cause = cause;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n/**\n * This exception MUST be thrown when the backend execution identifies that there is no data to\n * calculate.\n *\n * @public\n */\nexport class NoDataError extends AnalyticalBackendError {\n    constructor(message, dataView, cause) {\n        super(message, AnalyticalBackendErrorTypes.NO_DATA, cause);\n        this.dataView = dataView;\n    }\n}\n/**\n * This exception MUST be thrown when backend execution identifies that there is too much data\n * to process for the execution and refuses to proceed.\n *\n * @public\n */\nexport class DataTooLargeError extends AnalyticalBackendError {\n    constructor(message, cause) {\n        super(message, AnalyticalBackendErrorTypes.DATA_TOO_LARGE, cause);\n    }\n}\n/**\n * This error means that during a repeated polling for some resource, we did not\n * reach 200 response within the certain number of attempts/time.\n *\n * @public\n */\nexport class TimeoutError extends AnalyticalBackendError {\n    constructor(message, cause) {\n        super(message, AnalyticalBackendErrorTypes.TIMEOUT_ERROR, cause);\n    }\n}\n/**\n * This exception MUST be thrown when backend execution identifies that the data to calculate\n * results for is protected and the caller lacks the sufficient authorization.\n *\n * @public\n */\nexport class ProtectedDataError extends AnalyticalBackendError {\n    constructor(message, cause) {\n        super(message, AnalyticalBackendErrorTypes.PROTECTED_DATA, cause);\n    }\n}\n/**\n * This exception MUST be thrown when communication with the backend encounters an unexpected\n * response status code and it cannot handle or categorize it to a known, domain-specific error.\n *\n * @public\n */\nexport class UnexpectedResponseError extends AnalyticalBackendError {\n    constructor(message, httpStatus, responseBody, traceId, cause) {\n        super(message, AnalyticalBackendErrorTypes.UNEXPECTED_HTTP, cause);\n        this.httpStatus = httpStatus;\n        this.responseBody = responseBody;\n        this.traceId = traceId;\n    }\n}\n/**\n * This exception MUST be thrown when the unexpected happens. This is a last-resort error type that SHOULD\n * be used if the erroneous state cannot be categorized in a better way.\n *\n * @public\n */\nexport class UnexpectedError extends AnalyticalBackendError {\n    constructor(message, cause) {\n        super(message, AnalyticalBackendErrorTypes.UNEXPECTED, cause);\n    }\n}\n/**\n * This exception is thrown when client code asks Analytical Backend to exercise an unsupported feature.\n *\n * @public\n */\nexport class NotSupported extends AnalyticalBackendError {\n    constructor(message) {\n        super(message, AnalyticalBackendErrorTypes.NOT_SUPPORTED);\n    }\n}\n/**\n * This exception is thrown when client code asks Analytical Backend to exercise a feature that is not\n * implemented yet.\n * @public\n */\nexport class NotImplemented extends AnalyticalBackendError {\n    constructor(message) {\n        super(message, AnalyticalBackendErrorTypes.NOT_IMPLEMENTED);\n    }\n}\n/**\n * This exception is thrown when client code triggers an operation which requires authentication but the client\n * code did not provide credentials or the credentials are invalid.\n *\n * @public\n */\nexport class NotAuthenticated extends AnalyticalBackendError {\n    constructor(message, cause, reason) {\n        super(message, AnalyticalBackendErrorTypes.NOT_AUTHENTICATED, cause);\n        this.reason = reason;\n    }\n}\n/**\n * This exception is thrown when the limit of objects that can be created on backend is reached, for example\n * if no more workspaces can be created because of the plan limits.\n *\n * @public\n */\nexport class LimitReached extends AnalyticalBackendError {\n    constructor(message, cause) {\n        super(message, AnalyticalBackendErrorTypes.LIMIT_REACHED, cause);\n    }\n}\n/**\n * This exception is thrown when a contract has expired, for example if a plan's trial period has ended\n *\n * @public\n */\nexport class ContractExpired extends AnalyticalBackendError {\n    constructor(message, cause) {\n        super(message, AnalyticalBackendErrorTypes.CONTRACT_EXPIRED, cause);\n    }\n}\n/**\n * Type guard checking whether input is an instance of {@link AnalyticalBackendError}\n *\n * @public\n */\nexport function isAnalyticalBackendError(obj) {\n    return !isEmpty(obj) && obj.abeType !== undefined;\n}\n/**\n * Type guard checking whether input is an instance of {@link NoDataError}\n *\n * @public\n */\nexport function isNoDataError(obj) {\n    return isAnalyticalBackendError(obj) && obj.abeType === AnalyticalBackendErrorTypes.NO_DATA;\n}\n/**\n * Type guard checking whether input is an instance of {@link DataTooLargeError}\n *\n * @public\n */\nexport function isDataTooLargeError(obj) {\n    return isAnalyticalBackendError(obj) && obj.abeType === AnalyticalBackendErrorTypes.DATA_TOO_LARGE;\n}\n/**\n * Type guard checking whether input is an instance of {@link ProtectedDataError}\n *\n * @public\n */\nexport function isProtectedDataError(obj) {\n    return isAnalyticalBackendError(obj) && obj.abeType === AnalyticalBackendErrorTypes.PROTECTED_DATA;\n}\n/**\n * Type guard checking whether input is an instance of {@link UnexpectedResponseError}\n *\n * @public\n */\nexport function isUnexpectedResponseError(obj) {\n    return isAnalyticalBackendError(obj) && obj.abeType === AnalyticalBackendErrorTypes.UNEXPECTED_HTTP;\n}\n/**\n * Type guard checking whether input is an instance of {@link UnexpectedResponseError}\n *\n * @public\n */\nexport function isUnexpectedError(obj) {\n    return isAnalyticalBackendError(obj) && obj.abeType === AnalyticalBackendErrorTypes.UNEXPECTED;\n}\n/**\n * Type guard checking whether input is an instance of {@link NotSupported}\n *\n * @public\n */\nexport function isNotSupported(obj) {\n    return isAnalyticalBackendError(obj) && obj.abeType === AnalyticalBackendErrorTypes.NOT_SUPPORTED;\n}\n/**\n * Type guard checking whether input is an instance of {@link NotImplemented}\n *\n * @public\n */\nexport function isNotImplemented(obj) {\n    return isAnalyticalBackendError(obj) && obj.abeType === AnalyticalBackendErrorTypes.NOT_IMPLEMENTED;\n}\n/**\n * Type guard checking whether input is an instance of {@link NotAuthenticated}\n *\n * @public\n */\nexport function isNotAuthenticated(obj) {\n    return isAnalyticalBackendError(obj) && obj.abeType === AnalyticalBackendErrorTypes.NOT_AUTHENTICATED;\n}\n/**\n * Type guard checking whether input is an instance of {@link LimitReached}\n *\n * @public\n */\nexport function isLimitReached(obj) {\n    return isAnalyticalBackendError(obj) && obj.abeType === AnalyticalBackendErrorTypes.LIMIT_REACHED;\n}\n/**\n * Type guard checking whether input is an instance of {@link ContractExpired}\n *\n * @public\n */\nexport function isContractExpired(obj) {\n    return isAnalyticalBackendError(obj) && obj.abeType === AnalyticalBackendErrorTypes.CONTRACT_EXPIRED;\n}\n//# sourceMappingURL=index.js.map","// (C) 2019-2023 GoodData Corporation\nimport identity from \"lodash/identity.js\";\nimport cloneDeep from \"lodash/cloneDeep.js\";\nimport isEmpty from \"lodash/isEmpty.js\";\nimport { isAttribute } from \"./index.js\";\nimport { objRefToString, isObjRef } from \"../../objRef/index.js\";\nimport { idRef } from \"../../objRef/factory.js\";\nimport SparkMD5 from \"spark-md5\";\nimport { sanitizeLocalId } from \"../../sanitizeLocalId.js\";\n/**\n * Builder for attributes.\n *\n * Do not instantiate this class directly. Instead use {@link newAttribute} or {@link modifyAttribute}.\n *\n * @public\n */\nexport class AttributeBuilder {\n    /**\n     * @internal\n     */\n    constructor(input) {\n        this.customLocalId = false;\n        /**\n         * Sets alias - alternative title - for the attribute.\n         *\n         * @remarks\n         * This value will then be used in various chart-specific descriptive elements. For convenience if no alias is specified,\n         * the attribute will fall back to server-defined value.\n         *\n         * @param alias - alias to use instead of attribute title; undefined to use server-defined value\n         */\n        this.alias = (alias) => {\n            if (!alias) {\n                return this.noAlias();\n            }\n            this.attribute.alias = alias;\n            return this;\n        };\n        /**\n         * Resets alias - alternative title - set for the attribute.\n         *\n         * @remarks\n         * The server-defined title of the attribute will be used instead.\n         */\n        this.noAlias = () => {\n            delete this.attribute.alias;\n            return this;\n        };\n        /**\n         * Sets show all values property.\n         *\n         * @remarks\n         * The flag showAllValues translates to a property of the same name on the attribute in execution definition.\n         * If truthy, the backend will return all values of the particular attribute in the execution response\n         * even if there are no data available for it.\n         *\n         * @param showAllValues - flag defining whether to return all attribute values for given attribute; undefined to use backend default behavior(false)\n         */\n        this.showAllValues = (showAllValues) => {\n            if (showAllValues === undefined) {\n                delete this.attribute.showAllValues;\n            }\n            else {\n                this.attribute.showAllValues = showAllValues;\n            }\n            return this;\n        };\n        /**\n         * Sets display form reference.\n         *\n         * @param ref - new ref to use\n         */\n        this.displayForm = (ref) => {\n            this.attribute.displayForm = ref;\n            return this;\n        };\n        /**\n         * Sets local identifier (localId) for the attribute. LocalId can be used to reference the attribute\n         * within the execution definition.\n         *\n         * Normally, builder will generate localId based on contents of the attribute definition - taking all\n         * properties into account: in typical scenarios you don't have to call this function at all. The only exception\n         * where you have to provide custom local id is if your execution must contain the exact same attribute twice.\n         *\n         * For convenience, this method also accepts 'undefined', which indicates that the default local id generation\n         * logic should be used.\n         *\n         * @param localId - local identifier to set; if not specified, the builder will ensure local id will\n         * be generated\n         */\n        this.localId = (localId) => {\n            if (!localId || localId.trim().length === 0) {\n                return this.defaultLocalId();\n            }\n            this.attribute.localIdentifier = localId;\n            this.customLocalId = true;\n            return this;\n        };\n        /**\n         * Indicates that the attribute's localId should be generated using the default local-id generator logic.\n         */\n        this.defaultLocalId = () => {\n            this.attribute.localIdentifier = \"\";\n            this.customLocalId = false;\n            return this;\n        };\n        /**\n         * Creates the IAttribute instance.\n         */\n        this.build = () => {\n            const localIdentifier = this.getOrGenerateLocalId();\n            return {\n                attribute: Object.assign(Object.assign({}, this.attribute), { localIdentifier }),\n            };\n        };\n        if (isAttribute(input)) {\n            this.attribute = cloneDeep(input.attribute);\n            this.customLocalId = true;\n        }\n        else {\n            const displayForm = isObjRef(input) ? input : idRef(input, \"displayForm\");\n            this.attribute = {\n                displayForm,\n                localIdentifier: \"\",\n            };\n        }\n    }\n    getOrGenerateLocalId() {\n        if (this.customLocalId && !isEmpty(this.attribute.localIdentifier)) {\n            return this.attribute.localIdentifier;\n        }\n        return sanitizeLocalId([\"a\", this.calculateAliasHash(), objRefToString(this.attribute.displayForm)]\n            .filter((part) => !isEmpty(part))\n            .join(\"_\"));\n    }\n    calculateAliasHash() {\n        if (!this.attribute.alias) {\n            return \"\";\n        }\n        const hasher = new SparkMD5();\n        hasher.append(this.attribute.alias);\n        return hasher.end().substr(0, 8);\n    }\n}\n/**\n * Creates a new attribute with the specified display form ref and optional modifications and localIdentifier.\n * @param displayFormRefOrId - ref or identifier of the attribute display form\n * @param modifications - optional modifications (e.g. alias, etc.)\n * @public\n */\nexport function newAttribute(displayFormRefOrId, modifications = identity) {\n    const builder = new AttributeBuilder(displayFormRefOrId);\n    return modifications(builder).build();\n}\n/**\n * Allows modification of an existing attribute instance.\n *\n * @remarks\n * The returned attribute will have the same localId as the original attribute. If you would like to assign\n * new/different local identifier to the attribute, you can do that using the modifications where you can provide\n * either new custom localId or indicate that the attribute should fall back to the auto-generated localId.\n *\n * @param attribute - attribute to modify\n * @param modifications - modification function\n * @public\n */\nexport function modifyAttribute(attribute, modifications = identity) {\n    const builder = new AttributeBuilder(attribute);\n    return modifications(builder).build();\n}\n//# sourceMappingURL=factory.js.map","// (C) 2019-2023 GoodData Corporation\nimport { isUriRef, isIdentifierRef } from \"../../objRef/index.js\";\nimport isEmpty from \"lodash/isEmpty.js\";\nimport { invariant } from \"ts-invariant\";\n/**\n * Type guard checking whether object is an instance of IAttribute.\n *\n * @public\n */\nexport function isAttribute(obj) {\n    return !isEmpty(obj) && obj.attribute !== undefined;\n}\n/**\n * Predicate that returns true for any attribute.\n *\n * @public\n */\nexport const anyAttribute = (_) => true;\n/**\n * Factory function for attribute predicate which evaluates true for attributes that match particular ID.\n *\n * @public\n */\nexport const idMatchAttribute = (id) => (attr) => attr.attribute.localIdentifier === id;\n//\n//\n//\n/**\n * Gets local identifier of an attribute.\n *\n * @remarks\n * For convenience and fluency, this function accepts both attribute object and identifier.\n *\n * @param attributeOrId - attribute to work with or the identifier\n * @returns value of local identifier\n * @public\n */\nexport function attributeLocalId(attributeOrId) {\n    invariant(attributeOrId, \"attribute must be specified\");\n    return typeof attributeOrId === \"string\" ? attributeOrId : attributeOrId.attribute.localIdentifier;\n}\n/**\n * Gets URI of attribute's display form to use and get attribute element values from.\n *\n * @param attribute - attribute to work with, may be undefined == result is undefined\n * @returns display form URI as string, undefined if display form not specified using URI\n * @public\n */\nexport function attributeUri(attribute) {\n    invariant(attribute, \"attribute must be specified\");\n    return isUriRef(attribute.attribute.displayForm) ? attribute.attribute.displayForm.uri : undefined;\n}\n/**\n * Gets identifier of attribute's display form to use and get attribute element values from.\n *\n * @param attribute - attribute to work with, may be undefined == result is undefined\n * @returns display form identifier as string, undefined if display for not specified using identifier\n * @public\n */\nexport function attributeIdentifier(attribute) {\n    invariant(attribute, \"attribute must be specified\");\n    return isIdentifierRef(attribute.attribute.displayForm)\n        ? attribute.attribute.displayForm.identifier\n        : undefined;\n}\n/**\n * Gets an attribute alias.\n *\n * @param attribute - attribute to work with\n * @returns value of attribute alias\n * @public\n */\nexport function attributeAlias(attribute) {\n    invariant(attribute, \"attribute must be specified\");\n    return attribute.attribute.alias;\n}\n/**\n * Gets an attribute show all values property.\n *\n * @param attribute - attribute to work with\n * @returns value of attribute show all values property\n * @public\n */\nexport function attributeShowAllValues(attribute) {\n    invariant(attribute, \"attribute must be specified\");\n    return attribute.attribute.showAllValues;\n}\n/**\n * Gets an attribute display form object ref.\n *\n * @param attribute - attribute to work with\n * @returns value of attribute display form object ref\n * @public\n */\nexport function attributeDisplayFormRef(attribute) {\n    invariant(attribute, \"attribute must be specified\");\n    return attribute.attribute.displayForm;\n}\n/**\n * Given list of attributes, returns first-found attribute matching the provided predicate.\n *\n * @remarks\n * If no predicate is provided, then the function defaults to anyAttribute predicate - meaning first found attribute\n * will be returned.\n *\n * This function also provides convenience to find attribute by its local identifier - if you pass predicate as\n * string the function will automatically create idMatchAttribute predicate.\n *\n * @param attributes - list of attributes to work with, must be specified\n * @param idOrFun - attribute identifier or instance of AttributePredicate; {@link anyAttribute} predicate is default\n * @public\n */\nexport function attributesFind(attributes, idOrFun = anyAttribute) {\n    invariant(attributes, \"attributes must be specified\");\n    if (!attributes.length) {\n        return;\n    }\n    const predicate = typeof idOrFun === \"string\" ? idMatchAttribute(idOrFun) : idOrFun;\n    return attributes.find(predicate);\n}\n//# sourceMappingURL=index.js.map","// (C) 2019-2022 GoodData Corporation\nimport { invariant } from \"ts-invariant\";\nimport { isTotal } from \"./totals.js\";\nimport isEmpty from \"lodash/isEmpty.js\";\nimport findIndex from \"lodash/findIndex.js\";\nimport { attributeLocalId, isAttribute } from \"../attribute/index.js\";\n/**\n * Measure Group is a pseudo-identifier which can be used in an execution dimension and indicates\n * that this dimension MUST contain all the measures.\n *\n * @public\n */\nexport const MeasureGroupIdentifier = \"measureGroup\";\n/**\n * Determine if a given item is a measure group.\n *\n * @public\n */\nexport const isMeasureGroupIdentifier = (itemOrTotal) => itemOrTotal === MeasureGroupIdentifier;\n//\n// Type guards\n//\n/**\n * Type guard checking whether object is of IDimension type.\n *\n * @public\n */\nexport function isDimension(obj) {\n    return !isEmpty(obj) && obj.itemIdentifiers !== undefined;\n}\n//\n// Public functions\n//\n/**\n * Gets totals defined in the provided dimension\n *\n * @param dim - dimension to work with\n * @returns totals in the dimension or empty array if none\n * @public\n */\nexport function dimensionTotals(dim) {\n    invariant(dim, \"dimension must be specified\");\n    return dim.totals ? dim.totals : [];\n}\n/**\n * Creates a new dimension which has same items as the provided dimension but different totals.\n *\n * @param dim - dimension to inherit item identifiers from\n * @param totals - totals to have in the new dimension\n * @returns new dimension\n * @public\n */\nexport function dimensionSetTotals(dim, totals = []) {\n    invariant(dim, \"dimension must be specified\");\n    const totalsProp = !isEmpty(totals) ? { totals } : {};\n    return Object.assign({ itemIdentifiers: dim.itemIdentifiers }, totalsProp);\n}\n/**\n * Creates new two dimensional specification where each dimension will have the provided set of\n * identifiers.\n *\n * @remarks\n * The 'measureGroup' identifier MAY be specified in only one of the dimensions.\n *\n * @param dim1Input - items to put into the first dimension, this can be item identifiers or totals\n * @param dim2Input - items to put into the second dimension, this can be item identifiers or totals\n * @returns array with exactly two dimensions\n * @public\n */\nexport function newTwoDimensional(dim1Input, dim2Input) {\n    invariant(dim1Input, \"input for first dimension must be specified\");\n    invariant(dim2Input, \"input for second dimension must be specified\");\n    const atMostOneMeasureGroup = !(dim1Input.find(isMeasureGroupIdentifier) && dim2Input.find(isMeasureGroupIdentifier));\n    invariant(atMostOneMeasureGroup, \"The 'measureGroup' identifier must only be specified in one dimension.\");\n    return [newDimension(dim1Input), newDimension(dim2Input)];\n}\n/**\n * Creates new single-dimensional specification where the dimension will have the provided set of identifiers.\n *\n * @param items - allows for mix of item identifiers, attributes and total definitions to have in the new dimension\n * @param totals - additional totals to add to the dimension\n * @returns single dimension\n * @public\n */\nexport function newDimension(items = [], totals = []) {\n    const input = items.reduce((acc, value) => {\n        if (isTotal(value)) {\n            acc.totals.push(value);\n        }\n        else if (isAttribute(value)) {\n            acc.ids.push(attributeLocalId(value));\n        }\n        else {\n            acc.ids.push(value);\n        }\n        return acc;\n    }, { ids: [], totals: [] });\n    input.totals.push(...totals);\n    const totalsProp = !isEmpty(input.totals) ? { totals: input.totals } : {};\n    return Object.assign({ itemIdentifiers: input.ids }, totalsProp);\n}\n/**\n * Looks for item with the provided local identifier among the dimensions.\n *\n * @param dims - list of dimensions to look in\n * @param localId - local identifier to find among item identifiers\n * @returns list of items in dimensions, empty if not found, may contain more than one entry if\n *  item is in multiple dimensions\n * @public\n */\nexport function dimensionsFindItem(dims, localId) {\n    const result = [];\n    for (let dimIdx = 0; dimIdx < dims.length; dimIdx++) {\n        const dim = dims[dimIdx];\n        const itemIdx = findIndex(dim.itemIdentifiers, (i) => i === localId);\n        if (itemIdx >= 0) {\n            result.push({ dim, dimIdx, itemIdx });\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=dimension.js.map","import { attributeLocalId } from \"../attribute/index.js\";\nimport { measureLocalId } from \"../measure/index.js\";\nimport isEmpty from \"lodash/isEmpty.js\";\nimport { invariant } from \"ts-invariant\";\n//\n// Type guards\n//\n/**\n * Type guard checking whether an object is an attribute sort item.\n *\n * @public\n */\nexport function isAttributeSort(obj) {\n    return !isEmpty(obj) && obj.attributeSortItem !== undefined;\n}\n/**\n * Type guard checking whether an object is an attribute area sort item.\n *\n * @public\n */\nexport function isAttributeAreaSort(obj) {\n    return isAttributeSort(obj) && obj.attributeSortItem.aggregation !== undefined;\n}\n/**\n * Type guard checking whether an object is a normal attribute value sort item, not the area one.\n *\n * @public\n */\nexport function isAttributeValueSort(obj) {\n    return isAttributeSort(obj) && !isAttributeAreaSort(obj);\n}\n/**\n * Type guard checking whether an object is a measure sort item.\n *\n * @public\n */\nexport function isMeasureSort(obj) {\n    return !isEmpty(obj) && obj.measureSortItem !== undefined;\n}\n/**\n * Type guard checking whether an object is an attribute locator.\n *\n * @public\n */\nexport function isAttributeLocator(obj) {\n    return !isEmpty(obj) && obj.attributeLocatorItem !== undefined;\n}\n/**\n * Type guard checking whether an object is a total locator.\n *\n * @public\n */\nexport function isTotalLocator(obj) {\n    return !isEmpty(obj) && obj.totalLocatorItem !== undefined;\n}\n/**\n * Type guard checking whether an object is measure locator\n *\n * @public\n */\nexport function isMeasureLocator(obj) {\n    return !isEmpty(obj) && obj.measureLocatorItem !== undefined;\n}\n//\n// Public functions\n//\n/**\n * Gets sort item's direction\n * @param sort - sort item.\n * @public\n */\nexport function sortDirection(sort) {\n    invariant(sort, \"sort item must be specified\");\n    if (isAttributeSort(sort)) {\n        return sort.attributeSortItem.direction;\n    }\n    else {\n        return sort.measureSortItem.direction;\n    }\n}\n/**\n * Given sort item, returns ids of entities (objects) that are referenced by the sort item.\n *\n * @remarks\n * The ids are returned in an categorized way.\n *\n * @public\n */\nexport function sortEntityIds(sort) {\n    invariant(sort, \"sort item must be specified\");\n    const res = {\n        attributeIdentifiers: [],\n        measureIdentifiers: [],\n        allIdentifiers: [],\n    };\n    if (isAttributeSort(sort)) {\n        const attrId = sort.attributeSortItem.attributeIdentifier;\n        res.attributeIdentifiers.push(attrId);\n        res.allIdentifiers.push(attrId);\n    }\n    else if (isMeasureSort(sort)) {\n        sort.measureSortItem.locators.forEach((loc) => {\n            if (isAttributeLocator(loc)) {\n                const attrId = loc.attributeLocatorItem.attributeIdentifier;\n                res.attributeIdentifiers.push(attrId);\n                res.allIdentifiers.push(attrId);\n            }\n            else if (isMeasureLocator(loc)) {\n                const measureId = loc.measureLocatorItem.measureIdentifier;\n                res.measureIdentifiers.push(measureId);\n                res.allIdentifiers.push(measureId);\n            }\n        });\n    }\n    return res;\n}\n/**\n * Given a measure sort item, return the locators which identify the measure (possibly scoped for particular\n * attribute element).\n *\n * @param sort - measure sort items\n * @returns measure sort locators\n * @public\n */\nexport function sortMeasureLocators(sort) {\n    return sort.measureSortItem.locators;\n}\n/**\n * Given attribute locator, return the localId of attribute that it references.\n *\n * @param locator - attribute locator\n * @returns attribute localId\n * @public\n */\nexport function attributeLocatorIdentifier(locator) {\n    return locator.attributeLocatorItem.attributeIdentifier;\n}\n/**\n * Given attribute locator, return the element that it references.\n *\n * @param locator - attribute locator\n * @returns attribute element\n * @public\n */\nexport function attributeLocatorElement(locator) {\n    return locator.attributeLocatorItem.element;\n}\n/**\n * Given measure locator, return the localId of measure that it references.\n *\n * @param locator - measure locator\n * @returns measure localId\n * @public\n */\nexport function measureLocatorIdentifier(locator) {\n    return locator.measureLocatorItem.measureIdentifier;\n}\n/**\n * Creates a new attribute sort - sorting the result by values of the provided attribute's elements.\n *\n * @remarks\n * The attribute can be either specified by value or by reference using its local identifier.\n *\n * @param attributeOrId - attribute to sort by\n * @param sortDirection - asc or desc, defaults to \"asc\"\n * @returns always new item\n * @public\n */\nexport function newAttributeSort(attributeOrId, sortDirection = \"asc\") {\n    invariant(attributeOrId, \"attribute to create sort for must be specified\");\n    const id = attributeLocalId(attributeOrId);\n    return {\n        attributeSortItem: {\n            attributeIdentifier: id,\n            direction: sortDirection,\n        },\n    };\n}\n/**\n * Creates a new attribute area sort - sorting the result by aggregated measure values belonging to each\n * attribute value included in the result.\n *\n * @param attributeOrId - attribute to sort by\n * @param sortDirection - sorting direction\n * @param aggregation - area sort aggregation function. only \"sum\" is supported at the moment.\n * @public\n */\nexport function newAttributeAreaSort(attributeOrId, sortDirection = \"asc\", aggregation = \"sum\") {\n    invariant(attributeOrId, \"attribute to create sort for must be specified\");\n    const id = attributeLocalId(attributeOrId);\n    return {\n        attributeSortItem: {\n            attributeIdentifier: id,\n            direction: sortDirection,\n            aggregation,\n        },\n    };\n}\n/**\n * Creates a new measure sort - sorting the result by values of the provided measure.\n *\n * @remarks\n * The measure can be either specified by value or by reference using its local identifier.\n *\n * @param measureOrId - measure to sort by\n * @param sortDirection - asc or desc, defaults to \"asc\"\n * @param attributeLocators - optional attribute locators\n * @returns new sort item\n * @public\n */\nexport function newMeasureSort(measureOrId, sortDirection = \"asc\", attributeLocators = []) {\n    invariant(measureOrId, \"measure to create sort for must be specified\");\n    const id = measureLocalId(measureOrId);\n    return {\n        measureSortItem: {\n            direction: sortDirection,\n            locators: [\n                ...attributeLocators,\n                {\n                    measureLocatorItem: {\n                        measureIdentifier: id,\n                    },\n                },\n            ],\n        },\n    };\n}\n/**\n * Creates a new measure sort - sorting the result by values of the provided measure.\n *\n * @remarks\n * New measure sort is created from provided parts. Helpful eg. for just switching the direction of existing sort\n *\n * @param locators - complete locators\n * @param sortDirection - asc or desc, defaults to \"asc\"\n * @returns new sort item\n * @public\n */\nexport function newMeasureSortFromLocators(locators, sortDirection = \"asc\") {\n    invariant(locators.length !== 0, \"locators must be specified\");\n    return {\n        measureSortItem: {\n            direction: sortDirection,\n            locators,\n        },\n    };\n}\n/**\n * Creates a new attribute locator for an attribute element.\n *\n * @param attributeOrId - attribute, can be specified by either the attribute object or its local identifier\n * @param element - attribute element value URI or primary label value\n * @returns new locator\n * @public\n */\nexport function newAttributeLocator(attributeOrId, element) {\n    invariant(attributeOrId, \"attribute to create sort locator for must be specified\");\n    invariant(element, \"attribute element must be specified\");\n    const localId = attributeLocalId(attributeOrId);\n    return {\n        attributeLocatorItem: {\n            attributeIdentifier: localId,\n            element,\n        },\n    };\n}\n//# sourceMappingURL=sort.js.map","// (C) 2019-2022 GoodData Corporation\nimport isEmpty from \"lodash/isEmpty.js\";\nimport { measureLocalId } from \"../measure/index.js\";\nimport { attributeLocalId } from \"../attribute/index.js\";\nimport { invariant } from \"ts-invariant\";\n//\n// Type guards\n//\n/**\n * Type-guard checking whether an object is a Total.\n *\n * @public\n */\nexport function isTotal(obj) {\n    return (!isEmpty(obj) &&\n        obj.type !== undefined &&\n        obj.measureIdentifier !== undefined &&\n        obj.attributeIdentifier !== undefined);\n}\n//\n//\n//\n/**\n * Creates a new total.\n *\n * @param type - type of total, one of the enumerated types\n * @param measureOrId - measure instance OR measure local identifier\n * @param attributeOrId - attribute instance OR attribute local identifier\n * @param alias - provide custom name (alias) for the total; this will be included in the computed results\n * @returns new total\n * @public\n */\nexport function newTotal(type, measureOrId, attributeOrId, alias) {\n    invariant(type, \"total type must be specified\");\n    invariant(measureOrId, \"measure or measure local id must be specified\");\n    invariant(attributeOrId, \"attribute or attribute local id must be specified\");\n    const measureIdentifier = measureLocalId(measureOrId);\n    const attributeIdentifier = attributeLocalId(attributeOrId);\n    const aliasProp = alias ? { alias } : {};\n    return Object.assign({ type,\n        measureIdentifier,\n        attributeIdentifier }, aliasProp);\n}\n/**\n * Tests whether total instance represents a native total = a roll-up total.\n *\n * @public\n */\nexport function totalIsNative(total) {\n    invariant(total, \"total must be specified\");\n    return total.type === \"nat\";\n}\n//# sourceMappingURL=totals.js.map","// (C) 2019-2022 GoodData Corporation\nimport { anyBucket, bucketAttributes, bucketIsEmpty, bucketItems, bucketMeasures, bucketTotals, idMatchBucket, bucketModifyItems, bucketItemReduce, } from \"./index.js\";\nimport { anyAttribute, idMatchAttribute, isAttribute, } from \"../attribute/index.js\";\nimport { anyMeasure, idMatchMeasure, isMeasure } from \"../measure/index.js\";\nimport flatMap from \"lodash/flatMap.js\";\nimport { invariant } from \"ts-invariant\";\nimport identity from \"lodash/identity.js\";\nimport findIndex from \"lodash/findIndex.js\";\n/**\n * Gets all attributes matching the provided predicate from a list of buckets.\n *\n * @remarks\n * If no predicate is provided, then the function defaults to {@link anyAttribute} predicate - meaning all\n * attributes will be returned.\n *\n * @param buckets - list of buckets to get attributes from\n * @param predicate - attribute predicate; {@link anyAttribute} is default\n * @returns empty list if none match\n * @public\n */\nexport function bucketsAttributes(buckets, predicate = anyAttribute) {\n    invariant(buckets, \"buckets must be specified\");\n    if (!buckets.length) {\n        return [];\n    }\n    return flatMap(buckets, (b) => bucketAttributes(b, predicate));\n}\n/**\n * Gets all measures matching the provided predicate from a list of buckets.\n *\n * @remarks\n * If no predicate is provided, then the function defaults to {@link anyMeasure} predicate - meaning all\n * measures will be returned.\n *\n * @param buckets - list of buckets to get measures from\n * @param predicate - measure predicate; {@link anyMeasure} is default\n * @returns empty list if none match\n * @public\n */\nexport function bucketsMeasures(buckets, predicate = anyMeasure) {\n    invariant(buckets, \"buckets must be specified\");\n    if (!buckets.length) {\n        return [];\n    }\n    return flatMap(buckets, (b) => bucketMeasures(b, predicate));\n}\n/**\n * Finds bucket matching the provided predicate in a list of buckets.\n *\n * @remarks\n * If no predicate is provided, then the function defaults to {@link anyBucket} predicate - meaning first\n * bucket in the list will be returned.\n *\n * This function also provides convenience to find bucket by local identifier - if you pass predicate as\n * string the function will automatically create idMatchBucket predicate.\n *\n * @param buckets - list of buckets to search\n * @param idOrFun - bucket predicate or string to match bucket by local identifier; {@link anyBucket} is default\n * @public\n */\nexport function bucketsFind(buckets, idOrFun = anyBucket) {\n    invariant(buckets, \"buckets must be specified\");\n    const predicate = typeof idOrFun === \"string\" ? idMatchBucket(idOrFun) : idOrFun;\n    return buckets.find(predicate);\n}\n/**\n * Finds attribute matching the provided predicate in a list of buckets.\n *\n * @remarks\n * If found, the function returns an object that contains bucket where the matched attribute is stored, index within\n * that bucket and the attribute itself.\n *\n * This function also provides convenience to find attribute by local identifier - if you pass predicate as\n * string the function will automatically create idMatchAttribute predicate.\n *\n * @remarks See {@link AttributeInBucket}\n *\n * @param buckets - list of buckets to search\n * @param idOrFun - attribute predicate or string to find attribute by local identifier; defaults to {@link anyAttribute}\n * @returns first-found attribute matching the predicate, undefined if none match\n * @public\n */\nexport function bucketsFindAttribute(buckets, idOrFun = anyAttribute) {\n    invariant(buckets, \"buckets must be specified\");\n    if (!buckets.length) {\n        return;\n    }\n    const predicate = typeof idOrFun === \"string\" ? idMatchAttribute(idOrFun) : idOrFun;\n    const typeAgnosticPredicate = (obj) => {\n        return isAttribute(obj) && predicate(obj);\n    };\n    for (const bucket of buckets) {\n        const idx = findIndex(bucket.items, typeAgnosticPredicate);\n        if (idx >= 0) {\n            const item = bucket.items[idx];\n            return isAttribute(item) ? { bucket, idx, attribute: item } : undefined;\n        }\n    }\n    return undefined;\n}\n/**\n * Finds measure matching the provided predicate in a list of buckets.\n *\n * @remarks\n * If found, the function returns an object that contains bucket where the matched measure is stored, index\n * within that bucket and the measure itself.\n *\n * This function also provides convenience to find measure by local identifier - if you pass predicate as\n * string the function will automatically create idMatchMeasure predicate.\n *\n * @remarks See {@link MeasureInBucket}\n *\n * @param buckets - list of buckets to search\n * @param idOrFun - measure predicate or string to find measure by local identifier; defaults to {@link anyMeasure}\n * @returns first-found measure matching the predicate, undefined if none match\n * @public\n */\nexport function bucketsFindMeasure(buckets, idOrFun = anyMeasure) {\n    invariant(buckets, \"buckets must be specified\");\n    if (!buckets.length) {\n        return;\n    }\n    const predicate = typeof idOrFun === \"string\" ? idMatchMeasure(idOrFun) : idOrFun;\n    const typeAgnosticPredicate = (obj) => {\n        return isMeasure(obj) && predicate(obj);\n    };\n    for (const bucket of buckets) {\n        const idx = findIndex(bucket.items, typeAgnosticPredicate);\n        if (idx >= 0) {\n            const item = bucket.items[idx];\n            return isMeasure(item) ? { bucket, idx, measure: item } : undefined;\n        }\n    }\n    return undefined;\n}\n/**\n * Gets buckets with the provided local identifiers from a list of buckets.\n *\n * @param buckets - list of buckets to filter\n * @param ids - bucket identifiers\n * @returns empty list if none match\n * @public\n */\nexport function bucketsById(buckets, ...ids) {\n    invariant(buckets, \"buckets must be specified\");\n    if (!buckets.length || !ids || !ids.length) {\n        return [];\n    }\n    return buckets.filter((b) => b.localIdentifier && ids.indexOf(b.localIdentifier) >= 0);\n}\n/**\n * Gets all attributes and measures from a list of buckets.\n *\n * @param buckets - buckets to work with\n * @returns empty list if none\n * @public\n */\nexport function bucketsItems(buckets) {\n    invariant(buckets, \"buckets must be specified\");\n    return flatMap(buckets, (b) => bucketItems(b));\n}\n/**\n * Gets all totals from a list of buckets\n *\n * @param buckets - buckets to work with\n * @returns empty list if none\n * @public\n */\nexport function bucketsTotals(buckets) {\n    invariant(buckets, \"buckets must be specified\");\n    return flatMap(buckets, (b) => bucketTotals(b));\n}\n/**\n * Tests whether all buckets in a list are empty (meaning neither has any items or totals defined)\n *\n * @param buckets - buckets to work with\n * @returns true if empty, false if not\n * @public\n */\nexport function bucketsIsEmpty(buckets) {\n    invariant(buckets, \"buckets must be specified\");\n    if (!buckets.length) {\n        return true;\n    }\n    return buckets.every(bucketIsEmpty);\n}\n/**\n * Creates a new array of buckets, each bucket in the array contains modified bucket items\n * (retrieved by applying the modifications function to the bucketItem).\n *\n * @param buckets - an array of buckets, all items of each bucket in the array are applied the modification function\n * @param modifications - the modification to apply to the bucket items\n * @returns a new array of buckets, each bucket in the array contains modified bucket items\n * @public\n */\nexport function bucketsModifyItem(buckets, modifications = identity) {\n    invariant(buckets, \"buckets must be specified\");\n    return buckets.map((bucket) => bucketModifyItems(bucket, modifications));\n}\n/**\n * Creates a new array of buckets, each bucket in the array contains modified bucket items\n *\n * @param buckets - an array of buckets, array is applied the modification function\n * @param reducer - the reducer to apply to the bucket items array\n * @returns a new array of buckets, each bucket in the array contains modified bucket items\n * @public\n */\nexport function bucketsReduceItem(buckets, reducer = identity) {\n    invariant(buckets, \"buckets must be specified\");\n    return buckets.map((bucket) => bucketItemReduce(bucket, reducer));\n}\n//# sourceMappingURL=bucketArray.js.map","// (C) 2019-2022 GoodData Corporation\nimport isEmpty from \"lodash/isEmpty.js\";\nimport { anyAttribute, attributeIdentifier, idMatchAttribute, isAttribute, } from \"../attribute/index.js\";\nimport { anyMeasure, idMatchMeasure, isMeasure, isSimpleMeasure, measureIdentifier, } from \"../measure/index.js\";\nimport { isTotal } from \"../base/totals.js\";\nimport { invariant } from \"ts-invariant\";\nimport { modifySimpleMeasure } from \"../measure/factory.js\";\nimport isArray from \"lodash/isArray.js\";\nimport identity from \"lodash/identity.js\";\nimport findIndex from \"lodash/findIndex.js\";\nimport intersection from \"lodash/intersection.js\";\nimport stringify from \"json-stable-stringify\";\n/**\n * This predicate evaluates true for any bucket.\n *\n * @public\n */\nexport const anyBucket = (_) => true;\n/**\n * Factory function for predicates that will evaluate true if bucket's id is same as the provided id.\n *\n * @public\n */\nexport const idMatchBucket = (id) => (bucket) => bucket.localIdentifier === id;\n//\n// Type guards\n//\n/**\n * Type-guard testing whether the provided object is an instance of {@link IBucket}.\n *\n * @param obj - object to test\n * @public\n */\nexport function isBucket(obj) {\n    return (!isEmpty(obj) &&\n        obj.localIdentifier !== undefined &&\n        obj.items !== undefined);\n}\n//\n// Functions\n//\nconst AGGREGATION_KEYS = [\"Sum\", \"Count\", \"Avg\", \"Min\", \"Max\", \"Median\", \"Runsum\"];\nfunction getIdentifier(obj) {\n    if (isMeasure(obj)) {\n        return measureIdentifier(obj);\n    }\n    if (isAttribute(obj)) {\n        return attributeIdentifier(obj);\n    }\n    return undefined;\n}\nfunction getAttributeDisplayFormIdentifiers(obj) {\n    const result = [];\n    for (const objKey of Object.keys(obj)) {\n        const identifier = getIdentifier(obj[objKey]);\n        if (identifier) {\n            result.push({\n                [objKey]: identifier,\n            });\n        }\n    }\n    return result;\n}\n/**\n * Creates a new bucket with the provided id and all the specified content.\n *\n * @param localId - bucket identifier\n * @param content - items to put into the bucket; attributes, measures and/or totals\n * @returns always new instance\n * @public\n */\nexport function newBucket(localId, ...content) {\n    invariant(localId, \"local identifier must be specified\");\n    const items = [];\n    const totals = [];\n    (content !== null && content !== void 0 ? content : []).forEach((i) => {\n        if (!i) {\n            return;\n        }\n        const contentErrorMessage = `Contents of a bucket must be either attribute, measure or total.`;\n        if (isAttribute(i) || isMeasure(i)) {\n            items.push(i);\n        }\n        else if (isTotal(i)) {\n            totals.push(i);\n        }\n        else if (isArray(i)) {\n            invariant(false, `newBucket called with an array of length ${i.length} as one of the items for bucket ${localId}.` +\n                \"Please make sure that you are not trying to put an array of items into a bucket that only accepts single item.\");\n        }\n        else if (typeof i === \"object\") {\n            if (Object.keys(i).indexOf(\"Default\") > -1) {\n                const identifiers = getAttributeDisplayFormIdentifiers(i).map((identifier) => {\n                    const k = Object.keys(identifier)[0];\n                    const value = identifier[k];\n                    return `${k}: ${value}`;\n                });\n                invariant(false, `${contentErrorMessage} It looks like you used an attribute from generated metadata containing more than one display form. Use one of the following display forms instead: ${identifiers.join(\", \")}.`);\n            }\n            const keys = intersection(AGGREGATION_KEYS, Object.keys(i));\n            if (!isEmpty(keys)) {\n                const identifier = getIdentifier(i[keys[0]]);\n                invariant(false, `${contentErrorMessage} It looks like you used an object ${identifier} from generated metadata. You need to use one of the following aggregation functions instead: ${keys.join(\", \")}.`);\n            }\n            invariant(false, `${contentErrorMessage} Got unknown content object: ${stringify(i)}.`);\n        }\n        else {\n            invariant(false, `${contentErrorMessage} Got unsupported content of type ${typeof i}: ${i}.`);\n        }\n    });\n    const totalsProp = !isEmpty(totals) ? { totals } : {};\n    return Object.assign({ localIdentifier: localId, items }, totalsProp);\n}\n/**\n * Tests whether the provided bucket is empty = contains no items and no totals.\n *\n * @param bucket - bucket to test\n * @returns true if empty, false if not\n * @public\n */\nexport function bucketIsEmpty(bucket) {\n    invariant(bucket, \"bucket must be specified\");\n    return bucket.items.length === 0 && (!bucket.totals || bucket.totals.length === 0);\n}\n/**\n * Gets the index of the first attribute matching the provided predicate from the bucket.\n *\n * @remarks\n * If no predicate is provided, then the function defaults to anyAttribute predicate - meaning first found attribute\n * will be returned.\n *\n * This function also provides convenience to find attribute by its local identifier - if you pass predicate as\n * string the function will automatically create idMatchAttribute predicate.\n *\n * @param bucket - bucket to to search in\n * @param idOrFun - attribute identifier or instance of AttributePredicate; {@link anyAttribute} predicate is default\n * @returns -1 if no matching attribute is found\n * @public\n */\nexport function bucketAttributeIndex(bucket, idOrFun = anyAttribute) {\n    invariant(bucket, \"bucket must be specified\");\n    const predicate = typeof idOrFun === \"string\" ? idMatchAttribute(idOrFun) : idOrFun;\n    const compositeGuard = (obj) => {\n        return isAttribute(obj) && predicate(obj);\n    };\n    return findIndex(bucket.items, compositeGuard);\n}\n/**\n * Gets first attribute matching the provided predicate from the bucket.\n *\n * @remarks\n * If no predicate is provided, then the function defaults to anyAttribute predicate - meaning first found attribute\n * will be returned.\n *\n * This function also provides convenience to find attribute by its local identifier - if you pass predicate as\n * string the function will automatically create idMatchAttribute predicate.\n *\n * @param bucket - bucket to to search in\n * @param idOrFun - attribute identifier or instance of AttributePredicate; {@link anyAttribute} predicate is default\n * @returns undefined if no matching attribute is found\n * @public\n */\nexport function bucketAttribute(bucket, idOrFun = anyAttribute) {\n    const index = bucketAttributeIndex(bucket, idOrFun);\n    return index >= 0 ? bucket.items[index] : undefined;\n}\n/**\n * Gets all attributes matching the provided predicate from the bucket.\n *\n * @remarks\n * If no predicate is provided, then the function defaults to anyAttribute predicate - meaning all attributes\n * from the bucket will be returned.\n *\n * @param bucket - bucket to work with\n * @param predicate - attribute predicate; {@link anyAttribute} predicate is default\n * @returns empty list if none match\n * @public\n */\nexport function bucketAttributes(bucket, predicate = anyAttribute) {\n    invariant(bucket, \"bucket must be specified\");\n    // need custom type-guard so as not to break type inference in filter() method\n    const compositeGuard = (obj) => {\n        return isAttribute(obj) && predicate(obj);\n    };\n    return bucket.items.filter(compositeGuard);\n}\n/**\n * Gets the index of the first measure matching the provided predicate from the bucket.\n *\n * @remarks\n * If no predicate is provided, then the function defaults to anyMeasure predicate - meaning first found measure\n * will be returned.\n *\n * This function also provides convenience to find measure by its local identifier - if you pass predicate as\n * string the function will automatically create idMatchMeasure predicate.\n *\n * @param bucket - bucket to to search in\n * @param idOrFun - measure identifier or instance of MeasurePredicate; {@link anyMeasure} predicate is default\n * @returns -1 if no matching measure is found\n * @public\n */\nexport function bucketMeasureIndex(bucket, idOrFun = anyMeasure) {\n    invariant(bucket, \"bucket must be specified\");\n    const predicate = typeof idOrFun === \"string\" ? idMatchMeasure(idOrFun) : idOrFun;\n    const compositeGuard = (obj) => {\n        return isMeasure(obj) && predicate(obj);\n    };\n    return findIndex(bucket.items, compositeGuard);\n}\n/**\n * Gets first measure matching the provided predicate from the bucket.\n *\n * @remarks\n * If no predicate is provided, then the function defaults to anyMeasure predicate - meaning first found measure\n * will be returned.\n *\n * This function also provides convenience to find measure by its local identifier - if you pass predicate as\n * string the function will automatically create idMatchMeasure predicate.\n *\n * @param bucket - bucket to to search in\n * @param idOrFun - measure identifier or instance of MeasurePredicate; {@link anyMeasure} predicate is default\n * @returns undefined if no matching measure is found\n * @public\n */\nexport function bucketMeasure(bucket, idOrFun = anyMeasure) {\n    const index = bucketMeasureIndex(bucket, idOrFun);\n    return index >= 0 ? bucket.items[index] : undefined;\n}\n/**\n * Gets all measures matching the provided predicate from the bucket.\n *\n * @remarks\n * If no predicate is provided, then the function defaults to anyMeasure predicate - meaning all measures from\n * the bucket will be returned.\n *\n * @param bucket - bucket to work with\n * @param predicate - measure predicate; {@link anyMeasure} predicate is default\n * @returns empty list if none match\n * @public\n */\nexport function bucketMeasures(bucket, predicate = anyMeasure) {\n    invariant(bucket, \"bucket must be specified\");\n    // need custom type-guard so as not to break type inference in filter() method\n    const compositeGuard = (obj) => {\n        return isMeasure(obj) && predicate(obj);\n    };\n    return bucket.items.filter(compositeGuard);\n}\n/**\n * Gets all attributes and measures from the bucket.\n *\n * @param bucket - bucket to work with\n * @returns empty list if no items\n * @public\n */\nexport function bucketItems(bucket) {\n    invariant(bucket, \"bucket must be specified\");\n    return bucket.items;\n}\n/**\n * Gets all totals from the bucket\n *\n * @param bucket - bucket to work with\n * @returns empty list if no totals\n * @public\n */\nexport function bucketTotals(bucket) {\n    invariant(bucket, \"bucket must be specified\");\n    if (!bucket.totals) {\n        return [];\n    }\n    return bucket.totals;\n}\n/**\n * Gets a new bucket that 'inherits' all data from the provided bucket but has different totals.\n *\n * @remarks\n * New totals will be used in the new bucket as-is, no merging with existing totals.\n *\n * @param bucket - bucket to work with\n * @param totals - new totals to apply\n * @returns new bucket\n * @public\n */\nexport function bucketSetTotals(bucket, totals = []) {\n    invariant(bucket, \"bucket must be specified\");\n    return Object.assign(Object.assign({}, bucket), { totals });\n}\n/**\n * Defines possible compute ratio sanitization rules.\n *\n * @public\n */\nexport var ComputeRatioRule;\n(function (ComputeRatioRule) {\n    /**\n     * Compute ratio must not be used in any measure\n     */\n    ComputeRatioRule[ComputeRatioRule[\"NEVER\"] = 0] = \"NEVER\";\n    /**\n     * Compute ratio can be used if there is just a single measure\n     */\n    ComputeRatioRule[ComputeRatioRule[\"SINGLE_MEASURE_ONLY\"] = 1] = \"SINGLE_MEASURE_ONLY\";\n    /**\n     * Compute ratio can be used on any measure\n     */\n    ComputeRatioRule[ComputeRatioRule[\"ANY_MEASURE\"] = 2] = \"ANY_MEASURE\";\n})(ComputeRatioRule = ComputeRatioRule || (ComputeRatioRule = {}));\n/**\n * Applies compute ratio rule to all measures in a list.\n *\n * @remarks\n * This MAY be done to sanitize measure definitions so that the computed results make sense when visualized in a chart.\n *\n * The function will return a new list with updated measures according to the specified rule; see {@link ComputeRatioRule}.\n *\n * For convenience this function can work with list of measures AND attributes; attributes will be ignored\n * in processing and kept in resulting array as-is.\n *\n * @param items - list of attributes or measures to sanitize; attributes will be lef\n * @param rule - rule to apply; see {@link ComputeRatioRule}\n * @returns new list with modified measures; the original list and measures in it are left intact\n * @public\n */\nexport function applyRatioRule(items, rule = ComputeRatioRule.SINGLE_MEASURE_ONLY) {\n    invariant(items, \"items must be specified\");\n    if (rule === ComputeRatioRule.ANY_MEASURE) {\n        return items;\n    }\n    const numberOfMeasures = items.filter(isMeasure).length;\n    if (numberOfMeasures > 1 || rule === ComputeRatioRule.NEVER) {\n        return items.map(disableComputeRatio);\n    }\n    return items;\n}\n/**\n * Disables compute ratio if set on a simple measure. Does not do anything for other measures.\n *\n * @param item - maybe a simple measure where compute ratio should be disabled\n * @returns an instance of measure with compute ratio disabled\n * @public\n */\nexport function disableComputeRatio(item) {\n    if (isSimpleMeasure(item)) {\n        return modifySimpleMeasure(item, (m) => m.noRatio());\n    }\n    return item;\n}\n/**\n * Creates a new bucket by modifying items of the provided input bucket.\n *\n * @remarks\n * Each item from the input bucket will be dispatched to the modification function\n * and the result of the modification will be included in the new bucket.\n *\n * Note: it is valid for the modification function to just return the original item.\n * In that case the item will be included in the bucket without modification.\n *\n * @param bucket - bucket in which all items are applied the modification function\n * @param modifications - the modification to apply to the bucket items\n * @returns new instance of bucket with modified bucket items\n * @public\n */\nexport function bucketModifyItems(bucket, modifications = identity) {\n    invariant(bucket, \"bucket must be specified\");\n    const items = bucketItems(bucket);\n    return Object.assign(Object.assign({}, bucket), { items: items.map((bucketItem) => modifications(bucketItem)) });\n}\n/**\n * Creates a new bucket by modifying items of the provided input bucket.\n *\n * @remarks\n * Array of item from the input bucket will be dispatched to the reducer function\n * and the result of the modification will be included in the new bucket.\n *\n *\n * @param bucket - bucket in which all items are applied the modification function\n * @param reducer - the reducer function to apply to the bucket items\n * @returns new instance of bucket with modified bucket items\n * @public\n */\nexport function bucketItemReduce(bucket, reducer = identity) {\n    invariant(bucket, \"bucket must be specified\");\n    const items = bucketItems(bucket);\n    const result = items.reduce((acc, cur, idx, src) => {\n        return reducer(acc, cur, idx, src);\n    }, []);\n    return Object.assign(Object.assign({}, bucket), { items: result });\n}\n//# sourceMappingURL=index.js.map","// (C) 2021 GoodData Corporation\nimport groupBy from \"lodash/groupBy.js\";\nimport toPairs from \"lodash/toPairs.js\";\nimport { invariant } from \"ts-invariant\";\nimport { attributeLocalId, isAttribute } from \"../attribute/index.js\";\nimport { measureLocalId } from \"../measure/index.js\";\n/**\n * Validates the {@link IExecutionDefinition} instance and throws if it is invalid.\n * @param definition - the definition to validate\n * @internal\n */\nexport function defValidate(definition) {\n    const itemsWithLocalId = [...definition.attributes, ...definition.measures];\n    const groups = groupBy(itemsWithLocalId, (item) => isAttribute(item) ? attributeLocalId(item) : measureLocalId(item));\n    toPairs(groups).forEach(([localId, items]) => {\n        invariant(items.length === 1, `There are ${items.length} items with the same localId '${localId}'. Please make sure the attributes and measures in the execution definition have unique localIds.`);\n    });\n}\n//# sourceMappingURL=validation.js.map","// (C) 2019-2022 GoodData Corporation\nimport { isAttribute } from \"../attribute/index.js\";\nimport { isDimension, MeasureGroupIdentifier, newDimension, newTwoDimensional, } from \"../base/dimension.js\";\nimport { bucketAttributes, bucketMeasures } from \"../buckets/index.js\";\nimport { bucketsAttributes, bucketsIsEmpty, bucketsMeasures } from \"../buckets/bucketArray.js\";\nimport { insightBuckets, insightFilters, insightSorts } from \"../../insight/index.js\";\nimport { isMeasure } from \"../measure/index.js\";\nimport { defSetDimensions, defSetPostProcessing, defSetSorts, defWithFilters, defSetExecConfig, } from \"./index.js\";\nimport isEmpty from \"lodash/isEmpty.js\";\nimport { invariant } from \"ts-invariant\";\nimport { defValidate } from \"./validation.js\";\n/**\n * Creates new, empty execution definition for the provided workspace.\n *\n * @param workspace - workspace to calculate on\n * @returns always new instance\n * @public\n */\nexport function emptyDef(workspace) {\n    return {\n        workspace,\n        buckets: [],\n        attributes: [],\n        measures: [],\n        dimensions: [],\n        filters: [],\n        sortBy: [],\n        postProcessing: {},\n    };\n}\n/**\n * Prepares a new execution definition for a list of attributes and measures, filtered using the\n * provided filters.\n *\n * @remarks\n * This function MUST be used to implement IExecutionFactory.forItems();\n *\n * @param workspace - workspace to execute against, must not be empty\n * @param items - list of attributes and measures, must not be empty\n * @param filters - list of filters, may not be provided\n * @public\n */\nexport function newDefForItems(workspace, items, filters = []) {\n    invariant(workspace, \"workspace to create exec def for must be specified\");\n    invariant(items, \"items to create exec def from must be specified\");\n    const def = Object.assign(Object.assign({}, emptyDef(workspace)), { attributes: items.filter(isAttribute), measures: items.filter(isMeasure) });\n    defValidate(def);\n    return defWithFilters(def, filters);\n}\n/**\n * Prepares a new execution definition for a list of buckets.\n *\n * @remarks\n * Attributes and measures WILL be transferred to the execution in natural order:\n *\n * - Order of items within a bucket is retained in the execution\n * - Items from first bucket appear before items from second bucket\n *\n * Or more specifically, given two buckets with items as [A1, A2, M1] and [A3, M2, M3], the resulting\n * prepared execution WILL have definition with attributes = [A1, A2, A3] and measures = [M1, M2, M3]\n *\n * This function MUST be used to implement IExecutionFactory.forBuckets();\n *\n * @param workspace - workspace to execute against, must not be empty\n * @param buckets - list of buckets with attributes and measures, must be non empty, must have at least one attr or measure\n * @param filters - optional, may not be provided\n * @public\n */\nexport function newDefForBuckets(workspace, buckets, filters = []) {\n    invariant(workspace, \"workspace to create exec def for must be specified\");\n    invariant(buckets, \"buckets to create exec def from must be specified\");\n    const def = Object.assign(Object.assign({}, emptyDef(workspace)), { buckets, attributes: bucketsAttributes(buckets), measures: bucketsMeasures(buckets) });\n    defValidate(def);\n    return defWithFilters(def, filters);\n}\n/**\n * Prepares a new execution definition for the provided insight.\n *\n * @remarks\n * Buckets with attributes and measures WILL be used\n * to obtain attributes and measures - the behavior WILL be same as in forBuckets() function. Filters, sort by\n * and totals in the insight WILL be included in the prepared execution.\n *\n * Additionally, an optional list of additional filters WILL be merged with the filters already defined in\n * the insight.\n *\n * - Attributes and measures from insight's buckets are distributed into definition attributes and measures\n *   in natural order.\n * - Insight filters are added into definition\n * - Insight sorts are added into definition\n * - Insight totals are added into definition\n *\n * This function MUST be used to implement IExecutionFactory.forInsight();\n *\n * @param workspace - workspace to execute against, must not be empty\n * @param insight - insight to create execution for, must have buckets which must have some attributes or measures in them\n * @param filters - optional, may not be provided\n * @public\n */\nexport function newDefForInsight(workspace, insight, filters = []) {\n    invariant(workspace, \"workspace to create exec def for must be specified\");\n    invariant(insight, \"insight to create exec def from must be specified\");\n    const def = newDefForBuckets(workspace, insightBuckets(insight));\n    defValidate(def);\n    const extraFilters = filters ? filters : [];\n    const filteredDef = defWithFilters(def, [...insightFilters(insight), ...extraFilters]);\n    return defSetSorts(filteredDef, insightSorts(insight));\n}\n/**\n * Changes sorting in the definition. Any sorting settings accumulated so far WILL be wiped out.\n *\n * @remarks\n * This function MUST be used to implement IPreparedExecution.withSorting();\n *\n * @param definition - definition to alter with sorting\n * @param sorts - items to sort by\n * @returns new execution with the updated sorts\n * @public\n */\nexport function defWithSorting(definition, sorts) {\n    return defSetSorts(definition, sorts);\n}\n/**\n * Changes additional execution configuration in the definition.\n *\n * @remarks\n * Any additional execution configuration settings accumulated so far WILL be wiped out.\n *\n * This function MUST be used to implement IPreparedExecution.withExecConfig();\n *\n * @param definition - definition to alter with execution config\n * @param config - configuration\n * @returns new execution with the updated sorts\n * @public\n */\nexport function defWithExecConfig(definition, config) {\n    return defSetExecConfig(definition, config);\n}\n/**\n * Changes the postProcessing of a definition.\n *\n * @param definition - execution definition to alter with postProcessing\n * @param postProcessing - configuration that should be done with the data after they are obtained from the server\n *  and before they are passed to the user\n * @returns new execution with the specified postProcessing\n * @public\n */\nexport function defWithPostProcessing(definition, postProcessing) {\n    return defSetPostProcessing(definition, postProcessing);\n}\n/**\n * Changes the dateFormat of a postProcessing, other properties of postProcessing (if any) remain unchanged.\n *\n * @remarks\n * This function will call defWithPostProcessing to update definition with the new postProcessing.\n *\n * This function MUST be used to implement IPreparedExecution.withDateFormat();\n *\n * @param definition - execution definition to alter with postProcessing\n * @param dateFormat - Format to be applied to the dates in an AFM execution response.\n * @returns new execution with postProcessing updated with the specified dateFormat\n * @public\n */\nexport function defWithDateFormat(definition, dateFormat) {\n    const currentPostProcessing = definition.postProcessing || {};\n    const postProcessing = Object.assign(Object.assign({}, currentPostProcessing), { dateFormat });\n    return defWithPostProcessing(definition, postProcessing);\n}\n/**\n * Configures dimensions in the exec definition.\n *\n * @remarks\n * Any dimension settings accumulated so far WILL be wiped out.\n * If dims is array if dimensions, they will be used as is. If it is an array whose first element is dimension\n * generation function, then the function will be called to obtain dimensions.\n *\n * This function MUST be used to implement IPreparedExecution.withDimensions(); its parameters are constructed in\n * a way that it can handle both signatures of the withDimensions().\n *\n * @param definition - execution definition to alter\n * @param dims - dimensions to set\n * @returns new execution with the updated dimensions\n * @public\n */\nexport function defWithDimensions(definition, ...dims) {\n    return defSetDimensions(definition, toDimensions(dims, definition));\n}\nfunction toDimensions(dimsOrGen, def) {\n    if (!dimsOrGen || isEmpty(dimsOrGen)) {\n        return [];\n    }\n    const maybeGenerator = dimsOrGen[0];\n    if (typeof maybeGenerator === \"function\") {\n        return maybeGenerator(def);\n    }\n    return dimsOrGen.filter(isDimension);\n}\nfunction defaultDimensionsWithBuckets(buckets) {\n    const [firstBucket, ...otherBuckets] = buckets;\n    if (bucketsIsEmpty(otherBuckets)) {\n        if (bucketMeasures(firstBucket).length) {\n            return newTwoDimensional([MeasureGroupIdentifier], bucketAttributes(firstBucket));\n        }\n        return [newDimension(bucketAttributes(firstBucket))];\n    }\n    const firstDim = bucketAttributes(firstBucket);\n    const secondDim = bucketsAttributes(otherBuckets);\n    return bucketMeasures(firstBucket).length\n        ? newTwoDimensional([...firstDim, MeasureGroupIdentifier], secondDim)\n        : newTwoDimensional(firstDim, [...secondDim, MeasureGroupIdentifier]);\n}\nfunction defaultDimensionsWithoutBuckets(definition) {\n    if (definition.measures.length) {\n        return newTwoDimensional([MeasureGroupIdentifier], definition.attributes);\n    }\n    return [newDimension(definition.attributes)];\n}\n/**\n * Default dimension generator for execution definition behaves as follows:\n *\n * @remarks\n * - If the definition was created WITHOUT 'buckets', then:\n *   - If there are no measures specified, then single dimension will be returned and will contain all attributes\n *   - If there are measures, then two dimensions will be returned; measureGroup will be in the first dimension\n *     and all attributes in the second dimension\n *\n * If the definition was created WITH 'buckets' then:\n *   - If there is just one bucket and it contains only attributes, then single dimension with all attributes will be returned\n *   - If there is just one bucket and it contains both attributes and measures, then two dimensions will be returned:\n *     measureGroup will be in first dimension, all other attributes in the second dimension\n *   - If there are multiple buckets, then all attributes from first bucket will be in first dimension and all attributes\n *     from other buckets in the second dimension. If the first bucket contains measure(s), then the MeasureGroup will\n *     be in first dimension. Otherwise it will be in second dimension.\n *\n * @param definition - execution definition to get dims for\n * @public\n */\nexport function defaultDimensionsGenerator(definition) {\n    invariant(definition, \"definition must be specified\");\n    const buckets = definition.buckets;\n    return !bucketsIsEmpty(buckets)\n        ? defaultDimensionsWithBuckets(buckets)\n        : defaultDimensionsWithoutBuckets(definition);\n}\n//# sourceMappingURL=factory.js.map","// (C) 2020 GoodData Corporation\nimport stringify from \"json-stable-stringify\";\nimport { attributeElementsIsEmpty, isMeasureValueFilter, isNegativeAttributeFilter, } from \"./index.js\";\n/**\n * Determines if a filter has a semantic effect and thus must be taken into account when computing fingerprints.\n *\n * Irrelevant filters are:\n *\n * -  Measure Value filter with no condition specified\n * -  Negative attribute filter with empty 'notIn' field\n *\n * Note: the ALL_TIME date filter is not treated this way on purpose.\n *\n * @internal\n */\nexport function isFilterRelevantForFingerprinting(filter) {\n    if (isMeasureValueFilter(filter)) {\n        return !!filter.measureValueFilter.condition;\n    }\n    else if (isNegativeAttributeFilter(filter)) {\n        return !attributeElementsIsEmpty(filter.negativeAttributeFilter.notIn);\n    }\n    return true;\n}\n/**\n * Calculates filter fingerprint; ensures that filters that have semantically no effect result in no fingerprint.\n *\n * @remarks see {@link isFilterRelevantForFingerprinting} for information on which filters are considered irrelevant.\n *\n * @internal\n */\nexport function filterFingerprint(filter) {\n    return isFilterRelevantForFingerprinting(filter) ? stringify(filter) : undefined;\n}\n//# sourceMappingURL=fingerprint.js.map","// (C) 2019-2020 GoodData Corporation\nimport stringify from \"json-stable-stringify\";\nimport { isSimpleMeasure } from \"./index.js\";\nimport merge from \"lodash/merge.js\";\nimport { isFilterRelevantForFingerprinting } from \"../filter/fingerprint.js\";\nfunction simpleMeasureFingerprint(measure) {\n    var _a;\n    const { measureDefinition } = measure.measure.definition;\n    const measureDefinitionWithSanitizedFilters = Object.assign(Object.assign({}, measureDefinition), { filters: (_a = measureDefinition.filters) === null || _a === void 0 ? void 0 : _a.filter(isFilterRelevantForFingerprinting) });\n    const measureDefinitionDefaults = {\n        filters: [],\n        computeRatio: false,\n    };\n    const measureDefinitionWithDefaults = merge(measureDefinitionDefaults, measureDefinitionWithSanitizedFilters);\n    return stringify({\n        measure: Object.assign(Object.assign({}, measure.measure), { definition: {\n                measureDefinition: measureDefinitionWithDefaults,\n            } }),\n    });\n}\n/**\n * Calculates dimension fingerprint; ensures that the optional vs default values are correctly reflected in\n * the fingerprint.\n *\n * @internal\n */\nexport function measureFingerprint(measure) {\n    if (isSimpleMeasure(measure)) {\n        /*\n         * Simple measure has a few optional properties, which, when not provided default to specific\n         * values (aggregation, computeRatio etc).\n         *\n         * Fingerprinting simple measure thus requires normalization of the definition so that measure with\n         * optional props not specified has same fingerprint as measure with optional props specified to default\n         * values.\n         */\n        return simpleMeasureFingerprint(measure);\n    }\n    return stringify(measure);\n}\n//# sourceMappingURL=fingerprint.js.map","// (C) 2019-2021 GoodData Corporation\nimport stringify from \"json-stable-stringify\";\nimport { invariant } from \"ts-invariant\";\n/**\n * @internal\n */\nexport function attributeFingerprint(attribute) {\n    invariant(attribute, \"attribute must not be undefined\");\n    return stringify(attribute);\n}\n/**\n * @internal\n */\nexport function sortFingerprint(sort) {\n    return stringify(sort);\n}\n/**\n * @internal\n */\nexport function dataSamplingFingerprint(dataSamplingPercentage) {\n    // Since data sampling is optional, we will have to handle undefined by returning a string\n    return dataSamplingPercentage ? dataSamplingPercentage.toString() : \"undefined\";\n}\n//# sourceMappingURL=fingerprints.js.map","// (C) 2019-2020 GoodData Corporation\nimport stringify from \"json-stable-stringify\";\nimport merge from \"lodash/merge.js\";\n/**\n * Calculates dimension fingerprint; ensures that the optional vs default values are correctly reflected in\n * the fingerprint.\n *\n * @internal\n */\nexport function dimensionFingerprint(dim) {\n    const dimDefaults = {\n        totals: [],\n    };\n    const withDefaultTotals = merge(dimDefaults, dim);\n    return stringify(withDefaultTotals);\n}\n//# sourceMappingURL=fingerprint.js.map","// (C) 2019-2022 GoodData Corporation\nimport isEmpty from \"lodash/isEmpty.js\";\nimport isString from \"lodash/isString.js\";\nimport SparkMD5 from \"spark-md5\";\nimport { invariant } from \"ts-invariant\";\nimport { dimensionTotals } from \"../base/dimension.js\";\nimport { mergeFilters } from \"../filter/filterMerge.js\";\nimport { measureFingerprint } from \"../measure/fingerprint.js\";\nimport { attributeFingerprint, dataSamplingFingerprint, sortFingerprint } from \"./fingerprints.js\";\nimport { dimensionFingerprint } from \"../base/fingerprint.js\";\nimport { filterFingerprint } from \"../filter/fingerprint.js\";\n/**\n * Creates new execution definition by merging new filters into an existing definition.\n *\n * @param def - existing definition\n * @param filters - array of filters to add to definition\n * @returns always new instance\n * @public\n */\nexport function defWithFilters(def, filters = []) {\n    invariant(def, \"execution definition to add more filters to must be defined\");\n    if (isEmpty(filters)) {\n        return def;\n    }\n    return Object.assign(Object.assign({}, def), { filters: mergeFilters(def.filters, filters) });\n}\n/**\n * Creates new execution definition by merging new sort items into an existing definition.\n *\n * @param def - existing definition\n * @param sortBy - array of sort items to add to definition\n * @returns always new instance\n * @public\n */\nexport function defSetSorts(def, sortBy = []) {\n    invariant(def, \"execution definition to set sorts in must be defined\");\n    return Object.assign(Object.assign({}, def), { sortBy });\n}\n/**\n * Creates new execution definition by merging new exection configuration into an existing definition.\n *\n * @param def - existing definition\n * @param config - execution configuration\n * @returns always new instance\n * @public\n */\nexport function defSetExecConfig(def, config) {\n    invariant(def, \"execution definition to set execution config in must be defined\");\n    return Object.assign(Object.assign({}, def), { executionConfig: config });\n}\n/**\n * Creates new execution definition by setting a new post processing.\n *\n * @param def - existing definition\n * @param postProcessing - configuration that should be done with the data after they are obtained from the server\n *  and before they are passed to the user\n * @returns always new instance\n * @public\n */\nexport function defSetPostProcessing(def, postProcessing) {\n    invariant(def, \"execution definition to set post processing in must be defined\");\n    return Object.assign(Object.assign({}, def), { postProcessing });\n}\n/**\n * Gets totals from particular dimension in the provided execution definition.\n *\n * @param def - definition to get totals from\n * @param dimIdx - dimension index\n * @returns empty list if no definition or dimension with the provided index not defined or if there are no\n *  totals in the dimension\n * @public\n */\nexport function defTotals(def, dimIdx) {\n    invariant(def, \"execution definition to get totals for must be defined\");\n    if (!def.dimensions[dimIdx]) {\n        return [];\n    }\n    return dimensionTotals(def.dimensions[dimIdx]);\n}\n/**\n * Creates new execution definition by slapping the provided dimensions on top of the definition.\n *\n * @param def - existing definition\n * @param dimensions - dimensions\n * @returns always new instance\n * @public\n */\nexport function defSetDimensions(def, dimensions = []) {\n    invariant(def, \"execution definition to set dimension for must be defined\");\n    return Object.assign(Object.assign({}, def), { dimensions });\n}\n/**\n * Calculates fingerprint for the execution definition.\n *\n * @remarks\n * Fingerprinting is used as an _approximate_,\n * quick, first-level assessment whether two execution definitions are or are not effectively same = they\n * lead to the same computation on the backend.\n *\n * The contract and the approximate nature of the fingerprint can be described as follows:\n *\n * -  If two execution definitions have the same fingerprint, then they definitely are effectively the same\n *    from the result calculation point of view and the backend will perform the same computation for them.\n *\n * -  If two execution definition have different fingerprint, they MAY OR MAY NOT lead to different execution. Or\n *    more concrete: two executions with two different fingerprints MAY lead to the same execution and same results.\n *\n * While not optimal, this contract allows for safe usage of fingerprints to determine whether two\n * execution definitions have changed. For instance it can be used in React lifecycle methods (shouldComponentUpdate)\n * or for client-side caching.\n *\n * @param def - execution definition\n * @public\n */\nexport function defFingerprint(def) {\n    var _a, _b;\n    invariant(def, \"execution definition to calculate fingerprint for must be defined\");\n    const hasher = new SparkMD5();\n    /*\n     * Simple approach to construct exec definition fingerprint; the main drawback is that it completely\n     * disregards that ordering of some array elements does not impact the results of the actual execution.\n     *\n     * - attributes, measures, filters, sortby and totals should be sorted first and then fingerprinted.\n     * - dimensions must be fingerprinted in the defined order\n     *\n     * This simple approach can lead to 'false negatives' => code says executions are different while in\n     * fact are the same. This does not lead to functional issues as the bear can deal with that and will\n     * reuse cached and all. The only drawback is frontend cache misses.\n     */\n    const hashFun = hasher.append.bind(hasher);\n    hasher.append(def.workspace);\n    def.attributes.map(attributeFingerprint).forEach(hashFun);\n    def.measures.map(measureFingerprint).forEach(hashFun);\n    def.filters.map(filterFingerprint).filter(isString).forEach(hashFun);\n    def.sortBy.map(sortFingerprint).forEach(hashFun);\n    def.dimensions.map(dimensionFingerprint).forEach(hashFun);\n    if ((_a = def.executionConfig) === null || _a === void 0 ? void 0 : _a.dataSamplingPercentage) {\n        hashFun(dataSamplingFingerprint((_b = def.executionConfig) === null || _b === void 0 ? void 0 : _b.dataSamplingPercentage));\n    }\n    return hasher.end();\n}\n//# sourceMappingURL=index.js.map","// (C) 2019-2021 GoodData Corporation\nimport { objRefToString } from \"../../objRef/index.js\";\nimport { isAttributeFilter, isDateFilter, filterObjRef, isAllTimeDateFilter, isMeasureValueFilter, isRankingFilter, } from \"./index.js\";\nimport compact from \"lodash/compact.js\";\nimport groupBy from \"lodash/groupBy.js\";\nimport last from \"lodash/last.js\";\nimport { invariant } from \"ts-invariant\";\nimport values from \"lodash/values.js\";\nfunction separateFiltersByType(filters) {\n    const result = {\n        attribute: [],\n        date: [],\n        measureValue: [],\n        ranking: [],\n    };\n    filters.forEach((f) => {\n        if (isAttributeFilter(f)) {\n            result.attribute.push(f);\n        }\n        else if (isDateFilter(f)) {\n            result.date.push(f);\n        }\n        else if (isMeasureValueFilter(f)) {\n            result.measureValue.push(f);\n        }\n        else if (isRankingFilter(f)) {\n            result.ranking.push(f);\n        }\n        invariant(f, \"filter is not supported\");\n    });\n    return result;\n}\n/**\n * Merges two sets of filters.\n *\n * - Attribute filters and ranking filters from both sets are simply concatenated resulting\n *   in the filters being ANDed together.\n * - Date filters are merged based on date data set they filter on\n *   - For Date filters for the same date data set:\n *     - the filters are ordered putting original filters first\n *     - the last filter in this ordering is taken\n *        - if it is All time, all filters for the dimension are cleared\n *        - else the last filter is used\n * - Measure value filters are merged so that there is at most one Measure value filter per measure\n *   (the last one specified is used). This is to prevent errors with more than one Measure value filter\n *   on the same measure which is not supported.\n *\n * @remarks\n * It is the responsibility of the caller to make sure all the filters use the same ObjRef type so that\n * they can be compared without involving the backend. Otherwise, the results might be unexpected\n * (especially for date filters).\n *\n * There is also a function in backend insights service called getInsightWithAddedFilters that can help you\n * do this that takes care of the ObjRef normalization.\n *\n * @param originalFilters - original filters to merge with\n * @param addedFilters - new filters to add on top of original\n * @internal\n */\nexport function mergeFilters(originalFilters, addedFilters) {\n    invariant(originalFilters, \"original filters must be specified\");\n    const filtersToMerge = compact(addedFilters !== null && addedFilters !== void 0 ? addedFilters : []);\n    if (!filtersToMerge.length) {\n        return originalFilters;\n    }\n    if (!originalFilters.length) {\n        return filtersToMerge.filter((f) => !isAllTimeDateFilter(f));\n    }\n    const original = separateFiltersByType(originalFilters);\n    const added = separateFiltersByType(filtersToMerge);\n    // concat attribute filters\n    const attributeFilters = [...original.attribute, ...added.attribute];\n    // merge date filters by date dataset qualifier\n    const dateFilters = mergeDateFilters(original.date, added.date);\n    // merge measure value filters by measure\n    const measureValueFilters = mergeMeasureValueFilters(original.measureValue, added.measureValue);\n    // concat ranking filters\n    const rankingFilters = [...original.ranking, ...added.ranking];\n    return [...attributeFilters, ...dateFilters, ...measureValueFilters, ...rankingFilters];\n}\nfunction mergeDateFilters(originalFilters, addedFilters) {\n    const allFilters = [...originalFilters, ...addedFilters];\n    const grouped = groupBy(allFilters, (f) => objRefToString(filterObjRef(f)));\n    const mergedFilters = [];\n    values(grouped).forEach((filtersForDimension) => {\n        // use the last filter for the dimension specified.\n        // this makes sure that the added filter wins if it is specified\n        const lastFilterForDimension = last(filtersForDimension);\n        // if the last filter is all time, clear filters for this dimension, otherwise use the last filter\n        if (!isAllTimeDateFilter(lastFilterForDimension)) {\n            mergedFilters.push(lastFilterForDimension);\n        }\n    });\n    return mergedFilters;\n}\nfunction mergeMeasureValueFilters(originalFilters, addedFilters) {\n    const allFilters = [...originalFilters, ...addedFilters];\n    const grouped = groupBy(allFilters, (f) => objRefToString(f.measureValueFilter.measure));\n    return values(grouped).map((filters) => last(filters));\n}\n//# sourceMappingURL=filterMerge.js.map","// (C) 2019-2023 GoodData Corporation\nimport isEmpty from \"lodash/isEmpty.js\";\nimport { invariant } from \"ts-invariant\";\n//\n// Type guards\n//\n/**\n * Type guard checking whether the provided object is a positive attribute filter.\n *\n * @public\n */\nexport function isPositiveAttributeFilter(obj) {\n    return !isEmpty(obj) && obj.positiveAttributeFilter !== undefined;\n}\n/**\n * Type guard checking whether the provided object is a negative attribute filter.\n *\n * @public\n */\nexport function isNegativeAttributeFilter(obj) {\n    return !isEmpty(obj) && obj.negativeAttributeFilter !== undefined;\n}\n/**\n * Type guard checking whether the provided object is an absolute date filter.\n *\n * @public\n */\nexport function isAbsoluteDateFilter(obj) {\n    return !isEmpty(obj) && obj.absoluteDateFilter !== undefined;\n}\n/**\n * Type guard checking whether the provided object is a relative date filter.\n *\n * @public\n */\nexport function isRelativeDateFilter(obj) {\n    return !isEmpty(obj) && obj.relativeDateFilter !== undefined;\n}\n/**\n * Type guard checking whether the provided object is an all time date filter.\n *\n * @public\n */\nexport function isAllTimeDateFilter(obj) {\n    var _a;\n    return (!isEmpty(obj) &&\n        ((_a = obj.relativeDateFilter) === null || _a === void 0 ? void 0 : _a.granularity) === \"ALL_TIME_GRANULARITY\");\n}\n/**\n * Type guard checking whether the provided object is an attribute filter.\n *\n * @public\n */\nexport function isAttributeFilter(obj) {\n    return isPositiveAttributeFilter(obj) || isNegativeAttributeFilter(obj);\n}\n/**\n * Type guard checking whether the provided object is a date filter.\n *\n * @public\n */\nexport function isDateFilter(obj) {\n    return isRelativeDateFilter(obj) || isAbsoluteDateFilter(obj);\n}\n/**\n * Type guard checking whether the provided object is a measure value filter.\n *\n * @public\n */\nexport function isMeasureValueFilter(obj) {\n    return !isEmpty(obj) && obj.measureValueFilter !== undefined;\n}\n/**\n * Type guard checking whether the provided object is a ranking filter.\n *\n * @public\n */\nexport function isRankingFilter(obj) {\n    return !isEmpty(obj) && obj.rankingFilter !== undefined;\n}\n/**\n * Type guard checking whether the provided object is a filter.\n *\n * @public\n */\nexport function isFilter(obj) {\n    return isDateFilter(obj) || isAttributeFilter(obj) || isMeasureValueFilter(obj) || isRankingFilter(obj);\n}\n/**\n * Type guard checking whether the provided object is a measure value filter's comparison condition.\n *\n * @public\n */\nexport function isComparisonCondition(obj) {\n    return !isEmpty(obj) && obj.comparison !== undefined;\n}\n/**\n * Type guard checking whether the provided operator is a measure value filter's comparison operator.\n *\n * @public\n */\nexport function isComparisonConditionOperator(obj) {\n    return (obj === \"GREATER_THAN\" ||\n        obj === \"GREATER_THAN_OR_EQUAL_TO\" ||\n        obj === \"LESS_THAN\" ||\n        obj === \"LESS_THAN_OR_EQUAL_TO\" ||\n        obj === \"EQUAL_TO\" ||\n        obj === \"NOT_EQUAL_TO\");\n}\n/**\n * Type guard checking whether the provided object is a measure value filter's range condition.\n *\n * @public\n */\nexport function isRangeCondition(obj) {\n    return !isEmpty(obj) && obj.range !== undefined;\n}\n/**\n * Type guard checking whether the provided object is a measure value filter's range condition operator.\n *\n * @public\n */\nexport function isRangeConditionOperator(obj) {\n    return obj === \"BETWEEN\" || obj === \"NOT_BETWEEN\";\n}\n/**\n * Type guard checking whether the provided object is list of attribute elements specified by URI reference.\n *\n * @public\n */\nexport function isAttributeElementsByRef(obj) {\n    return !isEmpty(obj) && obj.uris !== undefined;\n}\n/**\n * Type guard checking whether the provided object is list of attribute elements specified by their text value.\n *\n * @public\n */\nexport function isAttributeElementsByValue(obj) {\n    return !isEmpty(obj) && obj.values !== undefined;\n}\n//\n// Functions\n//\n/**\n * Tests whether the provided attribute element does not specify any attribute elements.\n *\n * @param filter - attribute filter to test\n * @returns true if empty = no attribute elements\n * @public\n */\nexport function filterIsEmpty(filter) {\n    invariant(filter, \"filter must be specified\");\n    if (isPositiveAttributeFilter(filter)) {\n        return attributeElementsIsEmpty(filter.positiveAttributeFilter.in);\n    }\n    return attributeElementsIsEmpty(filter.negativeAttributeFilter.notIn);\n}\n/**\n * Tests whether the attribute elements object is empty.\n *\n * @param attributeElements - object to test\n * @returns true if empty = attribute elements not specified in any way (URI or value)\n * @internal\n */\nexport function attributeElementsIsEmpty(attributeElements) {\n    invariant(attributeElements, \"attribute elements must be specified\");\n    if (isAttributeElementsByRef(attributeElements)) {\n        return isEmpty(attributeElements.uris);\n    }\n    return isEmpty(attributeElements.values);\n}\n/**\n * Gets the number of items in the {@link IAttributeElements}.\n *\n * @param attributeElements - object to test\n * @returns the number of items\n * @internal\n */\nexport function attributeElementsCount(attributeElements) {\n    invariant(attributeElements, \"attribute elements must be specified\");\n    if (isAttributeElementsByRef(attributeElements)) {\n        return attributeElements.uris.length;\n    }\n    return attributeElements.values.length;\n}\n/**\n * Gets the items from the {@link IAttributeElements}.\n *\n * @param attributeElements - object to get items from\n * @returns the array of items\n * @internal\n */\nexport function getAttributeElementsItems(attributeElements) {\n    invariant(attributeElements, \"attribute elements must be specified\");\n    if (isAttributeElementsByRef(attributeElements)) {\n        return attributeElements.uris;\n    }\n    return attributeElements.values;\n}\n/**\n * Updates the items in the {@link IAttributeElements}.\n *\n * @param attributeElements - object to update items in\n * @param newItems - new items to put into attributeElements\n * @returns updated attributeElements object with new item values\n * @internal\n */\nexport function updateAttributeElementsItems(attributeElements, newItems) {\n    invariant(attributeElements, \"attribute elements must be specified\");\n    if (isAttributeElementsByRef(attributeElements)) {\n        return Object.assign(Object.assign({}, attributeElements), { uris: newItems });\n    }\n    return Object.assign(Object.assign({}, attributeElements), { values: newItems });\n}\nexport function filterAttributeElements(filter) {\n    invariant(filter, \"attribute elements must be specified\");\n    if (!isAttributeFilter(filter)) {\n        return undefined;\n    }\n    return isPositiveAttributeFilter(filter)\n        ? filter.positiveAttributeFilter.in\n        : filter.negativeAttributeFilter.notIn;\n}\nexport function filterObjRef(filter) {\n    invariant(filter, \"filter must be specified\");\n    if (isPositiveAttributeFilter(filter)) {\n        return filter.positiveAttributeFilter.displayForm;\n    }\n    if (isNegativeAttributeFilter(filter)) {\n        return filter.negativeAttributeFilter.displayForm;\n    }\n    if (isAbsoluteDateFilter(filter)) {\n        return filter.absoluteDateFilter.dataSet;\n    }\n    if (isRelativeDateFilter(filter)) {\n        return filter.relativeDateFilter.dataSet;\n    }\n    return undefined;\n}\n/**\n * Gets reference to a measure being used for filtering if the provided filter is measure based. For other filters return undefined.\n *\n * @public\n */\nexport function filterMeasureRef(filter) {\n    return isRankingFilter(filter)\n        ? filter.rankingFilter.measure\n        : isMeasureValueFilter(filter)\n            ? filter.measureValueFilter.measure\n            : undefined;\n}\n/**\n * Gets effective values of an absolute date filter.\n *\n * @param filter - date filter to work with\n * @returns filter values\n * @public\n */\nexport function absoluteDateFilterValues(filter) {\n    invariant(filter, \"filter must be specified\");\n    return {\n        from: filter.absoluteDateFilter.from,\n        to: filter.absoluteDateFilter.to,\n    };\n}\n/**\n * Gets effective values of a relative date filter.\n *\n * @param filter - date filter to work with\n * @returns filter values\n * @public\n */\nexport function relativeDateFilterValues(filter) {\n    invariant(filter, \"filter must be specified\");\n    return {\n        from: filter.relativeDateFilter.from,\n        to: filter.relativeDateFilter.to,\n        granularity: filter.relativeDateFilter.granularity,\n    };\n}\n/**\n * Gets measure value filter measure.\n * @param filter - measure value filter to work with\n * @returns filter measure\n * @public\n */\nexport function measureValueFilterMeasure(filter) {\n    invariant(filter, \"filter must be specified\");\n    return filter.measureValueFilter.measure;\n}\n/**\n * Gets measure value filter condition.\n * @param filter - measure value filter to work with\n * @returns filter condition\n * @public\n */\nexport function measureValueFilterCondition(filter) {\n    invariant(filter, \"filter must be specified\");\n    return filter.measureValueFilter.condition;\n}\n/**\n * Gets operator used in measure value filter condition.\n *\n * @param filter - filter to get operator from\n * @returns undefined if no condition in the filter\n * @public\n */\nexport function measureValueFilterOperator(filter) {\n    invariant(filter, \"filter must be specified\");\n    if (isComparisonCondition(filter.measureValueFilter.condition)) {\n        return filter.measureValueFilter.condition.comparison.operator;\n    }\n    else if (isRangeCondition(filter.measureValueFilter.condition)) {\n        return filter.measureValueFilter.condition.range.operator;\n    }\n    return undefined;\n}\n//# sourceMappingURL=index.js.map","// (C) 2019-2022 GoodData Corporation\nimport cloneDeep from \"lodash/cloneDeep.js\";\nimport isEmpty from \"lodash/isEmpty.js\";\nimport identity from \"lodash/identity.js\";\nimport { isArithmeticMeasure, isMeasure, isPoPMeasure, isPreviousPeriodMeasure, isSimpleMeasure, measureLocalId, isInlineMeasure, } from \"./index.js\";\nimport { isObjRef, objRefToString } from \"../../objRef/index.js\";\nimport { idRef } from \"../../objRef/factory.js\";\nimport SparkMD5 from \"spark-md5\";\nimport { invariant, InvariantError } from \"ts-invariant\";\nimport { sanitizeLocalId } from \"../../sanitizeLocalId.js\";\n/**\n * Abstract base class for measure builders. Measure builders allow for incremental, fluent construction\n * and modification of measures.\n *\n * @remarks\n * You should not be instantiating the builders directly. Instead, rely on the different functions to\n * create different types of measures.\n *\n * @public\n */\nexport class MeasureBuilderBase {\n    /**\n     * @internal\n     */\n    constructor() {\n        this.customLocalId = false;\n        /**\n         * Sets local identifier (localId) for the measure. LocalId can be used to reference the measure\n         * within the execution definition.\n         *\n         * @remarks\n         * Normally, builder will generate localId based on contents of the measure definition - taking all\n         * properties into account: in typical scenarios you don't have to call this function at all. The only exception\n         * where you have to provide custom local id is if your execution must contain the exact same measure twice.\n         *\n         * For convenience, this method also accepts 'undefined', which indicates that the default local id generation\n         * logic should be used.\n         *\n         * @param localId - local identifier to set; if not specified, the builder will ensure local id will\n         * be generated\n         */\n        this.localId = (localId) => {\n            if (!localId || localId.trim().length === 0) {\n                return this.defaultLocalId();\n            }\n            this.measure.localIdentifier = localId;\n            this.customLocalId = true;\n            return this;\n        };\n        /**\n         * Indicates that the measure's localId should be generated using the default local-id generator logic.\n         */\n        this.defaultLocalId = () => {\n            this.measure.localIdentifier = \"\";\n            this.customLocalId = false;\n            return this;\n        };\n        /**\n         * Sets alias - alternative title - for the measure.\n         *\n         * @remarks\n         * This value will then be used in various chart-specific descriptive elements.\n         * For convenience if no alias is specified, the measure will fall back to using either title (if specified)\n         * or server-defined title as the ultimate fallback\n         *\n         * @param alias - alias to use instead of measure title; undefined to use the title instead\n         */\n        this.alias = (alias) => {\n            if (!alias) {\n                return this.noAlias();\n            }\n            this.measure.alias = alias;\n            return this;\n        };\n        /**\n         * Resets alias - alternative title - set for the measure.\n         *\n         * @remarks\n         * The measure title will be used if specified, otherwise the server-defined title will be used instead.\n         */\n        this.noAlias = () => {\n            delete this.measure.alias;\n            return this;\n        };\n        /**\n         * Sets alternative title for the measure.\n         *\n         * @remarks\n         * This value will then be used in various chart-specific descriptive elements.\n         * For convenience if no title is specified, the measure will fall back to server-defined value.\n         *\n         * @param title - alternative title to use instead of server-defined value; undefined to use server-defined value\n         */\n        this.title = (title) => {\n            if (!title) {\n                return this.noTitle();\n            }\n            this.measure.title = title;\n            return this;\n        };\n        /**\n         * Resets alternative title for the measure. The server-defined title of the measure will be used\n         * instead.\n         */\n        this.noTitle = () => {\n            delete this.measure.title;\n            return this;\n        };\n        /**\n         * Sets measure format to use when rendering values calculated from this measure.\n         *\n         * @remarks\n         * The format string is described in more detail here {@link https://help.gooddata.com/doc/en/reporting-and-dashboards/reports/working-with-reports/formatting-numbers-in-reports}.\n         *\n         * For convenience, if you do not specify any format, then a default server-defined value will be used instead.\n         *\n         * @param format - measure format string; or undefined if you want to fall back to server-defined value\n         */\n        this.format = (format) => {\n            if (!format) {\n                return this.defaultFormat();\n            }\n            this.measure.format = format;\n            return this;\n        };\n        /**\n         * Resets format string to the server-defined value.\n         */\n        this.defaultFormat = () => {\n            delete this.measure.format;\n            return this;\n        };\n        this.build = () => {\n            const envelope = this.buildEnvelope();\n            return {\n                measure: Object.assign(Object.assign({}, envelope), { definition: this.buildDefinition() }),\n            };\n        };\n        this.measure = { localIdentifier: \"\" };\n    }\n    /**\n     * The measure builder subclasses must call this when they are used to modify\n     * an existing measure. Existing measure modification returns a new object that\n     * reflects the mods however it keeps the localId set as-is.\n     *\n     * @param measure - envelope of measure being modified\n     */\n    initializeFromExisting(measure) {\n        this.measure = cloneDeep(measure);\n        this.measure.localIdentifier = measure.localIdentifier;\n        this.customLocalId = true;\n    }\n    /**\n     * If custom localId has been set using localId() function, then use it unless it is empty.\n     *\n     * In all other cases generate localId. The localId generation consists up from three parts:\n     *\n     * - local identifier always starts with letter 'm'\n     * - IF alias, title or format is specified, it is hashed and first 8 chars of the hash will follow\n     * - The measure type specific part of the local identifier follows\n     *\n     * These three parts are separated using underscore.\n     */\n    getOrGenerateLocalId() {\n        if (this.customLocalId && !isEmpty(this.measure.localIdentifier)) {\n            return this.measure.localIdentifier;\n        }\n        return sanitizeLocalId([\"m\", this.buildEnvelopeLocalIdPart(), this.generateLocalId()]\n            .filter((part) => !isEmpty(part))\n            .join(\"_\"));\n    }\n    buildEnvelopeLocalIdPart() {\n        const { alias, format, title } = this.measure;\n        if (!alias && !format && !title) {\n            return \"\";\n        }\n        const hasher = new SparkMD5();\n        hasher.append(\"alias_\" + (alias !== null && alias !== void 0 ? alias : \"\"));\n        hasher.append(\"format_\" + (format !== null && format !== void 0 ? format : \"\"));\n        hasher.append(\"title_\" + (title !== null && title !== void 0 ? title : \"\"));\n        return hasher.end().substr(0, 8);\n    }\n    buildEnvelope() {\n        return Object.assign(Object.assign({}, this.measure), { localIdentifier: this.getOrGenerateLocalId() });\n    }\n}\n/**\n * Builder for simple measures.\n *\n * Do not instantiate this builder directly, instead use {@link newMeasure} or {@link modifyMeasure} functions.\n *\n * @public\n */\nexport class MeasureBuilder extends MeasureBuilderBase {\n    /**\n     * @internal\n     */\n    constructor(measureOrRef) {\n        super();\n        /**\n         * Sets aggregation to use for measures created from facts.\n         *\n         * @remarks\n         * By default the aggregation is SUM. For convenience the aggregation can be specified also for measures\n         * created from metrics - and in that case it will be ignored.\n         *\n         * For convenience, the aggregation may be undefined and it means the value should be reset to the default.\n         *\n         * @param aggregation - aggregation to use; if undefined will reset to default\n         */\n        this.aggregation = (aggregation) => {\n            if (!aggregation) {\n                return this.defaultAggregation();\n            }\n            this.measureDefinition.aggregation = aggregation;\n            return this;\n        };\n        /**\n         * Resets measure aggregation to the default (SUM).\n         */\n        this.defaultAggregation = () => {\n            delete this.measureDefinition.aggregation;\n            return this;\n        };\n        /**\n         * Indicates that the measure values should be calculated as percent contributions to the total unsliced\n         * value.\n         *\n         * @remarks\n         * This method works as 'turn-on-toggle' by default, however you can specify the actual boolean parameter and\n         * turn the ratio computation off using this method.\n         *\n         * @param value - set the compute ratio indicator to this value\n         */\n        this.ratio = (value = true) => {\n            if (!value) {\n                return this.noRatio();\n            }\n            this.measureDefinition.computeRatio = true;\n            return this;\n        };\n        /**\n         * Resets compute as ratio indicator.\n         */\n        this.noRatio = () => {\n            delete this.measureDefinition.computeRatio;\n            return this;\n        };\n        /**\n         * Sets filters to apply when calculating the values of this measure.\n         *\n         * @remarks\n         * These filters apply only to this particular measure calculation and do not impact the rest of the execution.\n         *\n         * @param filters - filters to apply to this measure\n         */\n        this.filters = (...filters) => {\n            this.measureDefinition.filters = filters;\n            return this;\n        };\n        /**\n         * Resets measure filters - this will remove all filters from the measure.\n         */\n        this.noFilters = () => {\n            this.measureDefinition.filters = [];\n            return this;\n        };\n        /**\n         * Sets reference to measure item that will be used for calculation.\n         *\n         * @remarks\n         * This can be either reference to a MAQL metric or a fact to calculate from.\n         *\n         * @param ref - new reference to use\n         */\n        this.measureItem = (ref) => {\n            this.measureDefinition.item = ref;\n            return this;\n        };\n        if (isMeasure(measureOrRef)) {\n            this.initializeFromExisting(measureOrRef.measure);\n            this.measureDefinition = cloneDeep(measureOrRef.measure.definition.measureDefinition);\n        }\n        else {\n            this.measureDefinition = {\n                item: measureOrRef,\n            };\n        }\n    }\n    generateLocalId() {\n        const aggString = this.measureDefinition.aggregation ? `_${this.measureDefinition.aggregation}` : \"\";\n        const ratioString = this.measureDefinition.computeRatio ? `_ratio` : \"\";\n        return `${objRefToString(this.measureDefinition.item)}${aggString}${ratioString}${this.filterLocalIdString()}`;\n    }\n    buildDefinition() {\n        return {\n            measureDefinition: this.measureDefinition,\n        };\n    }\n    filterLocalIdString() {\n        if (isEmpty(this.measureDefinition.filters)) {\n            return \"\";\n        }\n        const hasher = new SparkMD5();\n        hasher.append(JSON.stringify(this.measureDefinition.filters));\n        return \"_\" + hasher.end().substr(0, 8);\n    }\n}\n/**\n * Builder for inline measures.\n *\n * Do not instantiate this builder directly, instead use {@link newMeasure} or {@link modifyMeasure} functions.\n *\n * @public\n */\nexport class InlineMeasureBuilder extends MeasureBuilderBase {\n    /**\n     * @internal\n     */\n    constructor(measureInput) {\n        super();\n        /**\n         * Sets content of inline metric as string maql\n         *\n         * @param maql - maql of metric to use\n         */\n        this.maql = (maql) => {\n            this.inlineMeasureDefinition.maql = maql;\n            return this;\n        };\n        if (isInlineMeasure(measureInput)) {\n            this.initializeFromExisting(measureInput.measure);\n            this.inlineMeasureDefinition = cloneDeep(measureInput.measure.definition.inlineDefinition);\n        }\n        else {\n            this.inlineMeasureDefinition = {\n                maql: measureInput,\n            };\n        }\n    }\n    generateLocalId() {\n        const hasher = new SparkMD5();\n        hasher.append(this.inlineMeasureDefinition.maql);\n        return hasher.end().substr(0, 8) + \"_inline\";\n    }\n    buildDefinition() {\n        return {\n            inlineDefinition: this.inlineMeasureDefinition,\n        };\n    }\n}\n/**\n * Builder for arithmetic measures.\n *\n * Do not instantiate this builder directly, instead use {@link newArithmeticMeasure}.\n *\n * @public\n */\nexport class ArithmeticMeasureBuilder extends MeasureBuilderBase {\n    /**\n     * @internal\n     */\n    constructor(input) {\n        super();\n        /**\n         * Sets arithmetic operator to apply when calculating the arithmetic measure.\n         *\n         * @param op - operator\n         */\n        this.operator = (op) => {\n            this.arithmeticMeasure.operator = op;\n            return this;\n        };\n        /**\n         * Sets operands for arithmetic: other measures specified by either value or local identifier -\n         *\n         * @param measuresOrLocalIds - array of measures and/or localIds of measures to use as operands\n         */\n        this.operands = (measuresOrLocalIds) => {\n            this.arithmeticMeasure.measureIdentifiers = measuresOrLocalIds.map(measureLocalId);\n            return this;\n        };\n        if (isArithmeticMeasure(input)) {\n            this.initializeFromExisting(input.measure);\n            this.arithmeticMeasure = cloneDeep(input.measure.definition.arithmeticMeasure);\n        }\n        else {\n            const measureIdentifiers = input.measuresOrIds.map(measureLocalId);\n            this.arithmeticMeasure = {\n                measureIdentifiers,\n                operator: input.operator,\n            };\n        }\n    }\n    buildDefinition() {\n        return {\n            arithmeticMeasure: this.arithmeticMeasure,\n        };\n    }\n    generateLocalId() {\n        const hasher = new SparkMD5();\n        this.arithmeticMeasure.measureIdentifiers.forEach((id) => hasher.append(id));\n        return hasher.end();\n    }\n}\n/**\n * Builder for virtual arithmetic measures.\n *\n * Do not instantiate this builder directly, instead use {@link newVirtualArithmeticMeasure}.\n *\n * @internal\n */\nexport class VirtualArithmeticMeasureBuilder extends ArithmeticMeasureBuilder {\n    buildDefinition() {\n        const arithmeticDefinition = super.buildDefinition();\n        return Object.assign(Object.assign({}, arithmeticDefinition), { virtual: true });\n    }\n}\n/**\n * Builder for period-over-period measures.\n *\n * Do not instantiate this builder directly, instead use {@link newPopMeasure}.\n *\n * @public\n */\nexport class PoPMeasureBuilder extends MeasureBuilderBase {\n    /**\n     * @internal\n     */\n    constructor(input) {\n        super();\n        /**\n         * Sets master measure from which this period-over-period measure should be calculated.\n         *\n         * @param measureOrLocalId - measure value or measure local identifier\n         */\n        this.masterMeasure = (measureOrLocalId) => {\n            this.popMeasureDefinition.measureIdentifier = measureLocalId(measureOrLocalId);\n            return this;\n        };\n        /**\n         * Sets period-over-period date dimension attribute to use for offsetting. For convenience the attribute\n         * may be specified by either object reference or as a string - in which case it is assumed this is identifier\n         * of the attribute object.\n         *\n         * @param popAttrIdOrRef - reference of the PoP attribute, or identifier\n         */\n        this.popAttribute = (popAttrIdOrRef) => {\n            this.popMeasureDefinition.popAttribute = isObjRef(popAttrIdOrRef)\n                ? popAttrIdOrRef\n                : idRef(popAttrIdOrRef, \"attribute\");\n            return this;\n        };\n        if (isPoPMeasure(input)) {\n            this.initializeFromExisting(input.measure);\n            this.popMeasureDefinition = cloneDeep(input.measure.definition.popMeasureDefinition);\n        }\n        else {\n            const measureIdentifier = measureLocalId(input.measureOrLocalId);\n            const popAttribute = isObjRef(input.popAttrIdOrRef)\n                ? input.popAttrIdOrRef\n                : idRef(input.popAttrIdOrRef, \"attribute\");\n            this.popMeasureDefinition = {\n                measureIdentifier,\n                popAttribute,\n            };\n        }\n    }\n    buildDefinition() {\n        return {\n            popMeasureDefinition: this.popMeasureDefinition,\n        };\n    }\n    generateLocalId() {\n        return `${this.popMeasureDefinition.measureIdentifier}_${objRefToString(this.popMeasureDefinition.popAttribute)}`;\n    }\n}\n/**\n * Builder for previous period measures.\n *\n * Do not instantiate this builder directly, instead use {@link newPreviousPeriodMeasure}.\n *\n * @public\n */\nexport class PreviousPeriodMeasureBuilder extends MeasureBuilderBase {\n    /**\n     * @internal\n     */\n    constructor(input) {\n        super();\n        /**\n         * Sets master measure from which this previous period measure should be calculated.\n         *\n         * @param measureOrLocalId - measure value or measure local identifier\n         */\n        this.masterMeasure = (measureOrLocalId) => {\n            this.previousPeriodMeasure.measureIdentifier = measureLocalId(measureOrLocalId);\n            return this;\n        };\n        /**\n         * Sets date data set + offset within the data set to use when calculating values of this measure.\n         *\n         * @param dd - date data set + offset\n         */\n        this.dateDataSets = (dd) => {\n            this.previousPeriodMeasure.dateDataSets = this.convertDd(dd);\n            return this;\n        };\n        this.convertDd = (dd) => {\n            return dd.map((d) => (Object.assign(Object.assign({}, d), { dataSet: typeof d.dataSet === \"string\" ? idRef(d.dataSet) : d.dataSet })));\n        };\n        if (isPreviousPeriodMeasure(input)) {\n            this.initializeFromExisting(input.measure);\n            this.previousPeriodMeasure = cloneDeep(input.measure.definition.previousPeriodMeasure);\n        }\n        else {\n            this.previousPeriodMeasure = {\n                measureIdentifier: measureLocalId(input.measureIdOrLocalId),\n                dateDataSets: this.convertDd(input.dateDataSets),\n            };\n        }\n    }\n    buildDefinition() {\n        return {\n            previousPeriodMeasure: this.previousPeriodMeasure,\n        };\n    }\n    generateLocalId() {\n        return `${this.previousPeriodMeasure.measureIdentifier}_previous_period`;\n    }\n}\n/**\n * Creates a new measure with the specified identifier and optional modifications and localIdentifier.\n * @param measure - ref of identifier of the measure\n * @param modifications - optional modifications (e.g. alias, title, etc.)\n * @public\n */\nexport function newMeasure(measure, modifications = identity) {\n    const ref = isObjRef(measure) ? measure : idRef(measure);\n    const builder = new MeasureBuilder(ref);\n    return modifications(builder).build();\n}\n/**\n * Creates a new measure by applying modifications on top of an existing measure.\n *\n * @remarks\n * This generic function can accept measure of any type and thus in returns allows modifications on the properties that are common\n * in any type of measure.\n *\n * This operation is immutable and will not alter the input measure.\n *\n * The returned measure will have the same localIdentifier as the original measure. If you would like to assign\n * new/different local identifier to the measure, you can do that using the modifications where you can provide\n * either new custom localId or indicate that the measure should fall back to the auto-generated localId.\n *\n * @param measure - measure to use as template for the new measure\n * @param modifications - modifications to apply\n * @returns new instance\n * @public\n */\nexport function modifyMeasure(measure, modifications = identity) {\n    invariant(measure, \"measure must be specified\");\n    const builder = createBuilder(measure);\n    return modifications(builder).build();\n}\nfunction createBuilder(measure) {\n    if (isSimpleMeasure(measure)) {\n        return new MeasureBuilder(measure);\n    }\n    else if (isArithmeticMeasure(measure)) {\n        return new ArithmeticMeasureBuilder(measure);\n    }\n    else if (isPoPMeasure(measure)) {\n        return new PoPMeasureBuilder(measure);\n    }\n    else if (isPreviousPeriodMeasure(measure)) {\n        return new PreviousPeriodMeasureBuilder(measure);\n    }\n    else if (isInlineMeasure(measure)) {\n        return new InlineMeasureBuilder(measure);\n    }\n    throw new InvariantError(\"unexpected measure type\");\n}\n/**\n * Creates a new simple measure by applying modifications on top of an existing measure.\n *\n * @remarks\n * This operation is immutable and will not alter the input measure.\n *\n * The returned measure will have the same localIdentifier as the original measure. If you would like to assign\n * new/different local identifier to the measure, you can do that using the modifications where you can provide\n * either new custom localId or indicate that the measure should fall back to the auto-generated localId.\n *\n * @param measure - measure to use as template for the new measure\n * @param modifications - modifications to apply\n * @returns new instance\n * @public\n */\nexport function modifySimpleMeasure(measure, modifications = identity) {\n    invariant(measure, \"measure must be specified\");\n    const builder = new MeasureBuilder(measure);\n    return modifications(builder).build();\n}\n/**\n * Creates a new inline measure\n *\n * @param maql - maql definition of measure\n * @returns new instance\n * @public\n */\nexport function newInlineMeasure(maql) {\n    invariant(maql, \"maql must be specified\");\n    const builder = new InlineMeasureBuilder(maql);\n    return builder.build();\n}\n/**\n * Creates a new inline measure by applying modifications on top of an existing measure.\n *\n * @remarks\n * This operation is immutable and will not alter the input measure.\n *\n * The returned measure will have the same localIdentifier as the original measure. If you would like to assign\n * new/different local identifier to the measure, you can do that using the modifications where you can provide\n * either new custom localId or indicate that the measure should fall back to the auto-generated localId.\n *\n * @param measure - measure to use as template for the new measure\n * @param modifications - modifications to apply\n * @returns new instance\n * @public\n */\nexport function modifyInlineMeasure(measure, modifications = identity) {\n    invariant(measure, \"measure must be specified\");\n    const builder = new InlineMeasureBuilder(measure);\n    return modifications(builder).build();\n}\n/**\n * Creates a new PoP measure by applying modifications on top of an existing measure.\n *\n * @remarks\n * This operation is immutable and will not alter the input measure.\n *\n * The returned measure will have the same localIdentifier as the original measure. If you would like to assign\n * new/different local identifier to the measure, you can do that using the modifications where you can provide\n * either new custom localId or indicate that the measure should fall back to the auto-generated localId.\n *\n * @param measure - measure to use as template for the new measure\n * @param modifications - modifications to apply\n * @returns new instance\n * @public\n */\nexport function modifyPopMeasure(measure, modifications = identity) {\n    invariant(measure, \"measure must be specified\");\n    const builder = new PoPMeasureBuilder(measure);\n    return modifications(builder).build();\n}\n/**\n * Creates a new Previous Period measure by applying modifications on top of an existing measure.\n *\n * @remarks\n * This operation is immutable and will not alter the input measure.\n *\n * The returned measure will have the same localIdentifier as the original measure. If you would like to assign\n * new/different local identifier to the measure, you can do that using the modifications where you can provide\n * either new custom localId or indicate that the measure should fall back to the auto-generated localId.\n *\n * @param measure - measure to use as template for the new measure\n * @param modifications - modifications to apply\n * @returns new instance\n * @public\n */\nexport function modifyPreviousPeriodMeasure(measure, modifications = identity) {\n    invariant(measure, \"measure must be specified\");\n    const builder = new PreviousPeriodMeasureBuilder(measure);\n    return modifications(builder).build();\n}\n/**\n * Creates a new arithmetic measure with the specified measure identifiers and operator and optional modifications and localIdentifier.\n * @param measuresOrIds - measures or identifiers of the measures to be included in this arithmetic measure\n * @param operator - operator of the measure\n * @param modifications - optional modifications (e.g. alias, title, etc.)\n * @public\n */\nexport function newArithmeticMeasure(measuresOrIds, operator, modifications = identity) {\n    const builder = new ArithmeticMeasureBuilder({ measuresOrIds, operator });\n    return modifications(builder).build();\n}\n/**\n * Creates a new virtual arithmetic measure with the specified measure identifiers and operator and optional modifications and localIdentifier.\n *\n * @param measuresOrIds - measures or identifiers of the measures to be included in this arithmetic measure\n * @param operator - operator of the measure\n * @param modifications - optional modifications (e.g. alias, title, etc.)\n *\n * @internal\n */\nexport function newVirtualArithmeticMeasure(measuresOrIds, operator, modifications = identity) {\n    const builder = new VirtualArithmeticMeasureBuilder({ measuresOrIds, operator });\n    return modifications(builder).build();\n}\n/**\n * Creates a new PoP measure with the specified identifier and PoP attribute identifier and optional modifications and localIdentifier.\n * @param measureOrLocalId - measure or local identifier of the measure\n * @param popAttrIdOrRef - identifier or a reference to PoP attribute\n * @param modifications - optional modifications (e.g. alias, title, etc.)\n * @public\n */\nexport function newPopMeasure(measureOrLocalId, popAttrIdOrRef, modifications = identity) {\n    const builder = new PoPMeasureBuilder({ measureOrLocalId, popAttrIdOrRef });\n    return modifications(builder).build();\n}\n/**\n * Creates a new Previous Period measure with the specified measure identifier and date data sets and optional modifications and localIdentifier.\n * @param measureIdOrLocalId - measure or local identifier of the measure to create Previous Period measure for\n * @param dateDataSets - date data sets to use in the Previous Period calculation\n * @param modifications - optional modifications (e.g. alias, title, etc.)\n * @public\n */\nexport function newPreviousPeriodMeasure(measureIdOrLocalId, dateDataSets, modifications = identity) {\n    const builder = new PreviousPeriodMeasureBuilder({ measureIdOrLocalId, dateDataSets });\n    return modifications(builder).build();\n}\n//# sourceMappingURL=factory.js.map","// (C) 2019-2022 GoodData Corporation\nimport isEmpty from \"lodash/isEmpty.js\";\nimport { invariant } from \"ts-invariant\";\nimport { isIdentifierRef, isUriRef } from \"../../objRef/index.js\";\n/**\n * Implementation of measure predicate which always returns true.\n *\n * @public\n */\nexport const anyMeasure = (_) => true;\n/**\n * Factory function for measure predicate which evaluates true for measures that match particular ID.\n *\n * @public\n */\nexport const idMatchMeasure = (id) => (m) => m.measure.localIdentifier === id;\n//\n// Type guards\n//\n/**\n * Type guard for checking whether object is any type of measure.\n *\n * @public\n */\nexport function isMeasure(obj) {\n    var _a;\n    return (!isEmpty(obj) &&\n        // we need to prevent false positives for the \"insides\" of measure value filters that also have `measure` property\n        // so check also for the definition property which is mandatory anyway\n        ((_a = obj.measure) === null || _a === void 0 ? void 0 : _a.definition) !== undefined);\n}\n/**\n * Type guard for checking whether object is a simple measure.\n *\n * @public\n */\nexport function isSimpleMeasure(obj) {\n    return isMeasure(obj) && isMeasureDefinition(obj.measure.definition);\n}\n/**\n * Type guard for checking whether object is a inline measure.\n *\n * @public\n */\nexport function isInlineMeasure(obj) {\n    return isMeasure(obj) && isInlineMeasureDefinition(obj.measure.definition);\n}\n/**\n * Type guard for checking whether object is an adhoc measure.\n *\n * @remarks\n * An adhoc measure is a measure having an aggregation, one or some filters or a computeRatio of true\n *\n * @public\n */\nexport function isAdhocMeasure(obj) {\n    if (!isSimpleMeasure(obj)) {\n        return false;\n    }\n    const { measureDefinition } = obj.measure.definition;\n    return (!!measureDefinition.aggregation ||\n        !!measureDefinition.computeRatio ||\n        (Array.isArray(measureDefinition.filters) && measureDefinition.filters.length > 0));\n}\n/**\n * Type guard for checking whether object is a period-over-period measure.\n *\n * @public\n */\nexport function isPoPMeasure(obj) {\n    return isMeasure(obj) && isPoPMeasureDefinition(obj.measure.definition);\n}\n/**\n * Type guard for checking whether object is a previous-period measure.\n *\n * @public\n */\nexport function isPreviousPeriodMeasure(obj) {\n    return isMeasure(obj) && isPreviousPeriodMeasureDefinition(obj.measure.definition);\n}\n/**\n * Type guard for checking whether object is an arithmetic measure.\n *\n * @public\n */\nexport function isArithmeticMeasure(obj) {\n    return isMeasure(obj) && isArithmeticMeasureDefinition(obj.measure.definition);\n}\n/**\n * Type guard for checking whether an object is a virtual arithmetic measure.\n *\n * @internal\n *\n * @param obj - The object to be checked for being a virtual arithmetic measure.\n * @returns Returns true if the object is a virtual arithmetic measure, false otherwise.\n */\nexport function isVirtualArithmeticMeasure(obj) {\n    return isMeasure(obj) && isVirtualArithmeticMeasureDefinition(obj.measure.definition);\n}\n/**\n * Type guard for checking whether object is a measure definition.\n *\n * @public\n */\nexport function isMeasureDefinition(obj) {\n    return !isEmpty(obj) && obj.measureDefinition !== undefined;\n}\n/**\n * Type guard for checking whether object is a inline measure definition.\n *\n * @public\n */\nexport function isInlineMeasureDefinition(obj) {\n    return !isEmpty(obj) && obj.inlineDefinition !== undefined;\n}\n/**\n * Type guard for checking whether object is a period-over-period measure definition.\n *\n * @public\n */\nexport function isPoPMeasureDefinition(obj) {\n    return !isEmpty(obj) && obj.popMeasureDefinition !== undefined;\n}\n/**\n * Type guard for checking whether object is a previous period measure definition.\n *\n * @public\n */\nexport function isPreviousPeriodMeasureDefinition(obj) {\n    return !isEmpty(obj) && obj.previousPeriodMeasure !== undefined;\n}\n/**\n * Type guard for checking whether object is an arithmetic measure definition.\n *\n * @public\n */\nexport function isArithmeticMeasureDefinition(obj) {\n    return !isEmpty(obj) && obj.arithmeticMeasure !== undefined;\n}\n/**\n * Type guard for checking whether object is a virtual arithmetic measure definition.\n *\n * @internal\n */\nexport function isVirtualArithmeticMeasureDefinition(obj) {\n    const virtualArithmeticDefinition = obj;\n    return (isArithmeticMeasureDefinition(virtualArithmeticDefinition) && !!virtualArithmeticDefinition.virtual);\n}\n//\n// Functions\n//\n/**\n * Gets measure's local identifier. For convenience and fluency, this function accepts both measure object and identifier\n * object.\n *\n * @param measureOrLocalId - measure object or measure localId; if localId provided, it is returned as is\n * @returns string identifier\n * @public\n */\nexport function measureLocalId(measureOrLocalId) {\n    invariant(measureOrLocalId, \"measure or local id must be specified\");\n    return typeof measureOrLocalId === \"string\" ? measureOrLocalId : measureOrLocalId.measure.localIdentifier;\n}\n/**\n * Gets URI of persistent measure.\n *\n * @remarks\n * Undefined is returned if the measure definition is not for a persistent\n * measure (arithmetic or derived). Undefined is returned if the measure is not specified by URI.\n *\n * @param measure - measure to get URI for\n * @returns URI or undefined\n * @public\n */\nexport function measureUri(measure) {\n    invariant(measure, \"measure must be specified\");\n    const ref = measureItem(measure);\n    if (!ref) {\n        return undefined;\n    }\n    return isUriRef(ref) ? ref.uri : undefined;\n}\n/**\n * Gets identifier of persistent measure.\n *\n * @remarks\n * Undefined is returned if the measure definition is not for a persistent\n * measure (arithmetic or derived). Undefined is returned if the measure is not specified by identifier.\n *\n * @param measure - measure to get URI for\n * @returns identifier or undefined\n * @public\n */\nexport function measureIdentifier(measure) {\n    invariant(measure, \"measure must be specified\");\n    const ref = measureItem(measure);\n    if (!ref) {\n        return undefined;\n    }\n    return isIdentifierRef(ref) ? ref.identifier : undefined;\n}\nexport function measureItem(measure) {\n    var _a;\n    invariant(measure, \"measure must be specified\");\n    return (_a = measure.measure.definition.measureDefinition) === null || _a === void 0 ? void 0 : _a.item;\n}\n/**\n * Tests whether the measure is set to compute ratio.\n *\n * @param measure - measure to to test\n * @returns true if computes ratio, false otherwise\n * @public\n */\nexport function measureDoesComputeRatio(measure) {\n    invariant(measure, \"measure must be specified\");\n    if (!isSimpleMeasure(measure)) {\n        return false;\n    }\n    return !!measure.measure.definition.measureDefinition.computeRatio;\n}\nexport function measureMasterIdentifier(measure) {\n    invariant(measure, \"measure must be specified\");\n    if (isPoPMeasure(measure)) {\n        return measure.measure.definition.popMeasureDefinition.measureIdentifier;\n    }\n    else if (isPreviousPeriodMeasure(measure)) {\n        return measure.measure.definition.previousPeriodMeasure.measureIdentifier;\n    }\n    return undefined;\n}\nexport function measureArithmeticOperands(measure) {\n    invariant(measure, \"measure must be specified\");\n    if (!isArithmeticMeasure(measure)) {\n        return undefined;\n    }\n    return measure.measure.definition.arithmeticMeasure.measureIdentifiers;\n}\nexport function measureArithmeticOperator(measure) {\n    invariant(measure, \"measure must be specified\");\n    if (!isArithmeticMeasure(measure)) {\n        return undefined;\n    }\n    return measure.measure.definition.arithmeticMeasure.operator;\n}\n/**\n * Gets measure alias.\n *\n * @param measure - measure to get the alias of\n * @returns measure alias if specified, undefined otherwise\n * @public\n */\nexport function measureAlias(measure) {\n    invariant(measure, \"measure must be specified\");\n    return measure.measure.alias;\n}\n/**\n * Gets measure title.\n * @param measure - measure to get the title of\n * @returns measure title if specified, undefined otherwise\n * @public\n */\nexport function measureTitle(measure) {\n    invariant(measure, \"measure must be specified\");\n    return measure.measure.title;\n}\n/**\n * Gets measure format.\n * @param measure - measure to get the format of\n * @returns measure format if specified, undefined otherwise\n * @public\n */\nexport function measureFormat(measure) {\n    invariant(measure, \"measure must be specified\");\n    return measure.measure.format;\n}\n/**\n * Gets a flag indicating whether a given measure has a format resulting in data being formatted as percentage\n * @param measureOrFormat - measure or measure format to test\n * @returns true if the measure format is in percent, false otherwise\n * @public\n * @remarks Measure format is considered to represent value in percent when\n * A) format string has no conditional separators (i.e. no semicolons except a single one at the end);\n *    otherwise the parsing would need access to a particular value.\n * B) percentage symbol is found (not directly preceded by backslash)\n */\nexport function isMeasureFormatInPercent(measureOrFormat) {\n    const format = isMeasure(measureOrFormat) ? measureFormat(measureOrFormat) : measureOrFormat;\n    // no reasonable way to avoid the super-linear backtracking right now\n    // eslint-disable-next-line regexp/no-super-linear-backtracking\n    return !!format && /^[^;]*%[^;]*;*$/.test(format.trim().replace(/\\\\%/g, \"\"));\n}\n/**\n * Gets measure aggregation from a measure.\n *\n * @remarks\n * Measure aggregation is applicable and optional only for\n * simple measures. Passing any other measure to this function guarantees that undefined will be returned\n *\n * @param measure - measure to get the aggregation of\n * @returns measure aggregation if specified, undefined otherwise\n * @public\n */\nexport function measureAggregation(measure) {\n    invariant(measure, \"measure must be specified\");\n    if (!isSimpleMeasure(measure)) {\n        return undefined;\n    }\n    return measure.measure.definition.measureDefinition.aggregation;\n}\n/**\n * Gets measure filters.\n *\n * @param measure - measure to get the filters of\n * @returns measure filters if specified, undefined otherwise\n * @public\n */\nexport function measureFilters(measure) {\n    invariant(measure, \"measure must be specified\");\n    if (!isSimpleMeasure(measure)) {\n        return undefined;\n    }\n    return measure.measure.definition.measureDefinition.filters;\n}\nexport function measurePopAttribute(measure) {\n    invariant(measure, \"measure must be specified\");\n    if (!isPoPMeasure(measure)) {\n        return undefined;\n    }\n    return measure.measure.definition.popMeasureDefinition.popAttribute;\n}\nexport function measurePreviousPeriodDateDataSets(measure) {\n    invariant(measure, \"measure must be specified\");\n    if (!isPreviousPeriodMeasure(measure)) {\n        return undefined;\n    }\n    return measure.measure.definition.previousPeriodMeasure.dateDataSets;\n}\n//# sourceMappingURL=index.js.map","// (C) 2019-2022 GoodData Corporation\nimport isEmpty from \"lodash/isEmpty.js\";\n//\n// Type guards\n//\n/**\n * Type-guard testing whether the provided object is an instance of {@link IAttributeDescriptor}.\n *\n * @public\n */\nexport function isAttributeDescriptor(obj) {\n    return !isEmpty(obj) && obj.attributeHeader !== undefined;\n}\n/**\n * Type-guard testing whether the provided object is an instance of {@link IMeasureGroupDescriptor}.\n *\n * @public\n */\nexport function isMeasureGroupDescriptor(obj) {\n    return !isEmpty(obj) && obj.measureGroupHeader !== undefined;\n}\n/**\n * Type-guard testing whether the provided object is an instance of {@link IMeasureDescriptor}.\n *\n * @public\n */\nexport function isMeasureDescriptor(obj) {\n    return !isEmpty(obj) && obj.measureHeaderItem !== undefined;\n}\n/**\n * Type-guard testing whether the provided object is an instance of {@link ITotalDescriptor}.\n *\n * @public\n */\nexport function isTotalDescriptor(obj) {\n    return !isEmpty(obj) && obj.totalHeaderItem !== undefined;\n}\n/**\n * Type-guard testing whether the provided object is an instance of {@link IColorDescriptor}.\n *\n * @public\n */\nexport function isColorDescriptor(obj) {\n    return !isEmpty(obj) && obj.colorHeaderItem !== undefined;\n}\n/**\n * Type-guard testing whether the provided object is an instance of {@link IResultAttributeHeader}.\n *\n * @public\n */\nexport function isResultAttributeHeader(obj) {\n    return !isEmpty(obj) && obj.attributeHeaderItem !== undefined;\n}\n/**\n * Type-guard testing whether the provided object is an instance of {@link IResultMeasureHeader}.\n *\n * @public\n */\nexport function isResultMeasureHeader(obj) {\n    return (!isEmpty(obj) &&\n        obj.measureHeaderItem !== undefined &&\n        obj.measureHeaderItem.order !== undefined);\n}\n/**\n * Type-guard testing whether the provided object is an instance of {@link IResultTotalHeader}.\n *\n * @public\n */\nexport function isResultTotalHeader(obj) {\n    return (!isEmpty(obj) &&\n        obj.totalHeaderItem !== undefined &&\n        obj.totalHeaderItem.type !== undefined);\n}\n//\n//\n//\n/**\n * Returns item name contained within a result header.\n *\n * @param header - header of any type\n * @public\n */\nexport function resultHeaderName(header) {\n    if (isResultAttributeHeader(header)) {\n        return header.attributeHeaderItem.name;\n    }\n    else if (isResultMeasureHeader(header)) {\n        return header.measureHeaderItem.name;\n    }\n    return header.totalHeaderItem.name;\n}\n/**\n * Returns local identifier of attribute described in the provided attribute descriptor.\n *\n * @param descriptor - attribute descriptor, must be specified\n * @public\n */\nexport function attributeDescriptorLocalId(descriptor) {\n    return descriptor.attributeHeader.localIdentifier;\n}\n/**\n * Returns name of attribute described in the provided attribute descriptor.\n *\n * @param descriptor - attribute descriptor, must be specified\n * @public\n */\nexport function attributeDescriptorName(descriptor) {\n    return descriptor.attributeHeader.formOf.name;\n}\n//# sourceMappingURL=index.js.map","// (C) 2019-2022 GoodData Corporation\nimport isEmpty from \"lodash/isEmpty.js\";\nimport intersection from \"lodash/intersection.js\";\nimport { sortEntityIds } from \"../execution/base/sort.js\";\nimport { anyBucket, } from \"../execution/buckets/index.js\";\nimport { filterObjRef, isAttributeFilter } from \"../execution/filter/index.js\";\nimport { anyMeasure, measureFilters, measureLocalId, } from \"../execution/measure/index.js\";\nimport { anyAttribute, attributeDisplayFormRef, attributeLocalId, } from \"../execution/attribute/index.js\";\nimport { bucketsAttributes, bucketsById, bucketsFind, bucketsItems, bucketsMeasures, bucketsModifyItem, bucketsReduceItem, bucketsTotals, } from \"../execution/buckets/bucketArray.js\";\nimport { invariant } from \"ts-invariant\";\nimport identity from \"lodash/identity.js\";\nimport { serializeObjRef } from \"../objRef/index.js\";\nimport flatMap from \"lodash/flatMap.js\";\nimport uniqBy from \"lodash/uniqBy.js\";\n/**\n * Type guard checking whether the provided object is an {@link IColorMappingItem}.\n *\n * @public\n */\nexport function isColorMappingItem(obj) {\n    return !isEmpty(obj) && !!obj.color && !!obj.id;\n}\n//\n// Type guards\n//\n/**\n * Type guard checking whether the provided object is an Insight.\n *\n * @public\n */\nexport function isInsight(obj) {\n    return !isEmpty(obj) && obj.insight !== undefined;\n}\n//\n// Functions\n//\n/**\n * Finds bucket matching the provided predicate in an insight.\n *\n * @remarks\n * This function also provides convenience to find bucket by its local identifier - if you pass predicate as\n * string the function will automatically create idMatchBucket predicate.\n *\n * @param insight - insight to work with\n * @param idOrFun - local identifier or bucket predicate\n * @returns undefined if none match\n * @public\n */\nexport function insightBucket(insight, idOrFun = anyBucket) {\n    invariant(insight, \"insight must be specified\");\n    return bucketsFind(insight.insight.buckets, idOrFun);\n}\n/**\n * Gets buckets for the insight. If ids are provided, then only returns buckets matching the ids.\n *\n * @param insight - insight to work with\n * @param ids - local identifiers of buckets\n * @returns empty list if none match\n * @public\n */\nexport function insightBuckets(insight, ...ids) {\n    invariant(insight, \"insight must be specified\");\n    if (isEmpty(ids)) {\n        return insight.insight.buckets;\n    }\n    return bucketsById(insight.insight.buckets, ...ids);\n}\n/**\n * Gets all attributes and measures used in the provided insight.\n *\n * @param insight - insight to work with\n * @returns empty if none\n * @public\n */\nexport function insightItems(insight) {\n    invariant(insight, \"insight must be specified\");\n    return bucketsItems(insight.insight.buckets);\n}\n/**\n * Gets all measures used in the provided insight.\n *\n * @param insight - insight to work with\n * @param measurePredicate - predicate to select measures satisfying some conditions\n * @returns empty if none\n * @public\n */\nexport function insightMeasures(insight, measurePredicate = anyMeasure) {\n    invariant(insight, \"insight must be specified\");\n    return bucketsMeasures(insight.insight.buckets, measurePredicate);\n}\n/**\n * Tests whether insight uses any measures.\n *\n * @param insight - insight to test\n * @returns true if any measures, false if not\n * @public\n */\nexport function insightHasMeasures(insight) {\n    invariant(insight, \"insight must be specified\");\n    return insightMeasures(insight).length > 0;\n}\n/**\n * Gets all attributes used in the provided insight\n *\n * @param insight - insight to work with\n * @param attributePredicate - predicate to select attributes satisfying some conditions\n * @returns empty if none\n * @public\n */\nexport function insightAttributes(insight, attributePredicate = anyAttribute) {\n    invariant(insight, \"insight must be specified\");\n    return bucketsAttributes(insight.insight.buckets, attributePredicate);\n}\n/**\n * Tests whether insight uses any attributes\n *\n * @param insight - insight to test\n * @returns true if any measures, false if not\n * @public\n */\nexport function insightHasAttributes(insight) {\n    invariant(insight, \"insight must be specified\");\n    return insightAttributes(insight).length > 0;\n}\n/**\n * Tests whether insight contains valid definition of data to visualise - meaning at least one attribute or\n * one measure is defined in the insight.\n *\n * @param insight - insight to test\n * @returns true if at least one measure or attribute, false if none\n * @public\n */\nexport function insightHasDataDefined(insight) {\n    invariant(insight, \"insight must be specified\");\n    return (insight.insight.buckets.length > 0 && (insightHasMeasures(insight) || insightHasAttributes(insight)));\n}\n/**\n * Gets filters used in an insight.\n *\n * @param insight - insight to work with\n * @public\n */\nexport function insightFilters(insight) {\n    invariant(insight, \"insight must be specified\");\n    return insight.insight.filters;\n}\n/**\n * Gets sorting defined in the insight.\n *\n * @remarks\n * Note: this function ensures that only sorts working on top of attributes and measures defined in the\n * insight will be returned. Any invalid entries will be stripped.\n *\n * @param insight - insight to get sorts from\n * @returns array of valid sorts\n * @public\n */\nexport function insightSorts(insight) {\n    invariant(insight, \"insight must be specified\");\n    const attributeIds = insightAttributes(insight).map(attributeLocalId);\n    const measureIds = insightMeasures(insight).map(measureLocalId);\n    function contains(arr1, arr2) {\n        return intersection(arr1, arr2).length === arr2.length;\n    }\n    return insight.insight.sorts.filter((s) => {\n        const entities = sortEntityIds(s);\n        return (contains(attributeIds, entities.attributeIdentifiers) &&\n            contains(measureIds, entities.measureIdentifiers));\n    });\n}\n/**\n * Gets all totals defined in the insight\n *\n * @param insight - insight to get totals from\n * @returns empty if none\n * @public\n */\nexport function insightTotals(insight) {\n    invariant(insight, \"insight must be specified\");\n    return bucketsTotals(insight.insight.buckets);\n}\n/**\n * Gets visualization properties of an insight.\n *\n * @param insight - insight to get vis properties for\n * @returns empty object is no properties\n * @public\n */\nexport function insightProperties(insight) {\n    invariant(insight, \"insight must be specified\");\n    return insight.insight.properties;\n}\n/**\n * Gets URL of visualization that should be used to render this insight. This is a link to the location\n * where the visualization assets are stored and where they should be loaded and linked from.\n *\n * Note: at the moment, the SDK supports only compile-time linkage; for this the visualization URL\n * is in format \"local:visName\" (as in \"local:bar\" for BarChart)\n *\n * @param insight - insight to get visualization URL from\n * @alpha\n */\nexport function insightVisualizationUrl(insight) {\n    invariant(insight, \"insight to get vis class URI from must be specified\");\n    return insight.insight.visualizationUrl;\n}\n/**\n *\n * @param insight - insight to get visualization type\n * @alpha\n */\nexport function insightVisualizationType(insight) {\n    var _a;\n    invariant(insight, \"insight to get vis type must be specified\");\n    return ((_a = insightVisualizationUrl(insight)) === null || _a === void 0 ? void 0 : _a.split(\":\")[1]) || \"\";\n}\n/**\n * Gets the insight title\n *\n * @param insight - insight to get title of\n * @returns the insight title\n * @public\n */\nexport function insightTitle(insight) {\n    invariant(insight, \"insight to get title from must be specified\");\n    return insight.insight.title;\n}\n/**\n * Gets the insights tags from the tagging system\n *\n * @param insight - insight to get the tags of\n * @returns the insight tags or aan empty array if none are specified\n * @public\n */\nexport function insightTags(insight) {\n    var _a;\n    invariant(insight, \"insight must be specified\");\n    return (_a = insight.insight.tags) !== null && _a !== void 0 ? _a : [];\n}\n/**\n * Gets the insights summary\n *\n * @param insight - insight to get the summary of\n * @returns the insight summary or an empty string if is not specified\n * @public\n */\nexport function insightSummary(insight) {\n    var _a;\n    invariant(insight, \"insight must be specified\");\n    return (_a = insight.insight.summary) !== null && _a !== void 0 ? _a : \"\";\n}\n/**\n * Gets opaque reference to the insight.\n *\n * @param insight - insight to get ref of\n * @public\n */\nexport function insightRef(insight) {\n    invariant(insight, \"insight to get ref of must be specified\");\n    return insight.insight.ref;\n}\n/**\n * Gets the insight id\n *\n * @param insight - insight to get id of\n * @returns the insight id\n * @public\n */\nexport function insightId(insight) {\n    invariant(insight, \"insight to get id of must be specified\");\n    return insight.insight.identifier;\n}\n/**\n * Gets the insight uri\n *\n * @param insight - insight to get uri of\n * @returns the insight uri\n * @public\n */\nexport function insightUri(insight) {\n    invariant(insight, \"insight to get uri of must be specified\");\n    return insight.insight.uri;\n}\n/**\n * Gets the date when the insight was created\n *\n * @param insight - insight\n * @returns string - YYYY-MM-DD HH:mm:ss\n * @public\n */\nexport function insightCreated(insight) {\n    invariant(insight, \"insight must be specified\");\n    return insight.insight.created;\n}\n/**\n * Gets the user that created the insight\n *\n * @param insight - insight\n * @returns string\n * @public\n */\nexport function insightCreatedBy(insight) {\n    invariant(insight, \"insight must be specified\");\n    return insight.insight.createdBy;\n}\n/**\n * Gets the date of the last insight update\n *\n * @param insight - insight\n * @returns string - YYYY-MM-DD HH:mm:ss\n * @public\n */\nexport function insightUpdated(insight) {\n    invariant(insight, \"insight must be specified\");\n    return insight.insight.updated;\n}\n/**\n * Gets the user that last updated the insight\n *\n * @param insight - insight\n * @returns string\n * @public\n */\nexport function insightUpdatedBy(insight) {\n    invariant(insight, \"insight must be specified\");\n    return insight.insight.updatedBy;\n}\n/**\n * Checks if insight is locked\n *\n * @param insight - insight\n * @returns boolean\n * @public\n */\nexport function insightIsLocked(insight) {\n    invariant(insight, \"insight must be specified\");\n    return insight.insight.isLocked || false;\n}\n/**\n * Gets a new insight that 'inherits' all data from the provided insight but has different properties.\n *\n * @remarks\n * New properties will be used in the new insight as-is, no merging with existing properties.\n *\n * @param insight - insight to work with\n * @param properties - new properties to have on the new insight\n * @returns always new instance\n * @public\n */\nexport function insightSetProperties(insight, properties = {}) {\n    invariant(insight, \"insight must be specified\");\n    return {\n        insight: Object.assign(Object.assign({}, insight.insight), { properties }),\n    };\n}\n/**\n * Gets a new insight that 'inherits' all data from the provided insight but has different sorts.\n *\n * @remarks\n * New sorts will be used in the new insight as-is, no merging with existing sorts.\n *\n * @param insight - insight to work with\n * @param sorts - new sorts to apply\n * @returns always new instance\n * @public\n */\nexport function insightSetSorts(insight, sorts = []) {\n    invariant(insight, \"insight must be specified\");\n    return {\n        insight: Object.assign(Object.assign({}, insight.insight), { sorts }),\n    };\n}\n/**\n * Gets a new insight that 'inherits' all data from the provided insight but has different filters.\n *\n * @remarks\n * New filters will be used in the new insight as-is, no merging with existing filters.\n *\n * @param insight - insight to work with\n * @param filters - new filters to apply\n * @returns always new instance\n * @public\n */\nexport function insightSetFilters(insight, filters = []) {\n    invariant(insight, \"insight must be specified\");\n    return {\n        insight: Object.assign(Object.assign({}, insight.insight), { filters }),\n    };\n}\n/**\n * Gets a new insight that 'inherits' all data from the provided insight but has different buckets.\n *\n * @remarks\n * New buckets will be used in the new insight as-is, no merging with existing buckets.\n *\n * @param insight - insight to work with\n * @param buckets - new buckets to apply\n * @returns always new instance\n * @public\n */\nexport function insightSetBuckets(insight, buckets = []) {\n    invariant(insight, \"insight must be specified\");\n    return {\n        insight: Object.assign(Object.assign({}, insight.insight), { buckets }),\n    };\n}\n/**\n * Creates a new insight with modified bucket items (retrieved by applying the modifications function to each bucketItem in the insight).\n *\n * @remarks\n * Note: the bucket item modification function SHOULD NOT modify bucket item's localId.\n * The localId MAY be used to reference the item from other places in the insight (for example from sorts).\n * Changing the item localId has potential to break the insight: as-is this function does not concern itself with changing the references.\n *\n * @param insight - insight to use as template for the new insight\n * @param modifications - modifications to apply to the bucket items\n * @returns always new instance\n * @public\n */\nexport function insightModifyItems(insight, modifications = identity) {\n    invariant(insight, \"insight must be specified\");\n    const buckets = insightBuckets(insight);\n    return {\n        insight: Object.assign(Object.assign({}, insight.insight), { buckets: bucketsModifyItem(buckets, modifications) }),\n    };\n}\n/**\n * Creates a new insight with reduced bucket items (retrieved by applying the modifications function).\n *\n * @remarks\n * Note: the bucket item modification function SHOULD NOT modify bucket item's localId.\n * The localId MAY be used to reference the item from other places in the insight (for example from sorts).\n * Changing the item localId has potential to break the insight: as-is this function does not concern itself with changing the references.\n *\n * @param insight - insight to use as template for the new insight\n * @param reducer - reduce function to apply to the bucket items\n * @returns always new instance\n * @public\n */\nexport function insightReduceItems(insight, reducer = identity) {\n    invariant(insight, \"insight must be specified\");\n    const buckets = insightBuckets(insight);\n    return {\n        insight: Object.assign(Object.assign({}, insight.insight), { buckets: bucketsReduceItem(buckets, reducer) }),\n    };\n}\n/**\n * Gets references to all display forms used by the insight.\n *\n * @remarks\n * The display forms may be used for slicing or dicing the\n * data, for filtering the entire insight or for filtering just some measures.\n *\n * @param insight - insight to get the display form usage from\n * @public\n */\nexport function insightDisplayFormUsage(insight) {\n    invariant(insight, \"insight must be specified\");\n    return {\n        inAttributes: uniqBy(insightAttributes(insight).map(attributeDisplayFormRef), serializeObjRef),\n        inFilters: uniqBy(insightFilters(insight)\n            .filter(isAttributeFilter)\n            .map((attributeFilter) => filterObjRef(attributeFilter)), serializeObjRef),\n        inMeasureFilters: uniqBy(flatMap(insightMeasures(insight), (measure) => {\n            var _a;\n            const filters = (_a = measureFilters(measure)) !== null && _a !== void 0 ? _a : [];\n            return filters\n                .filter(isAttributeFilter)\n                .map((attributeFilter) => filterObjRef(attributeFilter));\n        }), serializeObjRef),\n    };\n}\n//\n// Visualization class functions\n//\n/**\n * For given visualization class, return URL where the vis assets are stored.\n *\n * @param vc - visualization class\n * @returns never null, never empty\n * @public\n */\nexport function visClassUrl(vc) {\n    invariant(vc, \"vis class to get URL from must be specified\");\n    return vc.visualizationClass.url;\n}\n/**\n * For given visualization class, return its URI.\n *\n * @param vc - visualization class\n * @returns never null, never empty\n * @public\n */\nexport function visClassUri(vc) {\n    invariant(vc, \"vis class to get URI from must be specified\");\n    return vc.visualizationClass.uri;\n}\n/**\n * For given visualization class, return its identifier.\n *\n * @param vc - visualization class\n * @returns never null, never empty\n * @public\n */\nexport function visClassId(vc) {\n    invariant(vc, \"vis class to get URI from must be specified\");\n    return vc.visualizationClass.identifier;\n}\n//# sourceMappingURL=index.js.map","/**\n * Creates an IdentifierRef from object identifier and given object type.\n *\n * @remarks see {@link IdentifierRef} for more information about identifier references\n *\n * @param identifier - identifier to use\n * @param type - referenced object type\n * @returns identifier reference\n * @public\n */\nexport function idRef(identifier, type) {\n    return type ? { identifier, type } : { identifier };\n}\n/**\n * Creates an UriRef from an URI\n * @param uri - URI to use\n * @returns uri reference\n * @public\n */\nexport function uriRef(uri) {\n    return { uri };\n}\n/**\n * Creates an LocalIdRef from a local identifier\n * @param localIdentifier - local identifier to use\n * @returns local identifier reference\n * @public\n */\nexport function localIdRef(localIdentifier) {\n    return { localIdentifier };\n}\n//# sourceMappingURL=factory.js.map","// (C) 2019-2022 GoodData Corporation\nimport isEmpty from \"lodash/isEmpty.js\";\nimport { invariant } from \"ts-invariant\";\nimport stringify from \"json-stable-stringify\";\n//\n// Type guards\n//\n/**\n * Type guard checking whether object is an URI Reference.\n *\n * @public\n */\nexport function isUriRef(obj) {\n    return !isEmpty(obj) && obj.uri !== undefined;\n}\n/**\n * Type guard checking whether object is an Identifier Reference.\n *\n * @public\n */\nexport function isIdentifierRef(obj) {\n    return !isEmpty(obj) && obj.identifier !== undefined;\n}\n/**\n * Type guard checking whether object is an Identifier Reference or an URI reference.\n *\n * @public\n */\nexport function isObjRef(obj) {\n    return isUriRef(obj) || isIdentifierRef(obj);\n}\n/**\n * Type guard checking whether object is a localId Reference.\n *\n * @public\n */\nexport function isLocalIdRef(obj) {\n    return !isEmpty(obj) && obj.localIdentifier !== undefined;\n}\n/**\n * Retrieves string representation of object reference. This is purely for for representation of\n * references in text, debug and tests.\n *\n * @internal\n */\nexport function objRefToString(objRef) {\n    invariant(objRef, \"object reference must be specified\");\n    if (isIdentifierRef(objRef)) {\n        return `${objRef.identifier}`;\n    }\n    else if (isUriRef(objRef)) {\n        return objRef.uri;\n    }\n    return objRef.localIdentifier;\n}\n/**\n * Serializes an instance of ObjRef to a string representation.\n *\n * @remarks\n * This is suitable when ObjRef needs to be used as a key in dictionaries/objects.\n *\n * Note: there is no loss of information and the serialized value is guaranteed to be stable, meaning same ObjRef\n * will always serialize the same.\n *\n * @param objRef - ref to serialize\n * @remarks see {@link deserializeObjRef}\n * @public\n */\nexport function serializeObjRef(objRef) {\n    return stringify(objRef, { space: 0 });\n}\n/**\n * Deserializes an ObjRef from its pure string representation.\n *\n * @remarks\n * The function will throw an error if the input is not a valid, serialized ObjRef.\n *\n * @param val - string representation of ObjRef\n * @remarks see {@link serializeObjRef}\n * @public\n */\nexport function deserializeObjRef(val) {\n    const obj = JSON.parse(val);\n    invariant(isObjRef(obj) || isLocalIdRef(obj), `Attempting to deserialize ObjRef but the input is invalid: '${val}'`);\n    return obj;\n}\n/**\n * Returns a value indicating whether the two ObjRef instances are semantically equal (i.e. are of the same type and have the same value).\n * Null and undefined are considered equal to each other.\n *\n * @remarks If the objects are ObjRefs of multiple types at once (for example they have identifiers and URIs),\n * the match is tested in the following sequence:\n * 1. identifier\n * 2. URI\n * 3. localIdentifier\n *\n * @public\n */\nexport function areObjRefsEqual(a, b) {\n    if (a == null) {\n        return b == null;\n    }\n    if (isIdentifierRef(a) && isIdentifierRef(b) && a.type && b.type) {\n        return a.identifier === b.identifier && a.type === b.type;\n    }\n    if (isIdentifierRef(a) && isIdentifierRef(b)) {\n        return a.identifier === b.identifier;\n    }\n    if (isUriRef(a) && isUriRef(b)) {\n        return a.uri === b.uri;\n    }\n    return isLocalIdRef(a) && isLocalIdRef(b) && a.localIdentifier === b.localIdentifier;\n}\n//# sourceMappingURL=index.js.map","// (C) 2021 GoodData Corporation\n/**\n * Removes all non MAQL compatible characters from an identifier by replacing them with an underscore.\n * @param identifier - identifier to sanitize\n * @returns sanitized identifier\n */\nexport function sanitizeLocalId(identifier) {\n    return identifier.replace(/[^a-zA-Z0-9_.]/g, \"_\");\n}\n//# sourceMappingURL=sanitizeLocalId.js.map"],"names":["DecoratedExecutionFactory","constructor","decorated","wrapper","this","wrap","execution","forDefinition","def","forItems","items","filters","forBuckets","buckets","forInsight","insight","forInsightByRef","DecoratedPreparedExecution","definition","equals","other","execute","explain","config","fingerprint","withDimensions","dim","createNew","withSorting","withDateFormat","dateFormat","withExecConfig","DecoratedExecutionResult","dimensions","export","options","readAll","readWindow","offset","size","transform","AbstractExecutionFactory","workspace","ExecutionFactoryWithFixedFilters","super","concat","ExecutionFactoryUpgradingToExecByReference","AnalyticalBackendErrorTypes","NO_DATA","DATA_TOO_LARGE","PROTECTED_DATA","UNEXPECTED_HTTP","UNEXPECTED","NOT_SUPPORTED","NOT_IMPLEMENTED","NOT_AUTHENTICATED","LIMIT_REACHED","CONTRACT_EXPIRED","TIMEOUT_ERROR","AnalyticalBackendError","Error","message","abeType","cause","Object","setPrototypeOf","prototype","NoDataError","dataView","DataTooLargeError","TimeoutError","ProtectedDataError","UnexpectedResponseError","httpStatus","responseBody","traceId","UnexpectedError","NotSupported","NotImplemented","NotAuthenticated","reason","LimitReached","ContractExpired","isAnalyticalBackendError","obj","undefined","isNoDataError","isProtectedDataError","isUnexpectedResponseError","isNotAuthenticated","isContractExpired","AttributeBuilder","input","customLocalId","alias","attribute","noAlias","showAllValues","displayForm","ref","localId","trim","length","localIdentifier","defaultLocalId","build","getOrGenerateLocalId","assign","calculateAliasHash","filter","part","join","hasher","append","end","substr","newAttribute","displayFormRefOrId","modifications","modifyAttribute","isAttribute","anyAttribute","_","idMatchAttribute","id","attr","attributeLocalId","attributeOrId","attributeIdentifier","identifier","attributeAlias","attributeDisplayFormRef","MeasureGroupIdentifier","isMeasureGroupIdentifier","itemOrTotal","isDimension","itemIdentifiers","dimensionTotals","totals","dimensionSetTotals","totalsProp","newTwoDimensional","dim1Input","dim2Input","atMostOneMeasureGroup","find","newDimension","reduce","acc","value","push","ids","dimensionsFindItem","dims","result","dimIdx","itemIdx","i","isAttributeSort","attributeSortItem","isAttributeAreaSort","aggregation","isAttributeValueSort","isMeasureSort","measureSortItem","isAttributeLocator","attributeLocatorItem","isTotalLocator","totalLocatorItem","isMeasureLocator","measureLocatorItem","sortDirection","sort","direction","sortEntityIds","res","attributeIdentifiers","measureIdentifiers","allIdentifiers","attrId","locators","forEach","loc","measureId","measureIdentifier","sortMeasureLocators","attributeLocatorIdentifier","locator","attributeLocatorElement","element","newAttributeSort","newAttributeAreaSort","newMeasureSort","measureOrId","attributeLocators","newMeasureSortFromLocators","isTotal","type","newTotal","aliasProp","totalIsNative","total","bucketsAttributes","predicate","b","bucketsMeasures","bucketsFind","idOrFun","bucketsById","indexOf","bucketsItems","bucketsTotals","bucketsIsEmpty","every","bucketsModifyItem","map","bucket","bucketsReduceItem","reducer","anyBucket","idMatchBucket","AGGREGATION_KEYS","getIdentifier","newBucket","content","contentErrorMessage","keys","identifiers","objKey","getAttributeDisplayFormIdentifiers","k","bucketIsEmpty","bucketAttributeIndex","bucketAttribute","index","bucketAttributes","bucketMeasure","bucketMeasureIndex","bucketMeasures","bucketItems","bucketTotals","bucketSetTotals","ComputeRatioRule","disableComputeRatio","item","m","noRatio","bucketModifyItems","bucketItem","bucketItemReduce","cur","idx","src","defValidate","itemsWithLocalId","attributes","measures","groups","measure","emptyDef","sortBy","postProcessing","newDefForItems","newDefForBuckets","newDefForInsight","extraFilters","filteredDef","defWithSorting","sorts","defWithExecConfig","defWithDateFormat","currentPostProcessing","defWithPostProcessing","defWithDimensions","dimsOrGen","maybeGenerator","toDimensions","defaultDimensionsGenerator","defaultDimensionsWithoutBuckets","firstBucket","otherBuckets","firstDim","secondDim","defaultDimensionsWithBuckets","isFilterRelevantForFingerprinting","measureValueFilter","condition","negativeAttributeFilter","notIn","filterFingerprint","measureFingerprint","_a","measureDefinition","measureDefinitionWithSanitizedFilters","measureDefinitionWithDefaults","computeRatio","simpleMeasureFingerprint","attributeFingerprint","sortFingerprint","dimensionFingerprint","withDefaultTotals","defWithFilters","defSetSorts","defSetExecConfig","executionConfig","defSetPostProcessing","defTotals","dimension","defSetDimensions","defFingerprint","_b","hashFun","bind","dataSamplingPercentage","toString","separateFiltersByType","date","measureValue","ranking","f","mergeFilters","originalFilters","addedFilters","filtersToMerge","original","added","attributeFilters","dateFilters","allFilters","grouped","mergedFilters","filtersForDimension","lastFilterForDimension","mergeDateFilters","measureValueFilters","mergeMeasureValueFilters","isPositiveAttributeFilter","positiveAttributeFilter","isNegativeAttributeFilter","isAbsoluteDateFilter","absoluteDateFilter","isRelativeDateFilter","relativeDateFilter","isAllTimeDateFilter","granularity","isAttributeFilter","isDateFilter","isMeasureValueFilter","isRankingFilter","rankingFilter","isFilter","isComparisonCondition","comparison","isRangeCondition","range","isAttributeElementsByRef","uris","isAttributeElementsByValue","values","filterIsEmpty","attributeElementsIsEmpty","in","attributeElements","attributeElementsCount","getAttributeElementsItems","updateAttributeElementsItems","newItems","filterAttributeElements","filterObjRef","dataSet","filterMeasureRef","absoluteDateFilterValues","from","to","relativeDateFilterValues","measureValueFilterMeasure","measureValueFilterCondition","MeasureBuilderBase","title","noTitle","format","defaultFormat","envelope","buildEnvelope","buildDefinition","initializeFromExisting","buildEnvelopeLocalIdPart","generateLocalId","MeasureBuilder","measureOrRef","defaultAggregation","ratio","noFilters","measureItem","aggString","ratioString","filterLocalIdString","JSON","stringify","InlineMeasureBuilder","measureInput","maql","inlineMeasureDefinition","inlineDefinition","ArithmeticMeasureBuilder","operator","op","arithmeticMeasure","operands","measuresOrLocalIds","measuresOrIds","VirtualArithmeticMeasureBuilder","arithmeticDefinition","virtual","PoPMeasureBuilder","masterMeasure","measureOrLocalId","popMeasureDefinition","popAttribute","popAttrIdOrRef","PreviousPeriodMeasureBuilder","previousPeriodMeasure","dateDataSets","dd","convertDd","d","measureIdOrLocalId","newMeasure","modifyMeasure","builder","createBuilder","modifySimpleMeasure","modifyPopMeasure","newVirtualArithmeticMeasure","newPopMeasure","newPreviousPeriodMeasure","anyMeasure","idMatchMeasure","isMeasure","isSimpleMeasure","isMeasureDefinition","isInlineMeasure","isInlineMeasureDefinition","isAdhocMeasure","Array","isArray","isPoPMeasure","isPoPMeasureDefinition","isPreviousPeriodMeasure","isPreviousPeriodMeasureDefinition","isArithmeticMeasure","isArithmeticMeasureDefinition","isVirtualArithmeticMeasure","virtualArithmeticDefinition","isVirtualArithmeticMeasureDefinition","measureLocalId","measureUri","uri","measureDoesComputeRatio","measureMasterIdentifier","measureArithmeticOperands","measureArithmeticOperator","measureAlias","measureTitle","measureFormat","isMeasureFormatInPercent","measureOrFormat","test","replace","measureAggregation","measureFilters","measurePopAttribute","measurePreviousPeriodDateDataSets","isAttributeDescriptor","attributeHeader","isMeasureGroupDescriptor","measureGroupHeader","isMeasureDescriptor","measureHeaderItem","isTotalDescriptor","totalHeaderItem","isColorDescriptor","colorHeaderItem","isResultAttributeHeader","attributeHeaderItem","isResultMeasureHeader","order","isResultTotalHeader","resultHeaderName","header","name","attributeDescriptorLocalId","descriptor","attributeDescriptorName","formOf","isColorMappingItem","color","isInsight","insightBucket","insightBuckets","insightItems","insightMeasures","measurePredicate","insightHasMeasures","insightAttributes","attributePredicate","insightHasAttributes","insightHasDataDefined","insightFilters","insightSorts","attributeIds","measureIds","contains","arr1","arr2","s","entities","insightTotals","insightProperties","properties","insightVisualizationUrl","visualizationUrl","insightVisualizationType","split","insightTitle","insightTags","tags","insightSummary","summary","insightRef","insightId","insightUri","insightCreated","created","insightUpdated","updated","insightIsLocked","isLocked","insightSetProperties","insightSetSorts","insightSetFilters","insightSetBuckets","insightModifyItems","insightReduceItems","insightDisplayFormUsage","inAttributes","inFilters","attributeFilter","inMeasureFilters","idRef","uriRef","localIdRef","isUriRef","isIdentifierRef","isObjRef","isLocalIdRef","objRefToString","objRef","serializeObjRef","space","areObjRefsEqual","a","sanitizeLocalId"],"sourceRoot":""}