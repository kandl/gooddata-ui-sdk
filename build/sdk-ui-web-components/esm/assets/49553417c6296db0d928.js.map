{"version":3,"file":"assets/49553417c6296db0d928.js","mappings":"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","sources":["webpack://@gooddata/sdk-ui-web-components/../sdk-backend-base/esm/normalizingBackend/normalizer.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/colors/index.js","webpack://@gooddata/sdk-ui-web-components/../sdk-model/esm/execution/buckets/bucketItem.js"],"sourcesContent":["// (C) 2007-2023 GoodData Corporation\nimport { attributeAlias, attributeLocalId, filterIsEmpty, isArithmeticMeasureDefinition, isAttributeLocator, isMeasureLocator, isAttributeSort, isLocalIdRef, isMeasureSort, isMeasureValueFilter, isNegativeAttributeFilter, isPoPMeasureDefinition, isPreviousPeriodMeasureDefinition, measureAlias, measureFormat, MeasureGroupIdentifier, measureLocalId, measureMasterIdentifier, measureTitle, measureValueFilterCondition, modifyAttribute, modifyMeasure, isAttributeFilter, isRankingFilter, isAttributeDescriptor, isMeasureDescriptor, isMeasureGroupDescriptor, isResultMeasureHeader, isMeasureDefinition, isPositiveAttributeFilter, } from \"@gooddata/sdk-model\";\nimport { invariant } from \"ts-invariant\";\nimport cloneDeep from \"lodash/cloneDeep.js\";\nimport cloneDeepWith from \"lodash/cloneDeepWith.js\";\nimport keyBy from \"lodash/keyBy.js\";\n/**\n * @internal\n */\nexport class Denormalizer {\n    static from(state) {\n        return new Denormalizer(state);\n    }\n    constructor(state) {\n        this.state = state;\n        /**\n         * Given the current normalization state, this method transforms the dimension descriptors of the\n         * normalized execution, so that all the customization of the original execution definition is restored\n         * into them:\n         *\n         * -  Reverse lookup of local identifiers happens\n         * -  Attribute / Measure name is set according to the defined alias\n         * -  Measure format is set according to the format in definition\n         *\n         * @param normalizedDims - normalized dimension descriptors\n         * @returns new descriptors\n         */\n        this.denormalizeDimDescriptors = (normalizedDims) => {\n            var _a;\n            const measureGroup = (_a = normalizedDims\n                .find((normalizedDim) => normalizedDim.headers.find((header) => isMeasureGroupDescriptor(header)))) === null || _a === void 0 ? void 0 : _a.headers.find((header) => isMeasureGroupDescriptor(header));\n            return cloneDeepWith(normalizedDims, (value) => {\n                var _a;\n                if (isAttributeDescriptor(value)) {\n                    const localIdentifier = this.originalLocalId(value.attributeHeader.localIdentifier);\n                    const attribute = this.originalAttributes[localIdentifier];\n                    const name = attributeAlias(attribute) || value.attributeHeader.formOf.name;\n                    return {\n                        attributeHeader: Object.assign(Object.assign({}, value.attributeHeader), { localIdentifier, formOf: Object.assign(Object.assign({}, value.attributeHeader.formOf), { name }) }),\n                    };\n                }\n                else if (isMeasureDescriptor(value)) {\n                    const localIdentifier = this.originalLocalId(value.measureHeaderItem.localIdentifier);\n                    const measure = this.originalMeasures[localIdentifier];\n                    const masterMeasureId = measureMasterIdentifier(measure);\n                    const masterMeasureInheritFormat = isMeasureGroupDescriptor(measureGroup) &&\n                        ((_a = measureGroup.measureGroupHeader.items.find((item) => this.originalLocalId(item.measureHeaderItem.localIdentifier) === masterMeasureId)) === null || _a === void 0 ? void 0 : _a.measureHeaderItem.format);\n                    /**\n                     * Measure format is taken by priority from:\n                     * 1) the chosen format of the measure (undefined for inherited format and derived measures)\n                     * 2) the chosen format of the master measure (undefined for inherited format and master)\n                     * 3) the inherited format of master measure (undefined for master)\n                     * 4) the inherited format for master measure or default \"#,#.##\" for derived\n                     */\n                    const format = measureFormat(measure) ||\n                        (masterMeasureId && measureFormat(this.originalMeasures[masterMeasureId])) ||\n                        masterMeasureInheritFormat ||\n                        value.measureHeaderItem.format;\n                    const name = this.originalMeasureTitle(measure, value.measureHeaderItem.name);\n                    return {\n                        measureHeaderItem: Object.assign(Object.assign({}, value.measureHeaderItem), { localIdentifier,\n                            format,\n                            name }),\n                    };\n                }\n                // let the default logic handle this\n                return undefined;\n            });\n        };\n        /**\n         * Derived measures or arithmetic measures have the 'name' in result header defaulted to measure\n         * localId. This method deals with it. It creates a copy of headers with the measure headers denormalized,\n         * values replaced with the contents of alias or title (whichever comes first).\n         *\n         * @param headerItems - headers to denormalize, copy will be done\n         * @returns new headers\n         */\n        this.denormalizeHeaders = (headerItems) => {\n            return cloneDeepWith(headerItems, (value) => {\n                if (isResultMeasureHeader(value)) {\n                    return {\n                        measureHeaderItem: {\n                            name: this.fillOriginalMeasureTitle(value.measureHeaderItem.name),\n                            order: value.measureHeaderItem.order,\n                        },\n                    };\n                }\n                // let the default logic handle this\n                return undefined;\n            });\n        };\n        this.originalLocalId = (normalized) => {\n            const value = this.state.n2oMap[normalized];\n            invariant(value, `mapping from normalized to real localId does not exist. Normalized: ${normalized}`);\n            return value;\n        };\n        this.fillOriginalMeasureTitle = (name) => {\n            const originalLocalId = this.state.n2oMap[name];\n            if (!originalLocalId) {\n                return name;\n            }\n            const measure = this.originalMeasures[originalLocalId];\n            if (!measure) {\n                return name;\n            }\n            return this.originalMeasureTitle(measure, name);\n        };\n        this.originalMeasureTitle = (originalDef, nameFromBackend) => {\n            return measureAlias(originalDef) || measureTitle(originalDef) || nameFromBackend;\n        };\n        this.originalAttributes = keyBy(state.original.attributes, attributeLocalId);\n        this.originalMeasures = keyBy(state.original.measures, measureLocalId);\n    }\n}\n/**\n * The normalization of execution definition means stripping away all the detail that is unnecessary for the\n * backend:\n *\n * -  attribute / measure alias\n * -  measure title\n * -  measure format\n * -  custom-crafted local IDs\n *\n * The code does the job by _mutating_ a clone of the original definition. The mutation approach, while not\n * backed by functionality in sdk-model and therefore somewhat hacky, is a simpler one for this task.\n *\n * The main reason behind that is the occurrence of attribute and measure objects in multiple parts of the\n * execution definition: same attributes and measures are referenced from both buckets and the attributes and measures\n * props of the execution definition. Mutating values means that after normalizing values the execution definition\n * is fully normalized.\n *\n * @internal\n */\nexport class Normalizer {\n    static normalize(def, options) {\n        const n = new Normalizer(def, options);\n        return n.normalize();\n    }\n    constructor(original, options = {}) {\n        this.original = original;\n        this.options = options;\n        /**\n         * original to normalized local id map\n         */\n        this.o2nMap = {};\n        /**\n         * normalized to original local id map\n         */\n        this.n2oMap = {};\n        this.originalMeasures = new Map();\n        this.alreadyNormalized = [];\n        /**\n         * Creates a new mapping between original local ID and the proposed normalized local ID. This method\n         * ensures uniqueness of the normalized local ID. If the proposed normalized local ID is taken, it will\n         * append a suffix to make a unique local ID.\n         *\n         * This can happen if the original execution definition contains same measure / attribute multiple times,\n         * each time using different local ID.\n         */\n        this.createUniqueMapping = (original, normalized) => {\n            invariant(!this.o2nMap[original], `duplicate localId used in execution definition: ${original}`);\n            let uniqueNormalized = normalized;\n            let attempt = 1;\n            while (this.n2oMap[uniqueNormalized]) {\n                uniqueNormalized = `${normalized}_${attempt}`;\n                attempt += 1;\n            }\n            this.o2nMap[original] = uniqueNormalized;\n            this.n2oMap[uniqueNormalized] = original;\n            return uniqueNormalized;\n        };\n        this.normalizedLocalId = (original) => {\n            const value = this.o2nMap[original];\n            invariant(value, `dangling localId reference. Target: ${original}`);\n            return value;\n        };\n        this.maybeNormalizedLocalId = (original) => {\n            return this.o2nMap[original];\n        };\n        this.normalizeAttributes = () => {\n            this.normalized.attributes.forEach((attr) => {\n                if (!this.options.keepRemovableProperties) {\n                    delete attr.attribute.alias;\n                }\n                const originalLocalId = attributeLocalId(attr);\n                const normalizedLocalId = attributeLocalId(modifyAttribute(attr, (m) => m.noAlias().defaultLocalId()));\n                attr.attribute.localIdentifier = this.createUniqueMapping(originalLocalId, normalizedLocalId);\n            });\n        };\n        this.normalizeTotal = (total) => {\n            var _a, _b;\n            // safely normalize total, when not found in the converted\n            // attributes/measures, keep the original identifier\n            return Object.assign(Object.assign({}, total), { attributeIdentifier: (_a = this.maybeNormalizedLocalId(total.attributeIdentifier)) !== null && _a !== void 0 ? _a : total.attributeIdentifier, measureIdentifier: (_b = this.maybeNormalizedLocalId(total.measureIdentifier)) !== null && _b !== void 0 ? _b : total.measureIdentifier });\n        };\n        this.normalizeTotals = () => {\n            this.normalized.buckets.forEach((bucket) => {\n                if (bucket.totals) {\n                    bucket.totals = bucket.totals.map(this.normalizeTotal);\n                }\n            });\n        };\n        /**\n         * Simple measure normalization will toss away noop filters. There is nothing else to do.\n         */\n        this.normalizeSimple = (def) => {\n            var _a;\n            if (!def.measureDefinition.filters) {\n                return;\n            }\n            def.measureDefinition.filters = (_a = def.measureDefinition.filters) === null || _a === void 0 ? void 0 : _a.filter((filter) => {\n                return !isNegativeAttributeFilter(filter) || !filterIsEmpty(filter);\n            });\n        };\n        this.normalizePoP = (def, path) => {\n            const masterMeasure = def.popMeasureDefinition.measureIdentifier;\n            const normalizedId = this.maybeNormalizedLocalId(masterMeasure) || this.normalizeMeasureByLocalId(masterMeasure, path);\n            def.popMeasureDefinition.measureIdentifier = normalizedId;\n        };\n        this.normalizePreviousPeriod = (def, path) => {\n            const masterMeasure = def.previousPeriodMeasure.measureIdentifier;\n            const normalizedId = this.maybeNormalizedLocalId(masterMeasure) || this.normalizeMeasureByLocalId(masterMeasure, path);\n            def.previousPeriodMeasure.measureIdentifier = normalizedId;\n        };\n        this.normalizeArithmetic = (def, path) => {\n            const normalizedIds = def.arithmeticMeasure.measureIdentifiers.map((operand) => {\n                return this.maybeNormalizedLocalId(operand) || this.normalizeMeasureByLocalId(operand, path);\n            });\n            def.arithmeticMeasure.measureIdentifiers = normalizedIds;\n        };\n        this.normalizeMeasure = (measure, path = new Set()) => {\n            const localId = measureLocalId(measure);\n            const definition = measure.measure.definition;\n            /*\n             * don't do anything if the measure is already normalized;\n             *\n             * this can happen as master / derived / arithmetic measures can be mixed in the measures array\n             * in any order & the recursive algorithm goes after the leaves first and then gets to the measure\n             * once again as it walks the array\n             */\n            if (this.alreadyNormalized.find((m) => m === measure)) {\n                // if already normalized, the measure has been mutated and the localId is the normalized one\n                return localId;\n            }\n            /*\n             * circular dependency detection and bail-out.\n             */\n            invariant(!path.has(localId), `circular dependency on measure with localId ${localId}`);\n            path.add(localId);\n            if (isPoPMeasureDefinition(definition)) {\n                this.normalizePoP(definition, path);\n            }\n            else if (isPreviousPeriodMeasureDefinition(definition)) {\n                this.normalizePreviousPeriod(definition, path);\n            }\n            else if (isArithmeticMeasureDefinition(definition)) {\n                this.normalizeArithmetic(definition, path);\n            }\n            else if (isMeasureDefinition(definition)) {\n                this.normalizeSimple(definition);\n            }\n            if (!this.options.keepRemovableProperties) {\n                delete measure.measure.alias;\n                delete measure.measure.title;\n                delete measure.measure.format;\n            }\n            const newLocalId = measureLocalId(modifyMeasure(measure, (m) => m.noAlias().noTitle().defaultFormat().defaultLocalId()));\n            const newUniqueLocalId = this.createUniqueMapping(localId, newLocalId);\n            measure.measure.localIdentifier = newUniqueLocalId;\n            this.alreadyNormalized.push(measure);\n            return newUniqueLocalId;\n        };\n        this.normalizeMeasureByLocalId = (localId, path) => {\n            const measure = this.originalMeasures.get(localId);\n            invariant(measure, `measure with localId ${localId} could not be found`);\n            return this.normalizeMeasure(measure, path);\n        };\n        this.normalizeMeasures = () => {\n            this.normalized.measures.forEach((measure) => this.normalizeMeasure(measure));\n        };\n        this.normalizeFilters = () => {\n            this.normalized.filters.forEach((filter) => {\n                if (isMeasureValueFilter(filter)) {\n                    const ref = filter.measureValueFilter.measure;\n                    if (isLocalIdRef(ref)) {\n                        ref.localIdentifier = this.normalizedLocalId(ref.localIdentifier);\n                    }\n                }\n                if (isRankingFilter(filter)) {\n                    const { measure, attributes = [] } = filter.rankingFilter;\n                    [...attributes, measure].filter(isLocalIdRef).forEach((ref) => {\n                        ref.localIdentifier = this.normalizedLocalId(ref.localIdentifier);\n                    });\n                }\n            });\n        };\n        this.normalizeSorts = () => {\n            this.normalized.sortBy.forEach((sort) => {\n                if (isAttributeSort(sort)) {\n                    sort.attributeSortItem.attributeIdentifier = this.normalizedLocalId(sort.attributeSortItem.attributeIdentifier);\n                }\n                else if (isMeasureSort(sort)) {\n                    sort.measureSortItem.locators.forEach((locator) => {\n                        if (isAttributeLocator(locator)) {\n                            locator.attributeLocatorItem.attributeIdentifier = this.normalizedLocalId(locator.attributeLocatorItem.attributeIdentifier);\n                        }\n                        else if (isMeasureLocator(locator)) {\n                            locator.measureLocatorItem.measureIdentifier = this.normalizedLocalId(locator.measureLocatorItem.measureIdentifier);\n                        }\n                    });\n                }\n            });\n        };\n        this.normalizeDimensions = () => {\n            this.normalized.dimensions.forEach((dim) => {\n                dim.itemIdentifiers = dim.itemIdentifiers.map((item) => {\n                    if (item === MeasureGroupIdentifier) {\n                        return item;\n                    }\n                    else {\n                        return this.normalizedLocalId(item);\n                    }\n                });\n                if (dim.totals) {\n                    dim.totals.forEach((total) => {\n                        total.attributeIdentifier = this.normalizedLocalId(total.attributeIdentifier);\n                        total.measureIdentifier = this.normalizedLocalId(total.measureIdentifier);\n                    });\n                }\n            });\n        };\n        this.normalize = () => {\n            this.normalizeAttributes();\n            this.normalizeMeasures();\n            this.normalizeFilters();\n            this.normalizeSorts();\n            this.normalizeDimensions();\n            this.normalizeTotals();\n            return {\n                normalized: this.normalized,\n                original: this.original,\n                n2oMap: this.n2oMap,\n            };\n        };\n        const copy = cloneDeep(this.original);\n        // throw away noop filters\n        const filters = copy.filters.filter((f) => {\n            if (isAttributeFilter(f)) {\n                return !filterIsEmpty(f) || isPositiveAttributeFilter(f);\n            }\n            else if (isMeasureValueFilter(f)) {\n                return measureValueFilterCondition(f) !== undefined;\n            }\n            return true;\n        });\n        this.normalized = Object.assign(Object.assign({}, copy), { filters });\n        copy.measures.forEach((measure) => this.originalMeasures.set(measureLocalId(measure), measure));\n    }\n}\n//# sourceMappingURL=normalizer.js.map","// (C) 2019-2022 GoodData Corporation\nimport isEmpty from \"lodash/isEmpty.js\";\nfunction isRgbChannel(c) {\n    return c !== undefined && typeof c === \"number\" && c >= 0 && c < 256;\n}\nfunction isRgbColorValue(obj) {\n    if (!isEmpty(obj)) {\n        const { r, g, b } = obj;\n        return isRgbChannel(r) && isRgbChannel(g) && isRgbChannel(b);\n    }\n    return false;\n}\n/**\n * Type guard checking whether the provided object is a {@link IColorPaletteItem}\n *\n * @public\n */\nexport function isColorPaletteItem(obj) {\n    if (!isEmpty(obj)) {\n        const { guid, fill } = obj;\n        return typeof guid === \"string\" && guid !== undefined && isRgbColorValue(fill);\n    }\n    return false;\n}\n//\n// Type guards\n//\n/**\n * Type guard checking whether the provided object is a {@link IColorFromPalette}\n *\n * @public\n */\nexport function isColorFromPalette(obj) {\n    return !isEmpty(obj) && obj.type === \"guid\";\n}\n/**\n * Type guard checking whether the provided object is a {@link IRgbColor}\n *\n * @public\n */\nexport function isRgbColor(obj) {\n    return !isEmpty(obj) && obj.type === \"rgb\";\n}\n/**\n * Returns RGB code representing the color in the provided color palette items.\n *\n * @param item - color palette item\n * @returns an `rgb(red#,green#,blue#)` code\n * @public\n */\nexport function colorPaletteItemToRgb(item) {\n    const { r, g, b } = item.fill;\n    return `rgb(${r},${g},${b})`;\n}\n/**\n * Returns a list of RGB color codes for all items in the provided color palette.\n *\n * @param palette - color palette\n * @returns list with the same cardinality as the color palette. RGB colors appear in the same order in which\n * they appear in the palette\n * @public\n */\nexport function colorPaletteToColors(palette) {\n    return palette.map(colorPaletteItemToRgb);\n}\n//# sourceMappingURL=index.js.map","// (C) 2019-2020 GoodData Corporation\nimport { isAttribute, attributeLocalId } from \"../attribute/index.js\";\nimport { isMeasure, measureLocalId } from \"../measure/index.js\";\nimport { invariant, InvariantError } from \"ts-invariant\";\n/**\n * Gets value of local identifier of bucketItem\n *\n * @param bucketItem - bucketItem to work with\n * @returns value of local identifier\n * @public\n */\nexport function bucketItemLocalId(bucketItem) {\n    invariant(bucketItem, \"bucketItem must be specified\");\n    if (isAttribute(bucketItem)) {\n        return attributeLocalId(bucketItem);\n    }\n    if (isMeasure(bucketItem)) {\n        return measureLocalId(bucketItem);\n    }\n    throw new InvariantError(`Unknown bucketItem \"${bucketItem}\"`);\n}\n//# sourceMappingURL=bucketItem.js.map"],"names":["Denormalizer","static","state","constructor","this","denormalizeDimDescriptors","normalizedDims","_a","measureGroup","find","normalizedDim","headers","header","value","localIdentifier","originalLocalId","attributeHeader","attribute","originalAttributes","name","formOf","Object","assign","measureHeaderItem","measure","originalMeasures","masterMeasureId","masterMeasureInheritFormat","measureGroupHeader","items","item","format","originalMeasureTitle","denormalizeHeaders","headerItems","fillOriginalMeasureTitle","order","normalized","n2oMap","originalDef","nameFromBackend","original","attributes","measures","Normalizer","def","options","normalize","o2nMap","Map","alreadyNormalized","createUniqueMapping","uniqueNormalized","attempt","normalizedLocalId","maybeNormalizedLocalId","normalizeAttributes","forEach","attr","keepRemovableProperties","alias","m","noAlias","defaultLocalId","normalizeTotal","total","_b","attributeIdentifier","measureIdentifier","normalizeTotals","buckets","bucket","totals","map","normalizeSimple","measureDefinition","filters","filter","normalizePoP","path","masterMeasure","popMeasureDefinition","normalizedId","normalizeMeasureByLocalId","normalizePreviousPeriod","previousPeriodMeasure","normalizeArithmetic","normalizedIds","arithmeticMeasure","measureIdentifiers","operand","normalizeMeasure","Set","localId","definition","has","add","title","newLocalId","noTitle","defaultFormat","newUniqueLocalId","push","get","normalizeMeasures","normalizeFilters","ref","measureValueFilter","rankingFilter","normalizeSorts","sortBy","sort","attributeSortItem","measureSortItem","locators","locator","attributeLocatorItem","measureLocatorItem","normalizeDimensions","dimensions","dim","itemIdentifiers","copy","f","undefined","set","isRgbChannel","c","isColorPaletteItem","obj","guid","fill","r","g","b","isRgbColorValue","isColorFromPalette","type","isRgbColor","colorPaletteItemToRgb","colorPaletteToColors","palette","bucketItemLocalId","bucketItem"],"sourceRoot":""}